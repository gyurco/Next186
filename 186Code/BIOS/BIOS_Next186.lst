Microsoft (R) Macro Assembler Version 6.14.8444		    03/07/22 17:52:44
BIOS_Next186.asm					     Page 1 - 1


				; This file is part of the Next186 SoC PC project
				; http://opencores.org/project,next186

				; Filename: BIOS_Next186.asm
				; Description: Part of the Next186 SoC PC project, ROM BIOS code
				; Version 1.0
				; Creation date: Feb-Jun 2013

				; Author: Nicolae Dumitrache 
				; e-mail: ndumitrache@opencores.org

				; -------------------------------------------------------------------------------------
				 
				; Copyright (C) 2013 Nicolae Dumitrache
				 
				; This source file may be used and distributed without 
				; restriction provided that this copyright statement is not 
				; removed from the file and that any derivative work contains 
				; the original copyright notice and the associated disclaimer.
				 
				; This source file is free software; you can redistribute it 
				; and/or modify it under the terms of the GNU Lesser General 
				; Public License as published by the Free Software Foundation;
				; either version 2.1 of the License, or (at your option) any 
				; later version. 
				 
				; This source is distributed in the hope that it will be 
				; useful, but WITHOUT ANY WARRANTY; without even the implied 
				; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
				; PURPOSE. See the GNU Lesser General Public License for more 
				; details. 
				 
				; You should have received a copy of the GNU Lesser General 
				; Public License along with this source; if not, download it 
				; from http://www.opencores.org/lgpl.shtml 
				 
				; -----------------------------------------------------------------------

				; Additional Comments: 
				; Assembled with MASM v6.14.8444
				; Next186 SoC PC have no ROM, only RAM. The bootstrap code is the initial value of cache 
				;  (last half 1K = 4 lines of 256bytes each), initially marked as "dirty", in order to
				;  be saved in RAM at first flush
				; The bootstrap code may load the BIOS from SD, or from RS232, and place it at F000:E000



				.186
				.model tiny
 0000				.code

 = 0001				SCANCODE1   equ 1

				;-------------------------- BIOS data area (BDA) -----------------
				;40:0000   2  Base port address of first RS-232 adapter (COM1) See COM Ports
				;40:0002   2  Port of COM2
				;40:0004   2  Port of COM3
				;40:0006   2  Port of COM4
				;40:0008   2  Base port addr of first parallel printer (LPT1)  Printer Ports
				;40:000A   2  Port of LPT2
				;40:000C   2  Port of LPT3
				;40:000E   2  Port of LPT4
				;40:0010   2  Equipment/hardware installed/active; see Equipment List
				;40:0012   1  Errors in PCjr infrared keyboard link
				;40:0013   2  Total memory in K-bytes (same as obtained via INT 12H)
				;40:0015   2  Scratch pad for manufacturing error tests
				;
				;40:0017   2  Keyboard status bits; see Keyboard Shift Status Flags
				;40:0019   1  Current (accumulating) value of Alt+numpad pseudo-key input;
				;             normally 0.  When [Alt] is released, value is stored in
				;             keyboard buffer at 001e.
				;40:001a   2  Addr of keyboard buffer head (keystroke at that addr is next)
				;40:001c   2  Address of keyboard buffer tail
				;40:001e  32  Keyboard buffer.  BIOS stores keystrokes here (head and tail
				;             point to addresses from 041eH to 043dH inclusive).
				;
				;40:003e   1  Diskette drive needs recalibration (bit 0=A, bit 1=B, etc.)
				;             bits 4-5 indicate which drive is currently selected
				;40:003f   1  Diskette motor is running (bit 0=drive A, bit 1=B, etc.)
				;40:0040   1  Time until motor off. INT 08H turns motor off when this is 0.
				;40:0041   1  Diskette error status; same as status returned by INT 13H
				;40:0042   7  Diskette controller status information area
				;
				;40:0049   1  Current active video mode.  See Video Modes and INT 10H.
				;40:004a   2  Screen width in text columns
				;40:004c   2  Length (in bytes) of video area (regen size)
				;40:004e   2  Offset from video segment of active video memory page
				;40:0050  16  Cursor location (8 byte-pairs; low byte=clm, hi byte=row)
				;40:0060   2  Cursor size/shape.  Low byte=end scan line; hi byte=start line.
				;40:0062   1  Current active video page number
				;40:0063   2  Port address for 6845 video controller chip; see CGA I/O Ports
				;40:0065   1  Current value of 6845 video ctrlr CRT_MODE (port 3x8H register)
				;40:0066   1  Current value of 6845 video ctrlr CRT_PALETTE (port 3x9H reg)
				;
				;40:0067   5  Cassette data area or POST data area
				;               40:0067: 1 byte mouse buffer counter (DataCounter)
				;               40:0068: 1 byte mouse packet size (PacketSize): 0 for 3 bytes, 1 for 4 bytes (Intellimouse)
				;				40:0069: 2 bytes palette offset during set video mode	
				;
				;40:006c   4  Timer tick counter (count of 55ms ticks since CPU reset)
				;40:0070   1  Timer overflow flag (timer has rolled over 24 hr)
				;40:0071   1  Ctrl-Break flag.  Bit 7=1 when break was pressed.  This never
				;             gets reset unless you do it yourself.
				;
				;40:0072   2  1234H means Ctrl+Alt+Del reboot is in progress.  BIOS checks
				;             this to avoid doing a "cold boot" with the time-consuming POST
				;             4321H means reset, preserving memory
				;             5678H, 9abcH, and abcdH (are internal PC Convertible codes)
				;
				;40:0074   4  PCjr diskette or AT hard disk control area
				;  (0074)   1 Status of last fixed-disk drive operation
				;  (0075)   1 Number of hard disk drives for AT
				;  (0077)   1 Hard disk port for XT.  See XT Hard Disk Ports.
				;40:0078   4  Printer time-out values (478H=Lpt1, 478H=Lpt2...)
				;40:007c   4  RS-232 time-out values  (47cH=Com1, 47dH=Com2...)
				;
				;40:0080   2  AT PS/2 keyboard buffer offset start address (usually 01eH)
				;40:0082   2                                   end address (usually 003eH)
				;
				;40:0084   1  EGA text rows-1  (maximum valid row value)
				;40:0085   2  EGA bytes per character (scan-lines/char used in active mode)
				;40:0087   1  EGA flags; see EgaMiscInfoRec
				;40:0088   1  EGA flags; see EgaMiscInfo2Rec
				;40:0089   1  VGA flags; see VgaFlagsRec
				;             See also:  EGA/VGA Data Areas
				;
				;40:008b   1  AT PS/2 Media control: data rate, step rate
				;40:008c   1  AT PS/2 Hard disk drive controller status
				;40:008d   1  AT PS/2 Hard disk drive error status
				;40:008e   1  AT PS/2 Hard disk drive interrupt control
				;
				;40:0090   1  AT PS/2 Disk media state bits for drive 0
				;40:0091   1                                for drive 1
				;40:0092   1  AT PS/2 Disk operation started flag for drive 0
				;40:0093   1                                      for drive 1

				;40:0094   1  AT PS/2 Present cylinder number for drive 0
				;40:0095   1                                  for drive 1
						; 2 - Number of 512bytes sectors of HD0
				;
				;40:0096   1  AT Keyboard flag bit 4=1 (10H) if 101-key keyboard is attached
				;40:0097   1  AT Keyboard flag for LED 'key lock' display
				;             bits 0-2 are ScrollLock, NumLock, CapsLock
				;
				;40:0098   4  AT Pointer to 8-bit user wait flag; see INT 15H 86H
				;40:009c   4  AT Microseconds before user wait is done
				;40:00a0   1  AT User wait activity flag:
				;                01H=busy, 80H=posted, 00H=acknowledged
				;
				;40:00a1   7  AT Reserved for network adapters
				;               40:00a1: 4 bytes far pointer to mouse callback (HandlerPtr)
				;               40:00a5: 3 bytes mouse buffer (DataBuffer)
				;
				;40:00a8   4  EGA Address of table of pointers; see EgaSavePtrRec
				;40:00ac  68  Reserved
				;40:00f0  16  (IAC) Inter-Aapplication Communication area.  Programs may use
				;             this area to store status, etc.  Might get overwritten by
				;             another program.

				; http://www.ctyme.com/intr/int.htm

				; video memory: 8 physical segments at 0a000h, 0b000h, 0c000h, 0d000h, 0e000h, 0f000h, 10000h, 11000h
				; Memory segments mapping
				; 1Mb virtual seg address   physical seg address
				;       0000h                   0000h
				;       1000h                   1000h
				;       2000h                   2000h
				;       3000h                   3000h
				;       4000h                   4000h
				;       5000h                   5000h
				;       6000h                   6000h
				;       7000h                   7000h
				;       8000h                   8000h
				;       9000h                   9000h
				;       a000h                   a000h       - video
				;       b000h                   b000h       - video
				;       c000h                   12000h
				;       d000h                   13000h
				;       e000h                   14000h
				;       f000h                   15000h


 = 0200				RAMSize   equ    200h        ; 64KB segments

				; Graphics character set
 = bios - 800h			font8x8		equ	bios - 800h        
 = font8x8 - 1000h		font8x16	equ	font8x8 - 1000h    
 = font8x16 - 0e00h		font8x14	equ	font8x16 - 0e00h


						org 0e000h
 E000				bios:        
 E000 4E 65 78 74 31 38		biosmsg     db 'Next186 MiST SoC PC BIOS (C) 2017 Nicolae Dumitrache', 0
       36 20 4D 69 53 54
       20 53 6F 43 20 50
       43 20 42 49 4F 53
       20 28 43 29 20 32
       30 31 37 20 4E 69
       63 6F 6C 61 65 20
       44 75 6D 69 74 72
       61 63 68 65 00
 E035 4D 42 20 53 44 20		msgmb       db 'MB SD Card', 13, 10, 0
       43 61 72 64 0D 0A
       00
 E042 50 53 32 20 4B 42		msgkb       db 'PS2 KB detected', 13, 10, 0
       20 64 65 74 65 63
       74 65 64 0D 0A 00

						org 0e05bh
 E05B				coldboot:
 E05B				warmboot:
 E05B  FA					cli
 E05C  FC					cld
 E05D  B8 0030					mov     ax, 30h
 E060  8E D0					mov     ss, ax
 E062  BC 0100					mov     sp, 100h
						
 E065  6A 00					push    0
 E067  9D					popf
						
 E068  B0 36					mov     al, 36h
 E06A  E6 43					out     43h, al
 E06C  33 C0					xor     ax, ax
 E06E  E7 07			        out     7, ax       ; NMIonIORQ_HI = 0
 E070  E6 40					out     40h, al
 E072  E6 40					out     40h, al      ; 18Hz PIT CH0
 E074  E6 61					out     61h, al      ; speaker off
 E076  F6 D0					not     al
 E078  E6 21					out     21h, al      ; disable all interrupts
 E07A  E6 A1					out		0a1h, al
 E07C  E7 06			        out     6, ax       ; NMIonIORQ_LO = 255 -> disabled
						

				; ------------------ MAP init
 E07E  E8 1666					call    flush
 E081  B8 0015					mov     ax, 15h     ; BIOS physical segment 15h mapped on virtual segment 0ch
 E084  E7 8C					out     8ch, ax
 E086  68 C000					push    0c000h
 E089  07					pop     es
 E08A  68 F000					push    0f000h
 E08D  1F					pop     ds
 E08E  33 F6					xor     si, si
 E090  33 FF					xor     di, di
 E092  B9 8000					mov     cx, 8000h
 E095  F3/ A5					rep     movsw       ; copy BIOS virtual segment 0fh over physical segment 15h

 E097  E8 164D					call    flush
 E09A  BA 0080					mov     dx, 80h      
 E09D  33 C0					xor     ax, ax
 E09F				mapi:        
 E09F  EF					out     dx, ax
 E0A0  40					inc     ax
 E0A1  42					inc     dx
 E0A2  3C 0C					cmp     al, 0ch
 E0A4  75 02					jne     short mapi1
 E0A6  04 06					add     al, 6
 E0A8				mapi1:        
 E0A8  3C 16					cmp     al, 16h
 E0AA  75 F3					jne     short mapi
						
				; -------------------- Interrupt table init
 E0AC  6A 00					push    0
 E0AE  1F					pop     ds
 E0AF  1E					push    ds
 E0B0  07					pop     es
 E0B1  33 F6					xor     si, si
 E0B3  BF 0004					mov     di, 4
 E0B6  C7 04 F6E6 R				mov     word ptr [si], offset defint
 E0BA  8C 4C 02					mov     word ptr [si+2], cs
 E0BD  B9 00FE					mov     cx, 256-2
 E0C0  F3/ A5					rep     movsw
 E0C2  C7 06 001C E2FA R			mov     word ptr ds:[7*4], offset int07
 E0C8  C7 06 0020 E32A R			mov     word ptr ds:[8*4], offset int08
 E0CE  C7 06 0024 E380 R			mov     word ptr ds:[9*4], offset int09
 E0D4  C7 06 0040 E5A3 R			mov     word ptr ds:[10h*4], offset int10        
 E0DA  C7 06 0044 EF1D R			mov     word ptr ds:[11h*4], offset int11        
 E0E0  C7 06 0048 EF26 R			mov     word ptr ds:[12h*4], offset int12        
 E0E6  C7 06 004C EF2F R			mov     word ptr ds:[13h*4], offset int13        
 E0EC  C7 06 0050 F11C R			mov     word ptr ds:[14h*4], offset int14        
 E0F2  C7 06 0054 F26D R			mov     word ptr ds:[15h*4], offset int15
 E0F8  C7 06 0058 F427 R			mov     word ptr ds:[16h*4], offset int16
 E0FE  C7 06 0060 F512 R			mov     word ptr ds:[18h*4], offset int18
 E104  C7 06 0064 F591 R			mov     word ptr ds:[19h*4], offset int19
 E10A  C7 06 0068 F5AB R			mov     word ptr ds:[1ah*4], offset int1a
 E110  C7 06 01C0 F5D7 R			mov     word ptr ds:[70h*4], offset int70
 E116  C7 06 01D0 F60F R			mov     word ptr ds:[74h*4], offset int74

				; ------------------- BDA init
 E11C  6A 40					push    40h
 E11E  1F					pop     ds
 E11F  1E					push    ds
 E120  07					pop     es
 E121  33 FF					xor     di, di
 E123  33 F6					xor     si, si
 E125  33 C0					xor     ax, ax
 E127  B1 80					mov     cl, 80h
 E129  F3/ AB					rep     stosw
 E12B  C7 04 03F8				mov		word ptr [si+00h], 3f8h	 ; COM1 base port address
 E12F  C7 44 08 0378				mov		word ptr [si+08h], 378h	 ; LPT1 base port address
 E134  C6 44 10 24				mov     byte ptr [si+10h], 24h   ; equipment word (color 80x25, PS2 mouse present)
 E138  C7 44 13 0280				mov     word ptr [si+13h], 640   ; memory size in KB
 E13D  83 44 1A 1E				add     word ptr [si+1ah], 1eh   ; next char pointer in kb buffer
 E141  83 44 1C 1E				add     word ptr [si+1ch], 1eh   ; last char pointer in kb buffer
 E145  C7 44 60 0E0F				mov     word ptr [si+60h], 0e0fh ; cursor shape
 E14A  C7 44 63 03D4				mov     word ptr [si+63h], 3d4h  ; video port address
 E14F  83 84 0080 1E				add     word ptr [si+80h], 1eh   ; start kb buffer
 E154  83 84 0082 3E				add     word ptr [si+82h], 3eh   ; end kb buffer
 E159  C7 84 0087 0940				mov     word ptr [si+87h], 0940h ; video adapter options (512Kb video)
 E15F  C7 84 0089 0B71				mov     word ptr [si+89h], 0b71h ; VGA video flags: 400 line text mode, default palette loading on (0), blinking on
 E165  C6 84 0096 10				mov     byte ptr [si+96h], 10h   ; 101 keyboard installed
				 
				; ------------------- Graph mode init
 E16A  B8 0003					mov     ax, 3
 E16D  CD 10					int     10h

				 ; ------------------- KB init ----------------
 E16F  B0 AE					mov     al, 0aeh
 E171  E6 64					out     64h, al     ; enable kb
 E173  B0 A7					mov     al, 0a7h
 E175  E6 64					out     64h, al     ; disable mouse
 E177  B9 0019					mov     cx, 25
 E17A				kbi1:       
 E17A  E8 1532					call    getps2byte
 E17D  E2 FB					loop    short kbi1  ; wait for kb timeout
 E17F  B4 FF					mov     ah, 0ffh    ; reset kb
 E181  F8					clc                 ; kb command
 E182  E8 1544					call    sendcmd   
 E185  72 31					jc      short nokb
 E187  B1 19					mov     cl, 25
 E189				kbi2:        
 E189  49					dec     cx
 E18A  E3 2C					jcxz    short nokb
 E18C  E8 1520					call    getps2byte
 E18F  72 F8					jc      short kbi2  ; wait for BAT
 E191  3C AA					cmp     al, 0aah
 E193  75 23					jne     short nokb
 E195  B4 F2					mov     ah, 0f2h    ; kb id
 E197  E8 152F					call    sendcmd     ; CF = 0
 E19A  72 1C					jc      short nokb
 E19C  E8 1510					call    getps2byte
 E19F  3C AB					cmp     al, 0abh
 E1A1  75 15					jne     short nokb
 E1A3  E8 1509					call    getps2byte
 E1A6  3C 83					cmp     al, 83h
				; set scan code 1
				IFDEF SCANCODE1
 E1A8  75 0E					jne     short nokb
 E1AA  B4 F0					mov     ah, 0f0h    ; kb scan set
 E1AC  E8 151A					call    sendcmd   
 E1AF  72 07					jc      short nokb
 E1B1  B4 01					mov     ah, 1       ; scan set 1
 E1B3  E8 1513					call    sendcmd   
 E1B6  73 05					jnc     short kbok
				ELSE
				ENDIF        

 E1B8				nokb:   
 E1B8  C6 06 0096 00				mov     byte ptr KbdFlags3, 0   ; kb not present
 E1BD				kbok:
 E1BD  B0 AD					mov     al, 0adh
 E1BF  E6 64					out     64h, al      ; disable kb interface

				; ------------------- Mouse init ----------------
 E1C1  B0 A8					mov     al, 0a8h
 E1C3  E6 64					out     64h, al      ; enable mouse
 E1C5				mousei0:        
 E1C5  E8 14E7					call    getps2byte
 E1C8  73 FB					jnc     short mousei0
 E1CA  B4 FF					mov     ah, 0ffh
 E1CC  E8 14FA					call    sendcmd      ; reset mouse (CF = 1)
 E1CF  72 15					jc      short nomouse
 E1D1  B1 19					mov     cl, 25
 E1D3				mousei1:        
 E1D3  49					dec     cx
 E1D4  E3 10					jcxz    short nomouse
 E1D6  E8 14D6					call    getps2byte
 E1D9  72 F8					jc      short mousei1
 E1DB  3C AA					cmp     al, 0aah     ; BAT
 E1DD  75 07					jne     short nomouse
 E1DF  E8 14CD					call    getps2byte
 E1E2  3C 00					cmp     al, 0        ; mouse ID
 E1E4  74 09					je      short mouseok
 E1E6				nomouse:
 E1E6  B0 A7					mov     al, 0a7h        
 E1E8  E6 64					out     64h, al      ; disable mouse
 E1EA  80 26 0010 FB				and     byte ptr EquipmentWord, not 4 ; ps2 mouse not present in equipement word
 E1EF				mouseok:
 E1EF  E8 14E8					call    enableKbIfPresent

 E1F2  B0 20					mov     al, 20h
 E1F4  E6 64					out     64h, al
 E1F6  E4 60					in      al, 60h
 E1F8  0C 03					or      al, 3
 E1FA  8A E0					mov     ah, al
 E1FC  B0 60					mov     al, 60h
 E1FE  E6 64					out     64h, al
 E200  8A C4					mov     al, ah
 E202  E6 60					out     60h, al     ; enable 8042 mouse and kb interrupts

 E204  B8 0000					mov     ax, 0		; 1000-1   ; 1ms
 E207  E7 70					out     70h, ax     ; set RTC frequency (stop)

				;		mov     al, 0
 E209  E6 21					out     21h, al     ; enable all PIC interrupts (8h, 9h, 0ch)
 E20B  E6 A1					out		0a1h, al	; enable all PIC interrupts (70h, 74h)
 E20D  E6 01					out		1, al		; intialize COM mux
 E20F  40					inc		ax
 E210  E7 01					out		1, ax		; enable auto flush on vblank
 E212  FB					sti                 ; enable CPU interrupts

				; ---------------------- COM flush
 E213  B4 03			        mov     ah, 3       ; get serial port status
 E215  33 D2			        xor     dx, dx      ; COM1
 E217				COMFlush:
 E217  CD 14			        int     14h
 E219  D0 EC			        shr     ah, 1
 E21B  B4 02			        mov     ah, 2
 E21D  72 F8			        jc      short COMFlush

				; ---------------------   HDD init
 E21F  E8 16B3					call    sdinit
 E222  A3 0094					mov     HDSize, ax
 E225  0E					push    cs
 E226  07					pop     es
 E227  BE E000 R				mov     si, offset biosmsg
 E22A  E8 14F8					call    prts
 E22D  BE E27E R				mov     si, offset bioscont
 E230  E8 14F2					call    prts
 E233  A1 0094					mov     ax, HDSize
 E236  D1 E8					shr     ax, 1
 E238  E8 14D1					call    dispAX
 E23B  BE E035 R				mov     si, offset msgmb
 E23E  E8 14E4					call    prts
 E241  F6 06 0096 10				test    byte ptr KbdFlags3, 10h
 E246  74 06					jz      nokbmsg
 E248  BE E042 R				mov     si, offset msgkb
 E24B  E8 14D7					call    prts
 E24E				nokbmsg:
 E24E  F6 06 0010 04				test    byte ptr EquipmentWord, 4
 E253  74 06					jz      nomousemsg
 E255  BE E269 R				mov     si, offset msgmouse
 E258  E8 14CA					call    prts
 E25B				nomousemsg:

				;-------------- HD bootstrap
 E25B  B8 00E3					mov		ax, 00e3h
 E25E  CD 14					int		14h		; init COM to 9.6K, 8n1
 E260  B8 0305					mov     ax, 305h
 E263  33 DB					xor     bx, bx
 E265  CD 16					int     16h     ; set typematic rate and delay to fastest
 E267  CD 19					int     19h

 E269 50 53 32 20 4D 6F		msgmouse    db 'PS2 Mouse detected', 13, 10, 0        
       75 73 65 20 64 65
       74 65 63 74 65 64
       0D 0A 00
 E27E 0D 0A 43 50 55 3A		bioscont    db 13, 10, 'CPU: 80186 50Mhz (50MIPS, 100Mhz 32bit bus)', 13, 10
       20 38 30 31 38 36
       20 35 30 4D 68 7A
       20 28 35 30 4D 49
       50 53 2C 20 31 30
       30 4D 68 7A 20 33
       32 62 69 74 20 62
       75 73 29 0D 0A
 E2AD  52 41 4D 3A 20 33	            db 'RAM: 32MB SDR 100Mhz 16bit', 13, 10
       32 4D 42 20 53 44
       52 20 31 30 30 4D
       68 7A 20 31 36 62
       69 74 0D 0A
 E2C9  43 61 63 68 65 3A	            db 'Cache: 8KB, 4-way, 128x64 bytes data/inst', 13, 10
       20 38 4B 42 2C 20
       34 2D 77 61 79 2C
       20 31 32 38 78 36
       34 20 62 79 74 65
       73 20 64 61 74 61
       2F 69 6E 73 74 0D
       0A
 E2F4  48 44 30 3A 20 00				db 'HD0: ', 0

				; ---------------------------- INT 07 ---------------------
 E2FA				int07 proc near ; coprocessor ESC sequence
 E2FA  50					push    ax
 E2FB  53					push    bx
 E2FC  1E					push    ds
 E2FD  55					push    bp
 E2FE  8B EC					mov     bp, sp
 E300  C5 5E 08					lds     bx, [bp+8]  
 E303				int07_pfx:        
 E303  8A 07					mov     al, [bx]
 E305  43					inc     bx
 E306  24 F8					and     al, 0f8h
 E308  3C D8					cmp     al, 0d8h        ; ESC code
 E30A  75 F7					jne     short int07_pfx
							  
 E30C  80 3F C0					cmp     byte ptr [bx], 0c0h ; mod reg r/m of ESC 8087 instruction
 E30F  1A C0					sbb     al, al
 E311  22 07					and     al, [bx]
 E313  25 00C7					and     ax, 0c7h
 E316  3C 06					cmp     al, 6
 E318  75 02					jne     int072
 E31A  B0 80					mov     al, 80h
 E31C				int072:
 E31C  C0 E8 06					shr     al, 6
 E31F  40					inc     ax
 E320  03 C3					add     ax, bx
 E322  89 46 08					mov     [bp+8], ax
 E325  5D					pop     bp
 E326  1F					pop     ds
 E327  5B					pop     bx
 E328  58					pop     ax
 E329  CF					iret
 E32A				int07 endp


				; ---------------------------- INT 08 ---------------------
 E32A				int08 proc near
 E32A  1E					push    ds
 E32B  53					push    bx
 E32C  6A 40					push    40h
 E32E  1F					pop     ds

 E32F  BB 0040					mov     bx, 40h
 E332  83 3F 00					cmp     word ptr [bx], 0
 E335  74 02					jz      int08_nodec
 E337  FF 0F					dec     word ptr [bx]
 E339				int08_nodec:
 E339  50					push    ax
 E33A  B0 20					mov     al, 20h
 E33C  E6 20					out     20h, al
 E33E  58					pop     ax
 E33F  BB 006C					mov     bx, 6ch
 E342  83 07 01					add     word ptr [bx], 1
 E345  83 57 02 00				adc     word ptr [bx+2], 0
 E349  83 7F 02 18				cmp     word ptr [bx+2], 18h
 E34D  75 13					jne     short int081
 E34F  81 3F 00B0				cmp     word ptr [bx], 0b0h
 E353  75 0D					jne     short int081
 E355  C7 07 0000				mov     word ptr [bx], 0
 E359  C7 47 02 0000				mov     word ptr [bx+2], 0
 E35E  C6 47 04 01				mov     byte ptr [bx+4], 1
 E362				int081:
 E362  CD 1C					int     1ch
 E364  FB					sti
 E365  50					push    ax
 E366  B4 04					mov     ah, 4
 E368				kloop:        
 E368  E4 64					in      al, 64h
 E36A  A8 01					test    al, 1
 E36C  74 0E					jz      short nokey
 E36E  FE CC					dec     ah
 E370  75 F6					jnz     short kloop
 E372  A8 20					test    al, 20h
 E374  74 04					jz      short kbdata
 E376  CD 74					int     74h
 E378  EB 02					jmp     short nokey
 E37A				kbdata:
 E37A  CD 09					int     9h        
 E37C				nokey:
 E37C  58					pop     ax
 E37D  5B					pop     bx
 E37E  1F					pop     ds
 E37F  CF					iret
 E380				int08 endp

				; --------------------- INT 09 - keyboard ------------------
 = ds:[17h]			KbdFlags1       equ     <ds:[17h]>
 = ds:[18h]			KbdFlags2       equ     <ds:[18h]>
 = ds:[19h]			AltKpd          equ     <ds:[19h]>
 = ds:[71h]			CtrlBreak       equ     <ds:[71h]>
 = ds:[96h]			KbdFlags3       equ     <ds:[96h]>
 = ds:[97h]			KbdFlags4       equ     <ds:[97h]>

				; Bits for the KbdFlags1
 = 0001				RShfDown        equ     1
 = 0002				LShfDown        equ     2
 = 0004				CtrlDown        equ     4
 = 0008				AltDown         equ     8
 = 0010				ScrLock         equ     10h
 = 0020				NumLock         equ     20h
 = 0040				CapsLock        equ     40h
 = 0080				Insert          equ     80h

				; Bits for the KbdFlags2
 = 0001				LCtrDown        equ     1
 = 0002				LAltDown        equ     2
 = 0004				SysReqDown      equ     4
 = 0008				Pause           equ     8
 = 0010				ScrLockDown     equ     10h
 = 0020				NumLockDown     equ     20h
 = 0040				CapsLockDown    equ     40h
 = 0080				InsDown         equ     80h
				 
				; Bits for the KbdFlags3
 = 0001				LastE1          equ     1
 = 0002				LastE0          equ     2
 = 0004				RCtrDown        equ     4
 = 0008				RAltDown        equ     8
 = 0020				LastF0          equ     20h

				; Bits for the KbdFlags4
 = 0001				ScrLockLED      equ     1
 = 0002				NumLockLED      equ     2
 = 0004				CapsLockLED     equ     4
 = 0008				SetRepeat       equ     8       ; Set auto repeat command in progress
 = 0010				AckReceived     equ     10h
 = 0040				LEDUpdate       equ     40h

				IFDEF SCANCODE1

 E380				int09 proc near
 E380  60					pusha
 E381  1E					push    ds
 E382  06					push    es
 E383  6A 40					push    40h
 E385  1F					pop     ds
 E386  E4 60					in      al, 60h         ; al contains the scan code
 E388  8B 16 0017				mov     dx, KbdFlags1
 E38C  8B 0E 0096				mov     cx, KbdFlags3
 E390  3C FA					cmp     al, 0fah        ; ACK
 E392  75 1F					jne     short noACK
				; ------------ manage ACK response
 E394  F6 C5 40					test    ch, LEDUpdate
 E397  74 14					jz      short ToggleACK ; no LED update
 E399  F6 C5 10					test    ch, AckReceived
 E39C  75 0C					jnz     short SecondACK ; second ACK received
 E39E  8A E5					mov     ah, ch          ; LED update command sent, ACK received, need to send second byte
 E3A0  80 E4 07					and     ah, ScrLockLED or NumLockLED or CapsLockLED
 E3A3  B3 00					mov     bl, 0
 E3A5  E8 12E2					call    sendps2byte
 E3A8  EB 03					jmp     short ToggleACK
 E3AA				SecondACK:        
 E3AA  80 F5 40					xor     ch, LEDUpdate   ; second ACK, clear LED update bit
 E3AD				ToggleACK:
 E3AD  80 F5 10					xor     ch, AckReceived ; toggle ACK bit 
 E3B0				SetFlags1:                                  
 E3B0  E9 01AF					jmp     SetFlags               
						
				; ------------ no ACK
 E3B3				noACK:
 E3B3  B4 4F					mov     ah,4fh
 E3B5  F9					stc
 E3B6  CD 15					int     15h
 E3B8  72 03 E9 01C8				jnc     int09Exit
 E3BD  3C E0					cmp     al, 0e0h
 E3BF  75 05					jne     short noE0
 E3C1  80 C9 02					or      cl, LastE0
 E3C4  EB EA					jmp     short SetFlags1
 E3C6				noE0:
 E3C6  3C E1					cmp     al, 0e1h
 E3C8  75 05					jne     short noE1
 E3CA  80 C9 01					or      cl, LastE1
 E3CD  EB E1					jmp     short SetFlags1
 E3CF				noE1:   
 E3CF  3C 53					cmp     al, 53h     ; is DEL?
 E3D1  75 18					jne     short noDEL
 E3D3  8A E2					mov     ah, dl
 E3D5  80 E4 0C					and     ah, CtrlDown or AltDown
 E3D8  80 FC 0C					cmp     ah, CtrlDown or AltDown
 E3DB  74 03 E9 010F				jne     NormalKey   ; is DEL, but no CTRL+ALt+DEL
 E3E0  C7 06 0072 1234				mov     word ptr ds:[72h], 1234h    ; warm boot flag
 E3E6  EA					db      0eah
 E3E7  0000 FFFF				dw      0, 0ffffh       ; reboot
 E3EB				noDEL:
 E3EB  F6 C1 02					test    cl, LastE0
 E3EE  75 24					jnz     short noRSUp    ; ignore fake shifts
 E3F0  3C 2A					cmp     al, 2ah         ; left shift
 E3F2  75 05					jne     short noLSDown
 E3F4  80 CA 02					or      dl, LShfDown
 E3F7  EB 63					jmp     short SetFlagsKey2
 E3F9				noLSDown:
 E3F9  3C AA					cmp     al, 2ah or 80h
 E3FB  75 05					jne     short noLSUp
 E3FD  80 E2 FD					and     dl, not LShfDown
 E400  EB 5A					jmp     short SetFlagsKey2
 E402				noLSUp:
 E402  3C 36					cmp     al, 36h         ; right shift
 E404  75 05					jne     short noRSDown
 E406  80 CA 01					or      dl, RShfDown
 E409  EB 51					jmp     short SetFlagsKey2
 E40B				noRSDown:
 E40B  3C B6					cmp     al, 36h or 80h
 E40D  75 05					jne     short noRSUP
 E40F  80 E2 FE					and     dl, not RShfDown
 E412  EB 48					jmp     short SetFlagsKey2
 E414				noRSUp:
 E414  3C 38					cmp     al, 38h         ; ALT
 E416  75 13					jne     short noALTDown
 E418  F6 C1 02					test    cl, LastE0
 E41B  74 08					jz      short LALTDn
 E41D  80 C9 08					or      cl, RAltDown
 E420  80 CA 08					or      dl, AltDown
 E423  EB 37					jmp     short SetFlagsKey2
 E425				LALTDn:
 E425  81 CA 0208				or      dx, (LAltDown shl 8) or AltDown
 E429  EB 31					jmp     short SetFlagsKey2
 E42B				noALTDown:
 E42B  3C B8					cmp     al, 38h or 80h
 E42D  75 1E					jne     short noALTUp
 E42F  F6 C1 02					test    cl, LastE0
 E432  74 08					jz      short LALTUp
 E434  80 E1 F7					and     cl, not RAltDown
 E437  80 E2 F7					and     dl, not AltDown
 E43A  EB 04					jmp     short ALTup
 E43C				LALTUp:
 E43C  81 E2 FDF7				and     dx, not ((LAltDown shl 8) or AltDown)
 E440				ALTUp:
 E440  33 C0					xor     ax, ax
 E442  86 06 0019				xchg    al, AltKpd
 E446  84 C0					test    al, al
 E448  74 12					jz      short SetFlagsKey2     
 E44A  E9 0107					jmp     pushKey
 E44D				noALTUp:
 E44D  3C 1D					cmp     al, 1dh         ; CTL
 E44F  75 13					jne     short noCTLDown
 E451  F6 C1 02					test    cl, lastE0
 E454  74 08					jz      short LCTLDn
 E456  80 C9 04					or      cl, RCtrDown
 E459  80 CA 04					or      dl, CtrlDown
 E45C				SetFlagsKey2:        
 E45C  EB 79					jmp     short SetFlagsKey1
 E45E				LCTLDn:
 E45E  81 CA 0104				or      dx, (LCtrDown shl 8) or CtrlDown
 E462  EB 73					jmp     short SetFlagsKey1
 E464				noCTLDown:
 E464  3C 9D					cmp     al, 1dh or 80h
 E466  75 13					jne     short noCTLUp
 E468  F6 C1 02					test    cl, LastE0
 E46B  74 08					jz      short LCTLUp
 E46D  80 E1 FB					and     cl, not RCtrDown
 E470  80 E2 FB					and     dl, not CtrlDown
 E473  EB 62					jmp     short SetFlagsKey1
 E475				LCTLUp:
 E475  81 E2 FEFB				and     dx,  not ((LCtrDown shl 8) or CtrlDown)
 E479  EB 5C					jmp     short SetFlagsKey1
 E47B				noCTLUp:
 E47B  BB 3A40					mov     bx, 3a00h + CapsLock
 E47E  E8 010C					call    KeyLock
 E481  73 54					jnc     short SetFlagsKey1
						
 E483  BB 4610					mov     bx, 4600h + ScrLock
 E486  52					push    dx          ; save ScrLock state bit (dl)
 E487  E8 0103					call    KeyLock
 E48A  5B					pop     bx          ; restore ScrLock state bit (bl)
 E48B  72 21					jc      short noScrLock
 E48D  F6 C2 04					test    dl, CtrlDown
 E490  74 45					jz      short SetFlagsKey1; no break, just ScollLock
 E492  8A D3					mov     dl, bl      ; restore ScrLock flag
 E494  F6 C7 10					test    bh, ScrLockDown
 E497  75 3E					jnz     short SetFlagsKey1 
 E499  C6 06 0071 80				mov     byte ptr CtrlBreak, 80h   ; CTRL+BREAK flag
 E49E  A1 0080					mov     ax, Buffer
 E4A1  A3 001A					mov     HeadPtr, ax
 E4A4  A3 001C					mov     TailPtr, ax
 E4A7  CD 1B					int     1bh
 E4A9  33 C0					xor     ax, ax
 E4AB  E9 00A6					jmp     pushkey
 E4AE				noScrLock:        
 E4AE  F6 C1 02					test    cl, LastE0  ; INS
 E4B1  75 0A					jnz     short testINS
 E4B3  F6 C2 03					test    dl, RShfDown or LShfDown
 E4B6  75 05					jnz     short testINS
 E4B8  F6 C2 20					test    dl, NumLock
 E4BB  75 06					jnz     short NoIns      
 E4BD				testINS:
 E4BD  BB 5280					mov     bx, 5200h + Insert
 E4C0  E8 00CA					call    KeyLock  
 E4C3				noIns:
 E4C3  BB 4520					mov     bx, 4500h + NumLock
 E4C6  52					push    dx          ; save NumLock state bit (dl)
 E4C7  E8 00C3					call    KeyLock
 E4CA  5B					pop     bx          ; restore NumLock state bit (bl)
 E4CB  72 22					jc      short NormalKey   ; CTRL+NumLock = Pause
 E4CD  F6 C2 04					test    dl, CtrlDown
 E4D0  74 05					jz      short SetFlagsKey1
 E4D2  8A D3					mov     dl, bl      ; restore NumLock flag
 E4D4  80 CE 08					or      dh, Pause   ; set Pause bit
 E4D7				SetFlagsKey1:
 E4D7  E9 0085					jmp     SetFlagsKey
 E4DA				E0Key:
 E4DA  BF FC65 R				mov     di, offset E0KeyList
 E4DD  51					push    cx
 E4DE  B9 000C					mov     cx, E0KeyIndex - E0KeyList
 E4E1  FC					cld
 E4E2  0E					push    cs
 E4E3  07					pop     es
 E4E4  F2/ AE					repne   scasb
 E4E6  59					pop     cx
 E4E7  75 76					jne     short SetFlagsKey
 E4E9  26: 8A 45 0B				mov     al, es:[di + E0KeyIndex - E0KeyList - 1]
 E4ED  EB 14					jmp     short KeyDown
 E4EF				NormalKey:
 E4EF  A8 80					test    al, 80h
 E4F1  75 6C					jnz     short SetFlagsKey ; key up
 E4F3  F6 C1 02					test    cl, LastE0
 E4F6  75 E2					jnz     short E0Key
 E4F8  3C 59					cmp     al, 59h
 E4FA  1A E4					sbb     ah, ah
 E4FC  22 C4					and     al, ah
 E4FE  BB FC0C R				mov     bx, offset KeyIndex
 E501  2E: D7					xlat    cs:[bx]
 E503				KeyDown:
 E503  33 DB					xor     bx, bx 
 E505  F6 C2 03					test    dl, RShfDown or LShfDown
 E508  74 02					jz      short noShift
 E50A  B3 02					mov     bl, 2
 E50C				noShift:
 E50C  3C 1A					cmp     al, 26
 E50E  77 0A					ja      short noCaps
 E510  F6 C2 40					test    dl, CapsLock
 E513  74 13					jz      short noNum
 E515  80 F3 02					xor     bl, 2
 E518  EB 0E					jmp     short noNum 
 E51A				noCaps:
 E51A  3C 25					cmp     al, 37
 E51C  77 0A					ja      short noNum
 E51E  F6 C2 20					test    dl, NumLock
 E521  75 02					jnz     short NumDown
 E523  B3 02					mov     bl, 2
 E525				NumDown:
 E525  80 F3 02					xor     bl, 2
 E528				noNum:        
 E528  F6 C2 04					test    dl, CtrlDown
 E52B  74 02					jz      short noCtrl
 E52D  B3 04					mov     bl, 4
 E52F				noCtrl:
 E52F  F6 C2 08					test    dl, AltDown
 E532  74 02					jz      short noAlt
 E534  B3 06					mov     bl, 6
 E536				noAlt:
 E536  98					cbw
 E537  C1 E0 03					shl     ax, 3
 E53A  03 D8					add     bx, ax
 E53C  2E: 8B 87 FC7D R				mov     ax, cs:KeyCode[bx]
 E541  83 F8 0A					cmp     ax, 000ah
 E544  77 0E					ja      short pushKey
 E546  48					dec     ax
 E547  78 16					js      short SetFlagsKey     ; ax was 0
 E549  8A 26 0019				mov     ah, AltKpd
 E54D  D5 0A					aad
 E54F  A2 0019					mov     AltKpd, al
 E552  EB 0B					jmp     short SetFlagsKey
 E554				pushKey:                
 E554  51					push    cx
 E555  8B C8					mov     cx, ax
 E557  B4 05					mov     ah, 5
 E559  CD 16					int     16h
 E55B  59					pop     cx
 E55C  80 E6 F7					and     dh, not Pause    ; clear Pause bit
 E55F				SetFlagsKey:
 E55F  80 E1 FC					and     cl, not (LastE0 or LastE1)    ; not prefix key code, clear all prefixes
 E562				SetFlags:
 E562  8A C2					mov     al, dl
 E564  C0 E8 04					shr     al, 4
 E567  32 C5					xor     al, ch
 E569  24 07					and     al, 7
 E56B  74 10					jz      short SF1   ; no LEDs to update
 E56D  F6 C5 58					test    ch, SetRepeat or AckReceived or LEDUpdate
 E570  75 0B					jnz     short SF1   ; can not update LEDS, so just write the flags and exit
 E572  0C 40					or      al, LEDUpdate
 E574  32 E8					xor     ch, al      ; insert the LEDs in KbdFlags4
 E576  B4 ED					mov     ah, 0edh    ; set LED
 E578  B3 00					mov     bl, 0
 E57A  E8 110D					call    sendps2byte
 E57D				SF1:        
 E57D  89 16 0017				mov     KbdFlags1, dx
 E581  89 0E 0096				mov     KbdFlags3, cx
						
 E585				int09Exit:
 E585  B0 20					mov     al, 20h
 E587  E6 20					out     20h, al
 E589  07					pop     es
 E58A  1F					pop     ds
 E58B  61					popa
 E58C  CF					iret
 E58D				int09 endp

				ELSE    ; SCANCODE2
				ENDIF

 E58D				KeyLock proc near   ; input: BH = expected scan code, al = scan code, BL = key lock flag. Returns CF=1 to continue, CF=0 to exit
 E58D  32 F8					xor     bh, al
 E58F  75 09					jnz     short s2
 E591  8A E6					mov     ah, dh
 E593  0A F3					or      dh, bl      ; set flag
 E595  32 E6					xor     ah, dh      ; get flag difference
 E597  32 D4					xor     dl, ah      ; toggle only if key was not already down
 E599  C3					ret
 E59A  80 FF 80			s2:     cmp     bh, 80h
 E59D  F9					stc
 E59E  75 02					jne     short exit
 E5A0  32 F3					xor     dh, bl      ; key up
 E5A2				exit:
 E5A2  C3					ret
 E5A3				KeyLock endp


				; --------------------- INT 10h - Video ----------------
 = ds:[49h]			ActiveVideoMode     equ <ds:[49h]>  ; 1  byte
 = ds:[4ah]			ScreenWidth         equ <ds:[4ah]>  ; 2  Screen width in text columns
 = ds:[4ch]			RegenLength         equ <ds:[4ch]>  ; 2  Length (in bytes) of video area (regen size)
 = ds:[4eh]			PageOffset          equ <ds:[4eh]>  ; 2  Offset from video segment of active video memory page
 = ds:[50h]			CursorPos           equ <ds:[50h]>  ; 16 Cursor location (8 byte-pairs; low byte=col, hi byte=row)
 = ds:[60h]			CursorShape         equ <ds:[60h]>  ; 2  Cursor size/shape.  Low byte=end scan line; hi byte=start line.
 = ds:[62h]			ActivePage          equ <ds:[62h]>  ; 1  Current active video page number
 = ds:[63h]			PortAddress         equ <ds:[63h]>  ; 2  Port address for 6845 video controller chip; see CGA I/O Ports
 = ds:[65h]			CrtMode             equ <ds:[65h]>  ; 1  Current value of 6845 video ctrlr CRT_MODE (port 3x8H register)
 = ds:[66h]			CrtPalette          equ <ds:[66h]>  ; 1  Current value of 6845 video ctrlr CRT_PALETTE (port 3x9H reg)
 = ds:[84h]			ScreenRows          equ <ds:[84h]>  ; 1  EGA text rows-1  (maximum valid row value)
 = ds:[85h]			ScanLinesChar       equ <ds:[85h]>  ; 2  EGA bytes per character (scan-lines/char used in active mode)
 = ds:[87h]			EgaMiscInfo         equ <ds:[87h]>  ; 1  EGA flags; see EgaMiscInfoRec
 = ds:[88h]			EgaMiscInfo2        equ <ds:[88h]>  ; 1  EGA flags; see EgaMiscInfo2Rec
 = ds:[89h]			VgaFlags            equ <ds:[89h]>  ; 1  VGA flags; see VgaFlagsRec
 = ds:[8ah]			VgaFlags2           equ <ds:[8ah]>  ; 1  VGA flags2
 = ds:[69h]			PalOffset			equ <ds:[69h]>  ; 2  current palette offset (temporary during the video mode set)


 E5A3				int10 proc near     
 E5A3  FB					sti                     ; no interrupt reentrant
 E5A4  FC					cld
 E5A5  1E					push    ds
 E5A6  56					push    si
 E5A7  6A 40					push    40h
 E5A9  1F					pop     ds
 E5AA  80 FC 4F					cmp     ah, 4fh
 E5AD  74 16					je      short svga
 E5AF  80 FC 1C					cmp     ah, 1ch
 E5B2  77 0E					ja      short exit
 E5B4  8B F0					mov     si, ax
 E5B6  C1 EE 07					shr     si, 7
 E5B9  81 E6 01FE				and     si, 1feh
 E5BD  2E: FF 94 EEE3 R				call    cs:vidtbl[si]
 E5C2				exit:        
 E5C2  5E					pop     si
 E5C3  1F					pop     ds
 E5C4  CF					iret
 E5C5				svga:
 E5C5  3C 05					cmp     al, 5
 E5C7  74 77					je      short VESAMemControl
 E5C9  3C 01					cmp     al, 1
 E5CB  72 0D					jb      short VESAGetInfo
 E5CD  74 24					je      short VESAGetModeInfo
 E5CF  3C 03					cmp     al, 3
 E5D1  72 37					jb      short VESASetMode
 E5D3  74 4F					je      short VESAGetMode
 E5D5  B8 0100					mov     ax, 100h
 E5D8  EB E8					jmp     short exit

				; ---------------- VESA fn00
 E5DA				VESAGetInfo:
 E5DA  51					push    cx
 E5DB  57					push    di
 E5DC  BE E66C R				mov     si, offset VESAInfo
 E5DF  B9 000A					mov     cx, 10
 E5E2  F3/ 2E: A5				rep     movsw es:[di], cs:[si]
 E5E5  B1 76					mov     cl, 118     ; 236 bytes 0
 E5E7				VESASupportedClear:        
 E5E7  33 C0					xor     ax, ax
 E5E9  F3/ AB					rep     stosw
 E5EB  5F					pop     di
 E5EC  59					pop     cx     
 E5ED				VESASupported:
 E5ED  B4 00					mov     ah, 0       ; success    
 E5EF				VESASupportedErr:
 E5EF  B0 4F					mov     al, 4fh
 E5F1  EB CF					jmp     short exit

				; ---------------- VESA fn01
 E5F3				VESAGetModeInfo:
 E5F3  81 F9 0101				cmp     cx, 101h
 E5F7				VESAGetModeInfo1:        
 E5F7  B4 01					mov     ah, 1       ; error
 E5F9  75 F4					jne     short VESASupportedErr
 E5FB  51					push    cx
 E5FC  57					push    di
 E5FD  B9 0009					mov     cx, 9
 E600  BE E697 R				mov     si, offset VESAModeInfo
 E603  F3/ 2E: A5				rep     movsw es:[di], cs:[si]
 E606  B1 77					mov     cl, 119       
 E608  EB DD					jmp     short VESASupportedClear

				; ---------------- VESA fn02
 E60A				VESASetMode:
 E60A  6B C3 02					imul    ax, bx, 2
 E60D  3D 0202					cmp     ax, 101h*2
 E610  75 0A					jne     short VESASetMode1      
 E612  8D 87 23FF				lea     ax, [bx+23ffh]
 E616  86 E0					xchg    ah, al
 E618  CD 10					int     10h
 E61A  EB D1					jmp     short VESASupported   
 E61C				VESASetMode1:
 E61C  8A C3					mov     al, bl
 E61E  B4 00					mov     ah, 0
 E620  CD 10					int     10h
 E622  EB C9					jmp     short VESASupported

				; ---------------- VESA fn03
 E624				VESAGetMode:
 E624  8A 3E 0087				mov     bh, EgaMiscInfo
 E628  80 E7 80					and     bh, 80h
 E62B  8A 1E 0049				mov     bl, ActiveVideoMode
 E62F  80 FB 25					cmp     bl, 25h
 E632  74 06					je      short VESAGetMode1
 E634  0A DF					or      bl, bh
 E636  B7 00					mov     bh, 0
 E638  EB B3					jmp     short VESASupported
 E63A				VESAGetMode1:
 E63A  81 C3 00DC				add     bx, 257-25h        
 E63E  EB AD					jmp     short VESASupported

				; ---------------- VESA fn05
 E640				VESAMemControl:
				;        test    bx, not 101h                ; BX validation
				;        jnz     short VESAGetModeInfo1      ; error
 E640  0E					push    cs
 E641  68 E5ED R				push    offset VESASupported
				;        call    VESAMemControlCB
				;        jmp     short VESASupported
 E644				VESAMemControlCB:
 E644  9C					pushf
 E645  FA					cli
 E646  50					push    ax
 E647  52					push    dx
 E648  8B C3					mov     ax, bx
 E64A  83 E0 01					and     ax, 1
 E64D  04 8A					add     al, 8ah
 E64F  92					xchg    ax, dx
 E650  83 E0 07					and     ax, 7
 E653  04 0A					add     al, 0ah
 E655  84 FF					test    bh, bh
 E657  75 08					jnz     getpageinfo
 E659  E8 108B					call    flush
 E65C  EF					out     dx, ax          
 E65D  5A					pop     dx
 E65E  58					pop     ax
 E65F  9D					popf
 E660  CB					retf
 E661				getpageinfo:
 E661  ED					in      ax, dx
 E662  2C 0A					sub     al, 0ah
 E664  83 E0 07					and     ax, 7
 E667  92					xchg    ax, dx
 E668  58					pop     ax
 E669  58					pop     ax                
 E66A  9D					popf
 E66B  CB					retf
				   
 E66C 56 45 53 41		VESAInfo    db  'VESA'
 E670  0100 E680 R F000					dw  100h, VESAOEM, 0f000h, 2, 0, VESAModes, 0f000h, 8
       0002 0000 E693 R
       F000 0008
 E680 4E 69 63 6F 6C 61		VESAOEM     db  'Nicolae Dumitrache', 0
       65 20 44 75 6D 69
       74 72 61 63 68 65
       00
 E693 0101 FFFF			VESAModes   dw  101h, 0ffffh
 E697				VESAModeInfo:
				;Bit(s)  Description - mode attributes 
				;0      mode supported by present hardware configuration
				;1      optional information available (must be =1 for VBE v1.2+)
				;2      BIOS output supported
				;3      set if color, clear if monochrome
				;4      set if graphics mode, clear if text mode
				;---VBE v2.0+ ---
				;5      mode is not VGA-compatible
				;6      bank-switched mode not supported
				;7      linear framebuffer mode supported
				;8      double-scan mode available (e.g. 320x200 and 320x240)
				;---VBE v3.0 ---
				;9      interlaced mode available
				;10     hardware supports triple buffering
				;11     hardware supports stereoscopic display
				;12     dual display start address support
				;13-15  reserved
 E697  0099					dw  0000000010011001b       
				;Bit(s)  Description - window attributes
				;0      exists
				;1      readable
				;2      writable
				;3-7    reserved
 E699  07 07					db  00000111b, 00000111b
 E69B  0040 0040 A000				dw  64, 64, 0a000h, 0b000h, VESAMemControlCB, 0f000h, 640
       B000 E644 R F000
       0280

 E6A9 00			p3c0r10	db		0	; port 3c0h reg 10h mirror
				
 E6AA				ModeTab:
				;           0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f     10    11    12    13    25
 E6AA 4D 4D 4D 4D C0 C0		crtc9   db 04dh, 04dh, 04dh, 04dh, 0c0h, 0c0h, 0c0h, 04dh, 0c0h, 0c0h, 0c0h, 0c0h, 0c0h, 0c0h, 0c0h, 040h, 040h, 040h, 040h, 0c0h, 040h ; repln, lcr[9]
       C0 4D C0 C0 C0 C0
       C0 C0 C0 40 40 40
       40 C0 40
 E6BF 8F 8F 8F 8F 8F 8F		crtc12  db 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 05dh, 05dh, 0dfh, 0dfh, 08fh, 0dfh ; vde
       8F 8F 8F 8F 8F 8F
       8F 8F 8F 5D 5D DF
       DF 8F DF
 E6D4 14 14 14 14 14 14		crtc13  db 014h, 014h, 014h, 014h, 014h, 014h, 014h, 028h, 028h, 028h, 028h, 028h, 028h, 014h, 028h, 028h, 028h, 028h, 028h, 028h, 050h ; offset
       14 28 28 28 28 28
       28 14 28 28 28 28
       28 28 50
 E6E9 08 08 08 08 01 01		dac10   db 008h, 008h, 008h, 008h, 001h, 001h, 001h, 001h, 001h, 001h, 001h, 001h, 001h, 001h, 001h, 00bh, 001h, 00bh, 001h, 041h, 001h ; mode ctrl
       01 01 01 01 01 01
       01 01 01 0B 01 0B
       01 41 01
 E6FE 01 01 01 01 0B 0B		sc1     db 001h, 001h, 001h, 001h, 00bh, 00bh, 001h, 000h, 000h, 000h, 000h, 000h, 000h, 00bh, 001h, 001h, 001h, 001h, 001h, 001h, 001h ; clocking mode (half)
       01 00 00 00 00 00
       00 0B 01 01 01 01
       01 01 01
				
				; --------------- fn 00h, set video mode
 E713				setmode:
 E713  60					pusha
 E714  06					push    es
 E715  02 C0					add     al, al      ; CF = cls bit
 E717  D0 16 0087				rcl     byte ptr EgaMiscInfo, 1
 E71B  D0 0E 0087				ror     byte ptr EgaMiscInfo, 1

 E71F  50					push	ax
 E720  BA 03D4					mov     dx,3d4h    ; CRTC
 E723  B8 0011					mov     ax,0011h   ; unset register protect
 E726  EF					out     dx,ax
 E727  B8 8317					mov     ax,8317h   ; mode control
 E72A  EF					out     dx,ax
 E72B  BA 03C4					mov		dx, 3c4h ; SC
 E72E  B8 0F02					mov		ax, 0f02h
 E731  EF					out		dx, ax		; enable all write planes
 E732  B8 0C04					mov		ax, 0c04h
 E735  EF					out		dx, ax		; clear planar and odd/even mode
 E736  B2 CE					mov		dl, 0ceh	; GC
 E738  B8 0001					mov		ax, 0001h
 E73B  EF					out		dx, ax		; disable set/reset
 E73C  B0 03					mov		al, 03h
 E73E  EF					out		dx, ax		; reset logical op and rotate count
 E73F  B0 05					mov		al, 05h
 E741  EF					out		dx, ax		; set write mode to 00 (CPU access)
 E742  B8 FF07					mov		ax, 0ff07h
 E745  EF					out     dx, ax      ; set color don't care to 0Fh
 E746  40					inc     ax
 E747  EF					out		dx, ax		; set bitmask to CPU access
 E748  58					pop		ax

 E749  3C 06					cmp     al, 3*2
 E74B  77 2B					ja      short setmode1
 E74D  B0 B6					mov     al, 0b6h        ; reset sound generator
 E74F  E6 43					out     43h, al
 E751  B0 00					mov     al, 0
 E753  E6 42					out     42h, al
 E755  E6 42					out     42h, al
 E757  B8 0806					mov     ax, 0806h   ; text mode (80x25, 16 colors), flash enabled
 E75A  C7 06 004A 0050				mov     word ptr ScreenWidth, 80
 E760  C7 06 004C 1000				mov     word ptr RegenLength, 1000h
 E766  BB B800					mov     bx, 0b800h  ; segment
 E769  B9 4000					mov     cx, 4000h   ; video len/2
 E76C  BE 0720					mov     si, 0720h   ; clear value
 E76F  C7 06 0069 FB3C R			mov		word ptr PalOffset, offset PalVGA
 E775  E9 00D2					jmp     setmode2
 E778				setmode1:
						; CGA modes
 E778  3C 0C					cmp     al,6*2
 E77A  77 3C					ja      setmode11
				
 E77C  50					push    ax
 E77D  BA 03D4					mov     dx, 3d4h    ; CRTC
 E780  B8 8217					mov     ax, 8217h   ; mode control
 E783  EF					out     dx, ax
 E784  BA 03C4					mov     dx, 3c4h   ; SC
 E787  B8 0804					mov     ax, 0804h
 E78A  EF					out     dx, ax     ; set odd/even mode
 E78B  58					pop     ax
				
 E78C  3C 0C					cmp     al,6*2
 E78E  74 0A					je      setmode1a
 E790  50					push    ax         ; save AL
 E791  B2 CE					mov     dl, 0ceh   ; GC
 E793  B8 3005					mov     ax, 3005h
 E796  EF					out     dx,ax      ; set shift-load
 E797  58					pop     ax         ; restore AL
 E798  B4 11					mov     ah, 11h    ; half -> 320x200x4
 E79A				setmode1a:
 E79A  BB B800					mov     bx, 0b800h  ; segment
 E79D  B9 2000					mov     cx, 2000h   ; video len/2
 E7A0  BE 0000					mov     si, 0000h   ; clear value
 E7A3  C7 06 004A 0050				mov     word ptr ScreenWidth, 80
 E7A9  C7 06 004C 1000				mov     word ptr RegenLength, 1000h
 E7AF  C7 06 0069 FA6C R			mov     word ptr PalOffset, offset PalEGA
 E7B5  E9 0092					jmp     setmode2
 E7B8				setmode11:
 E7B8  3C 1A					cmp		al,	0dh*2
 E7BA  75 14					jne		short setmode12
 E7BC  C7 06 004A 0028				mov     word ptr ScreenWidth, 40
 E7C2  C7 06 004C 2000				mov     word ptr RegenLength, 2000h
 E7C8  C7 06 0069 FA6C R			mov		word ptr PalOffset, offset PalEGA
 E7CE  EB 32					jmp		short setmode121
 E7D0				setmode12:
 E7D0  3C 1C					cmp		al, 0eh*2	; 640x200x16
 E7D2  75 14					jne		short setmode122
 E7D4  C7 06 0069 FA6C R			mov		word ptr PalOffset, offset PalEGA
 E7DA				setmode1221:
 E7DA  C7 06 004A 0050				mov     word ptr ScreenWidth, 80
 E7E0  C7 06 004C 4000				mov     word ptr RegenLength, 04000h
 E7E6  EB 1A					jmp		short setmode121
 E7E8				setmode122:
 E7E8  C7 06 0069 FB3C R			mov		word ptr PalOffset, offset PalVGA
 E7EE  3C 20					cmp		al, 10h*2
 E7F0  74 E8					je		short setmode1221	; 640x350x16
 E7F2  3C 24					cmp		al, 12h*2
 E7F4  75 1B					jne		short setmode13
 E7F6  C7 06 004A 0050				mov     word ptr ScreenWidth, 80
 E7FC  C7 06 004C A000				mov     word ptr RegenLength, 0a000h
 E802				setmode121:
 E802  50					push	ax
 E803  BA 03C4					mov		dx, 3c4h	; SC
 E806  B8 FF02					mov		ax, 0ff02h
 E809  EF					out		dx, ax		; set write all planes
 E80A  B8 0404					mov		ax, 0404h
 E80D  EF					out		dx, ax		; set planar mode
 E80E  58					pop		ax
 E80F  EB 31					jmp		short setmode21
 E811				setmode13:    
 E811  3C 26					cmp     al, 13h*2
 E813  75 14					jne     short setmode3
						; graphic mode, 320x200, 256 colors
 E815  C7 06 004A 0028				mov     word ptr ScreenWidth, 40
 E81B  C7 06 004C 0000				mov     word ptr RegenLength, 0000h
 E821  C7 06 0069 F99C R			mov		word ptr PalOffset, offset Pal256
 E827  EB 19					jmp     short setmode21
 E829				setmode3:
 E829  3C 4A					cmp     al, 25h*2
 E82B  74 03 E9 00E2				jne		setmodeexit
 E830  C7 06 004A 0050				mov     word ptr ScreenWidth, 80
 E836  C7 06 004C 0000				mov     word ptr RegenLength, 0000h
 E83C  C7 06 0069 F99C R			mov		word ptr PalOffset, offset Pal256
 E842				setmode21:
 E842  BB A000					mov     bx, 0a000h  ; segment
 E845  B9 8000					mov     cx, 8000h   ; video len/2
 E848  33 F6					xor     si, si      ; clear value
 E84A				setmode2:
 E84A  D0 E8					shr     al, 1
 E84C  A2 0049					mov     ActiveVideoMode, al
				
 E84F  32 E4					xor     ah,ah
 E851  8B F8					mov     di,ax
 E853  83 FF 13					cmp     di,13h     ; video modes > 13h are mapped to 14h entry
 E856  76 03					jbe     setmode2a
 E858  BF 0014					mov     di,14h
 E85B				setmode2a:
 E85B  2E: 8A A5 E6E9 R				mov     ah, cs:dac10[di]
 E860  2E: 8A 85 E6FE R				mov     al, cs:sc1[di]
 E865  50					push    ax
 E866  51					push    cx
 E867  BA 03D4					mov     dx, 3d4h   ; CRTC
 E86A  2E: 8A A5 E6AA R				mov     ah, cs:crtc9[di]
 E86F  B0 09					mov     al, 09h
 E871  EF					out     dx, ax     ; set repln, lcr9
 E872  2E: 8A A5 E6BF R				mov     ah, cs:crtc12[di]
 E877  B0 12					mov     al, 12h
 E879  EF					out     dx, ax     ; vde
 E87A  2E: 8A A5 E6D4 R				mov     ah, cs:crtc13[di]
 E87F  B0 13					mov     al, 13h
 E881  EF					out     dx, ax     ; offset
 E882  1E					push    ds
 E883  07					pop     es
 E884  B8 1207					mov     ax, 1207h   ; lcr8, vde8
 E887  EF					out     dx, ax
 E888  B8 FF18					mov     ax, 0ff18h  ; lcr7..0
 E88B  EF					out     dx,ax
 E88C  33 C0					xor     ax, ax
 E88E  BF 0050					mov     di, offset CursorPos
 E891  B9 0008					mov     cx, 8
 E894  F3/ AB					rep     stosw           ; reset cursor position for all pages
 E896  B8 0500					mov     ax, 0500h
 E899  CD 10					int     10h             ; set page0
 E89B  59					pop     cx
 E89C  F6 06 0087 80				test    byte ptr EgaMiscInfo, 80h
 E8A1  75 16					jnz     short setmode4    ; no clear video memory

 E8A3  8E C3					mov     es, bx
 E8A5				clearnext:
 E8A5  96					xchg    ax, si
 E8A6  33 FF					xor     di, di
 E8A8  51					push	cx
 E8A9  F3/ AB					rep     stosw        
 E8AB  59					pop		cx
 E8AC  80 FF A0					cmp		bh, 0a0h
 E8AF  75 08					jnz		short clearok
 E8B1  96					xchg	ax, si
 E8B2  40					inc		ax
 E8B3  CD 10					int		10h
 E8B5  3C 08					cmp		al, 8
 E8B7  75 EC					jnz		short clearnext				
 E8B9				clearok:

 E8B9				setmode4:
 E8B9  BA 03DA					mov     dx, 3dah
 E8BC  EC					in      al, dx
 E8BD  58					pop     ax
 E8BE  50					push    ax
 E8BF  BA 03C0					mov     dx, 3c0h
 E8C2  B0 10					mov     al, 10h
 E8C4  EE					out     dx, al
 E8C5  8A C4					mov     al, ah      
 E8C7  EE					out     dx, al      ; set video mode
 E8C8  2E: A2 E6A9 R				mov     cs:p3c0r10, al
 E8CC  B0 13					mov     al, 13h
 E8CE  EE					out     dx, al
 E8CF  B0 00					mov     al, 0
 E8D1  EE					out     dx, al      ; 0 pan
 E8D2  58					pop     ax
 E8D3  8A E0					mov     ah, al    ; set half dot clock
 E8D5  BA 03C4					mov     dx, 3c4h    ; SC
 E8D8  B0 01					mov     al, 01h
 E8DA  EF					out     dx, ax

 E8DB  B8 1114					mov     ax, 1114h
 E8DE  CD 10					int     10h         ; set 8x16 ROM font
 E8E0  B8 1123					mov     ax, 1123h
 E8E3  CD 10					int     10h         ; set ROM 8x8 font for graphics mode
 E8E5  B4 01					mov     ah, 1
 E8E7  B9 0607					mov		cx, 607h	; scanlines 13 and 14
 E8EA  CD 10					int     10h         ; show cursor
 E8EC  F6 06 0089 08				test    byte ptr VgaFlags, 8  ; test default palette loading
 E8F1  75 1F					jnz     short setmodeexit     ; no default palette
 E8F3  B8 1012					mov     ax, 1012h
 E8F6  33 DB					xor     bx, bx
 E8F8  B9 0040					mov     cx, 40h    
 E8FB  8B 16 0069				mov     dx, PalOffset
 E8FF  0E					push    cs
 E900  07					pop     es
 E901  CD 10					int     10h             ; set default palette
 E903  B0 02					mov		al, 02h
 E905  81 C2 00C0				add		dx, 40h*3
 E909  CD 10					int		10h				; set default palette EGA registers
 E90B  B0 13					mov		al, 13h
 E90D  BB 0001					mov		bx, 0001h		; select page0
 E910  CD 10					int		10h
 E912				setmodeexit:
 E912  BA 03D4					mov     dx,3d4h
 E915  B8 8011					mov     ax,8011h   ; set register protect
 E918  EF					out     dx,ax
 E919  BA 03D9					mov     dx,3d9h    ; CGA color select
 E91C  B0 30					mov     al,030h    ; palette 1, hi-intensity, bg color=0
 E91E  A2 0066					mov     CrtPalette, al
 E921  EE					out     dx,al
				
 E922  07					pop     es
 E923  61					popa
 E924				nullproc:
 E924  C3					ret        

				; --------------- fn 01h, set cursor shape and visibility
 E925				cursor:     ; CH = start line (0-7), CH bit 5 = 1  -> cursor off
							; CL = end line (0-7)
 E925  50					push    ax
 E926  52					push    dx
 E927  89 0E 0060				mov		[CursorShape], cx
 E92B  F6 06 0085 10				test	byte ptr [ScanLinesChar], 10h
 E930  74 04					jz		short cursor8
 E932  03 C9					add		cx, cx
 E934  FE C5					inc		ch
 E936				cursor8:
 E936  BA 03D4					mov     dx, 3d4h
 E939  B0 0A					mov     al, 0ah
 E93B  8A E5					mov		ah, ch
 E93D  EF					out     dx, ax
 E93E  40					inc		ax
 E93F  8A E1					mov     ah, cl
 E941  EF					out     dx, ax
 E942  5A					pop     dx
 E943  58					pop     ax
 E944  C3					ret

				;---------------- fn 02h, set cursor pos
 E945				curpos:
 E945  50					push    ax
 E946  53					push    bx
 E947  8A C7					mov     al, bh
 E949  C1 EB 07					shr     bx, 7
 E94C  83 E3 0E					and     bx, 0eh
 E94F  89 57 50					mov     CursorPos[bx], dx
 E952  80 3E 0049 03				cmp     byte ptr ActiveVideoMode, 3
 E957  75 1E					jne     short curpos1
 E959  3A 06 0062				cmp     al, ActivePage
 E95D  75 18					jne     short curpos1
 E95F  52					push    dx
 E960  33 C0					xor     ax, ax
 E962  86 C6					xchg    al, dh        
 E964  6B C0 50					imul    ax, 80
 E967  03 C2					add     ax, dx
 E969  BA 03D4					mov     dx, 3d4h
 E96C  50					push    ax
 E96D  8A E0					mov 	ah, al
 E96F  B0 0F					mov		al, 0fh
 E971  EF					out		dx, ax
 E972  58					pop		ax
 E973  B0 0E					mov		al, 0eh
 E975  EF					out 	dx, ax
 E976  5A					pop     dx
 E977				curpos1:        
 E977  5B					pop     bx
 E978  58					pop     ax
 E979  C3					ret

				;---------------- fn 03h, get cursor pos
 E97A				getcurpos:
 E97A  53					push    bx
 E97B  C1 EB 07					shr     bx, 7
 E97E  83 E3 0E					and     bx, 0eh
 E981  8B 57 50					mov     dx, CursorPos[bx]
 E984  8B 0E 0060				mov     cx, CursorShape
 E988  5B					pop     bx
 E989  C3					ret

				;---------------- fn 04h, light pen
 E98A				lightpen:
 E98A  B4 00					mov     ah, 0   ; not triggered
 E98C  C3					ret

				;---------------- fn 05h, set active video page
 E98D				apage:
 E98D  60					pusha
 E98E  E8 0D56					call    flush
 E991  24 07					and     al, 7
 E993  8A F8					mov     bh, al
 E995  A2 0062					mov     ActivePage, al
 E998  A0 0049					mov     al, ActiveVideoMode
 E99B  3C 13					cmp     al, 13h
 E99D  73 19					jae		short apage1
 E99F  3C 03					cmp     al, 3
 E9A1  77 25					ja		short apage2
 E9A3  B8 000A					mov     ax, 0ah
 E9A6  E7 8A					out     8ah, ax
 E9A8  40					inc     ax
 E9A9  E7 8B					out     8bh, ax
 E9AB  B4 03					mov     ah, 3
 E9AD  CD 10					int     10h        ; get cursor pos
 E9AF  B4 02					mov     ah, 2
 E9B1  CD 10					int     10h        ; set cursor pos
 E9B3  B8 0400					mov		ax, 400h
 E9B6  EB 13					jmp     short apage4
 E9B8				apage1:	
 E9B8  B8 000A					mov     ax, 0ah		; mode 13h and 25h
 E9BB  02 C7					add     al, bh
 E9BD  E7 8A					out     8ah, ax
 E9BF  40					inc     ax
 E9C0  3C 12					cmp     al, 12h
 E9C2  75 02					jne     short apage3
 E9C4  B0 0A					mov     al, 0ah
 E9C6				apage3: 
 E9C6  E7 8B					out     8bh, ax
 E9C8				apage2:
 E9C8  A1 004C					mov	ax, RegenLength
 E9CB				apage4:
 E9CB  C1 EB 08					shr     bx, 8      ; page number
 E9CE  F7 E3					mul     bx
 E9D0  8B D8					mov     bx, ax     ; 1 means 4 bytes, or 2 characters
 E9D2  C1 E0 02					shl     ax, 2	   ; 1 means 1 byte   
 E9D5  A3 004E					mov     PageOffset, ax
 E9D8  BA 03D4					mov     dx, 3d4h
 E9DB  8A E3					mov		ah, bl
 E9DD  B0 0D					mov		al, 0dh
 E9DF  EF					out		dx, ax
 E9E0  8A E7					mov		ah, bh
 E9E2  48					dec		ax
 E9E3  EF					out		dx, ax
 E9E4  61					popa
 E9E5  C3					ret

				;---------------- fn 06h, scroll up / clr
 E9E6				scrollup:
 E9E6  60					pusha
 E9E7  06					push    es
 E9E8  87 CA					xchg    cx, dx
 E9EA  2B CA					sub     cx, dx
 E9EC  41					inc     cx
 E9ED  E8 0047					call    scr_params
 E9F0				scrollup6:        
 E9F0  68 B800					push    0b800h          ; segment
 E9F3  07					pop     es
 E9F4  02 D2					add     dl, dl
 E9F6  03 FF					add     di, di
 E9F8  03 3E 004E				add     di, PageOffset  ; di = top left corner address
 E9FC  91					xchg    ax, cx          ; ah = 0
 E9FD  84 DB					test    bl, bl
 E9FF  74 13					jz      short scrollup3       ; clear
 EA01  2A E3					sub     ah, bl
 EA03  72 0F					jb      short scrollup3       ; clear
 EA05  03 F7					add     si, di
 EA07				scrollup4:        
 EA07  8A C8					mov     cl, al
 EA09  F3/ 26: A5				rep     movsw es:[si], es:[di]
 EA0C  03 F2					add     si, dx
 EA0E  03 FA					add     di, dx
 EA10  FE CC					dec     ah              
 EA12  79 F3					jns     short scrollup4       ; ch = lines - 1
 EA14				scrollup3:                      
 EA14  02 E3					add     ah, bl          ; clear rectangle: DI=address, ah=lines, al=columns, bh=attribute
 EA16  93					xchg    ax, bx
 EA17  B0 20					mov     al, ' '
 EA19				scrollup5:
 EA19  8A CB					mov     cl, bl
 EA1B  F3/ AB					rep     stosw
 EA1D  03 FA					add     di, dx
 EA1F  FE CF					dec     bh
 EA21  79 F6					jns     short scrollup5       ; ch = lines - 1
 EA23				scrollexit:
 EA23  07					pop     es
 EA24  61					popa
 EA25  C3					ret

				;---------------- fn 07h, scroll dn / clr
 EA26				scrolldn:
 EA26  FD					std
 EA27  60					pusha
 EA28  06					push    es
 EA29  F7 D9					neg     cx
 EA2B  03 CA					add     cx, dx
 EA2D  41					inc     cx
 EA2E  E8 0006					call    scr_params
 EA31  F7 DA					neg     dx
 EA33  F7 DE					neg     si
 EA35  EB B9					jmp     short scrollup6

 EA37				scr_params:
 EA37  8A D8					mov     bl, al          ; lines
 EA39  33 C0					xor     ax, ax
 EA3B  86 C6					xchg    al, dh
 EA3D  6B F8 50					imul    di, ax, 80
 EA40  03 FA					add     di, dx
 EA42  B2 50					mov     dl, 80          ; dh = 0
 EA44  2A D1					sub     dl, cl
 EA46  8A C3					mov     al, bl
 EA48  69 F0 00A0				imul    si, ax, 160
 EA4C  C3					ret
				;---------------- fn 08h, read char/attr
 EA4D				readchar:
 EA4D  53					push    bx
 EA4E  E8 0004					call    mode3chaddr
 EA51  8B 07					mov     ax, [bx]
 EA53  5B					pop     bx
 EA54  C3					ret

 EA55				mode3chaddr:    ; returns current char address in mode3 in ds:bx. Input: bh=page, ds=40h 
 EA55  50					push    ax
 EA56  81 E3 0700				and     bx, 700h
 EA5A  8D 87 B800				lea     ax, [bx+0b800h]
 EA5E  C1 EB 07					shr     bx, 7
 EA61  8B 5F 50					mov     bx, CursorPos[bx]
 EA64  8E D8					mov     ds, ax
 EA66  33 C0					xor     ax, ax
 EA68  86 C7					xchg    al, bh
 EA6A  6B C0 50					imul    ax, 80
 EA6D  03 D8					add     bx, ax
 EA6F  03 DB					add     bx, bx
 EA71  58					pop     ax
 EA72  C3					ret

				;---------------- fn 09h, write char/attr
 EA73				writecharattr:
 EA73  50					push    ax
 EA74  06					push    es
 EA75  53					push    bx
 EA76  51					push    cx
 EA77  8A E3					mov     ah, bl
 EA79  E8 FFD9		call    mode3chaddr
 EA7C  1E					push    ds
 EA7D  07					pop     es
 EA7E  87 FB					xchg    di, bx
 EA80  F3/ AB					rep     stosw
 EA82  87 FB					xchg    di, bx
 EA84  59					pop     cx
 EA85  5B					pop     bx
 EA86  07					pop     es
 EA87  58					pop     ax
 EA88  C3					ret

				;---------------- fn 0ah, write char
 EA89				writechar:
 EA89  E3 0E					jcxz    short writecharskip
 EA8B  53					push    bx
 EA8C  51					push    cx
 EA8D  E8 FFC5					call    mode3chaddr
 EA90				writechar3:        
 EA90  88 07					mov     [bx], al
 EA92  83 C3 02					add     bx, 2
 EA95  E2 F9					loop    short writechar3
 EA97  59					pop     cx
 EA98  5B					pop     bx
 EA99				writecharskip:        
 EA99  C3					ret

				;---------------- fn 0bh,  Set Color Palette (CGA)
 EA9A				setcolorpalette:
 EA9A  52					push    dx
 EA9B  1E					push    ds
 EA9C  6A 40					push    40h
 EA9E  1F					pop     ds
 EA9F  BA 03D9					mov     dx, 03d9h
 EAA2  A0 0066					mov     al, CrtPalette
 EAA5  0A FF					or      bh, bh
 EAA7  75 09					jnz     setcolorpalette_pal
 EAA9  24 20					and     al, 020h ; clear brightness and color
 EAAB  80 E3 1F					and     bl, 01fh
 EAAE  0A C3					or      al, bl
 EAB0  EB 07					jmp short setcolorpalette_out
 EAB2				setcolorpalette_pal:
 EAB2  24 1F					and     al, 01fh ; clear palette bit
 EAB4  C0 E3 05					shl     bl, 5
 EAB7  0A C3					or      al, bl
 EAB9				setcolorpalette_out:
 EAB9  EE					out     dx,al
 EABA  A2 0066					mov     CrtPalette, al
 EABD  1F					pop     ds
 EABE  5A					pop     dx
 EABF  C3					ret

				;---------------- fn 0eh, write char as TTY
 EAC0				writecharTTY:
 EAC0  50					push    ax
 EAC1  53					push    bx
 EAC2  52					push    dx
 EAC3  8A 1E 0062				mov     bl, ActivePage
 EAC7  B7 00					mov     bh, 0
 EAC9  03 DB					add     bx, bx
 EACB  8B 57 50					mov     dx, CursorPos[bx]
 EACE  C1 E3 07					shl     bx, 7
 EAD1  B4 0A					mov     ah, 0ah
 EAD3  E8 0008					call    tty
 EAD6  B4 02					mov     ah, 2       ; set cursor pos
 EAD8  CD 10					int     10h
 EADA  5A					pop     dx
 EADB  5B					pop     bx
 EADC  58					pop     ax 
 EADD  C3					ret        

 EADE				tty:    ; dx=xy, bh=page, al=char, bl=attr, ah=0ah(no attr) or 09h(with attr)
 EADE  F7 06 0018 0008				test    word ptr KbdFlags2, Pause
 EAE4  75 F8					jnz     short tty
 EAE6  51					push    cx
 EAE7  3C 07					cmp     al, 7
 EAE9  74 1A					je      short bell
 EAEB  3C 08					cmp     al, 8
 EAED  74 18					je      short bs
 EAEF  3C 0A					cmp     al, 0ah
 EAF1  74 22					je      short cr
 EAF3  3C 0D					cmp     al, 0dh
 EAF5  74 18					je      short lf
 EAF7  B9 0001					mov     cx, 1
 EAFA  CD 10					int     10h         ; write char at cursor
 EAFC  42					inc     dx
 EAFD  3A 16 004A				cmp     dl, ScreenWidth
 EB01  73 10					jae     short crlf
 EB03				tty1:
 EB03  59					pop     cx
 EB04  C3					ret
 EB05				bell:
				; TODO bell code        
 EB05  EB FC					jmp     short tty1
 EB07				bs:
 EB07  80 EA 01					sub     dl, 1
 EB0A  80 D2 00					adc     dl, 0      
 EB0D  EB F4					jmp     short tty1
 EB0F				lf:
 EB0F  B2 00					mov     dl, 0
 EB11  EB F0					jmp     short tty1
 EB13				crlf:
 EB13  B2 00					mov     dl, 0        
 EB15				cr:        
 EB15  FE C6					inc     dh
 EB17  3A 36 0084				cmp     dh, ScreenRows
 EB1B  76 E6					jbe     short tty1
 EB1D  FE CE					dec     dh
				;        mov     ah, 8
				;        int     10h         ; read attribute at cursor pos
 EB1F  53					push    bx          ; save active page in bh
 EB20  52					push    dx
				;        xchg    ax, bx
 EB21  B7 07					mov     bh, 7       ; default attribute
 EB23  B8 0601					mov     ax, 601h    
 EB26  8A 36 0084				mov     dh, ScreenRows
 EB2A  8A 16 004A				mov     dl, ScreenWidth
 EB2E  4A					dec     dx
 EB2F  33 C9					xor     cx, cx
 EB31  CD 10					int     10h         ; scroll up
 EB33  5A					pop     dx
 EB34  5B					pop     bx          ; restore active page in bh         
 EB35  EB CC					jmp     short tty1
						
				;---------------- fn 0fh, read video mode
 EB37				readmode:
 EB37  A0 0087					mov     al, EgaMiscInfo
 EB3A  24 80					and     al, 80h
 EB3C  0A 06 0049				or      al, ActiveVideoMode
 EB40  8A 26 004A				mov     ah, ScreenWidth
 EB44  8A 3E 0062				mov     bh, ActivePage
 EB48  C3					ret


				;---------------- fn 10h, palette
 EB49 EB8F R EB8E R EB9F R	paltable    dw  setonereg, palexit, setallreg, setblink, palexit, palexit, palexit, readonereg, readoverscan, readallreg, palexit, palexit, palexit, palexit, palexit, palexit
       EBB3 R EB8E R EB8E R
       EB8E R EBDF R EC0B R
       EBF4 R EB8E R EB8E R
       EB8E R EB8E R EB8E R
       EB8E R
 EB69  EC0E R EB8E R EC24 R				dw  setoneDAC, palexit, setblockDAC, paging, palexit, readoneDAC, palexit, readblockDAC, setPELmask, getPELmask, getpaging, grayscale
       EC35 R EB8E R EC65 R
       EB8E R EC7D R EC8E R
       EC97 R ECA0 R ECB6 R

 EB81				pal:
 EB81  3C 1B					cmp     al, 1bh
 EB83  77 09					ja      short palexit
 EB85  8B F0					mov     si, ax
 EB87  03 F6					add     si, si
 EB89  2E: FF 94 CB49 R				call    cs:paltable[si-2000h]
 EB8E				palexit:
 EB8E  C3					ret

 EB8F				setonereg:
 EB8F  60					pusha
 EB90  BA 03DA					mov		dx, 3dah
 EB93  EC					in		al, dx
 EB94  BA 03C0					mov		dx, 3c0h
 EB97  8A C3					mov		al, bl
 EB99  EE					out		dx, al
 EB9A  8A C7					mov		al, bh
 EB9C  EE					out		dx, al
 EB9D  61					popa
 EB9E				setonereg1:        
 EB9E  C3					ret        

 EB9F				setallreg:
 EB9F  60					pusha
 EBA0  B0 00					mov     al, 0
 EBA2  8B F2					mov     si, dx
 EBA4  B3 0F					mov     bl, 15
 EBA6				setallreg1:        
 EBA6  26: 8A 7C 0F				mov     bh, es:[si+15]
 EBAA  CD 10					int     10h
 EBAC  4E					dec     si
 EBAD  FE CB					dec     bl
 EBAF  79 F5					jns     short setallreg1
 EBB1  61					popa
 EBB2  C3					ret

 EBB3				setblink:
 EBB3  60					pusha
 EBB4  BA 03DA					mov		dx, 3dah
 EBB7  EC					in		al, dx
 EBB8  BA 03C0					mov     dx, 3c0h
 EBBB  B0 10					mov     al, 10h
 EBBD  EE					out     dx, al
 EBBE  2E: A0 E6A9 R				mov		al, cs:p3c0r10      
 EBC2  C0 E3 03					shl     bl, 3
 EBC5  32 C3					xor		al, bl
 EBC7  24 F7					and		al, not 8
 EBC9  32 C3					xor		al, bl
 EBCB  EE					out     dx, al          ; set blink flag
 EBCC  2E: A2 E6A9 R				mov		cs:p3c0r10, al
 EBD0  C0 E0 02					shl     al, 2
 EBD3  32 06 0089				xor     al, VgaFlags
 EBD7  24 20					and     al, 20h
 EBD9  30 06 0089				xor     VgaFlags, al
 EBDD				setblink1:
 EBDD  61					popa
 EBDE  C3					ret

 EBDF				readonereg:
 EBDF  52					push	dx
 EBE0  50					push	ax
 EBE1  BA 03DA					mov		dx, 3dah
 EBE4  EC					in		al, dx
 EBE5  BA 03C0					mov		dx, 3c0h
 EBE8  8A C3					mov		al, bl
 EBEA  EE					out		dx, al
 EBEB  42					inc		dx
 EBEC  EC					in		al, dx
 EBED  4A					dec		dx
 EBEE  EE					out		dx, al
 EBEF  8A F8					mov		bh, al
 EBF1  58					pop		ax
 EBF2  5A					pop		dx
 EBF3  C3					ret

 EBF4				readallreg:
 EBF4  60					pusha
 EBF5  8B FA					mov     di, dx
 EBF7  B3 00					mov     bl, 0
 EBF9				readllreg1:
 EBF9  B0 07					mov     al, 7
 EBFB  CD 10					int     10h
 EBFD  8A C7					mov     al, bh
 EBFF  AA					stosb
 EC00  43					inc     bx
 EC01  80 FB 10					cmp     bl, 16
 EC04  75 F3					jne     short readllreg1
 EC06  B0 00					mov     al, 0   ; overscan color
 EC08  AA					stosb
 EC09  61					popa
 EC0A  C3					ret

 EC0B				readoverscan:
 EC0B  B7 00					mov     bh, 0
 EC0D  C3					ret

 EC0E				setoneDAC:
 EC0E  50					push    ax
 EC0F  52					push    dx
 EC10  92					xchg    ax, dx
 EC11  8A C3					mov     al, bl
 EC13  BA 03C8					mov     dx, 3c8h
 EC16  EE					out     dx, al
 EC17  42					inc     dx
 EC18  8A C4					mov     al, ah
 EC1A  EE					out     dx, al
 EC1B  8A C5					mov     al, ch
 EC1D  EE					out     dx, al
 EC1E  8A C1					mov     al, cl
 EC20  EE					out     dx, al
 EC21  5A					pop     dx
 EC22  58					pop     ax
 EC23  C3					ret

 EC24				setblockDAC:
 EC24  60					pusha
 EC25  8B F2					mov     si, dx
 EC27  BA 03C8					mov     dx, 3c8h
 EC2A  93					xchg    ax, bx
 EC2B  EE					out     dx, al
 EC2C  42					inc     dx
 EC2D  6B C9 03					imul    cx, 3
 EC30  F3/ 26: 6E				rep     outsb dx, es:[si]
 EC33  61					popa
 EC34  C3					ret

 EC35				paging:
 EC35  60					pusha
 EC36  BA 03DA					mov		dx, 3dah
 EC39  EC					in		al, dx
 EC3A  BA 03C0					mov		dx, 3c0h
 EC3D  84 DB					test    bl, bl
 EC3F  2E: A0 E6A9 R				mov		al, cs:p3c0r10
 EC43  75 11					jnz     short paging1
 EC45  02 C0					add		al, al
 EC47  D0 CF					ror		bh, 1
 EC49  D0 D8					rcr		al, 1
 EC4B  2E: A2 E6A9 R				mov		cs:p3c0r10, al
 EC4F  50					push	ax
 EC50  B0 10					mov		al, 10h
 EC52  EE					out		dx, al
 EC53  58					pop		ax
 EC54  EB 0C					jmp     short paging2
 EC56				paging1:
 EC56  02 C0					add		al, al
 EC58  72 03					jc		paging3
 EC5A  C0 E7 02					shl		bh, 2
 EC5D				paging3:
 EC5D  B0 14					mov		al, 14h
 EC5F  EE					out		dx, al
 EC60  8A C7					mov		al, bh
 EC62				paging2:        
 EC62  EE					out		dx, al
 EC63  61					popa
 EC64  C3					ret

 EC65				readoneDAC:
 EC65  50					push    ax
 EC66  52					push    dx
 EC67  8A C3					mov     al, bl
 EC69  BA 03C7					mov     dx, 3c7h
 EC6C  EE					out     dx, al
 EC6D  42					inc     dx
 EC6E  42					inc     dx
 EC6F  EC					in      al, dx
 EC70  8A E0					mov     ah, al
 EC72  EC					in      al, dx
 EC73  8A E8					mov     ch, al
 EC75  EC					in      al, dx
 EC76  8A C8					mov     cl, al
 EC78  5A					pop     dx
 EC79  8A F4					mov     dh, ah
 EC7B  58					pop     ax             
 EC7C  C3					ret

 EC7D				readblockDAC:
 EC7D  60					pusha
 EC7E  8B FA					mov     di, dx
 EC80  BA 03C7					mov     dx, 3c7h
 EC83  93					xchg    ax, bx
 EC84  EE					out     dx, al
 EC85  42					inc     dx
 EC86  42					inc     dx
 EC87  6B C9 03					imul    cx, 3
 EC8A  F3/ 6C					rep     insb                
 EC8C  61					popa
 EC8D  C3					ret

 EC8E				setPELmask:
 EC8E  52					push    dx
 EC8F  93					xchg    ax, bx
 EC90  BA 03C6					mov     dx, 3c6h
 EC93  EE					out     dx, al
 EC94  93					xchg    ax, bx
 EC95  5A					pop     dx
 EC96  C3					ret

 EC97				getPELmask:
 EC97  52					push    dx
 EC98  93					xchg    ax, bx
 EC99  BA 03C6					mov     dx, 3c6h
 EC9C  EC					in      al, dx
 EC9D  93					xchg    ax, bx
 EC9E  5A					pop     dx
 EC9F  C3					ret

 ECA0				getpaging:
 ECA0  B3 14					mov		bl, 14h
 ECA2  E8 FF3A					call	readonereg	; returns BH
 ECA5  2E: 8A 1E E6A9 R				mov		bl, cs:p3c0r10
 ECAA  80 E7 0F					and		bh, 0fh
 ECAD  C0 EB 07					shr		bl, 7
 ECB0  75 03					jnz		short getpaging1
 ECB2  C0 EF 02					shr		bh, 2
 ECB5				getpaging1:
 ECB5  C3					ret

 ECB6				grayscale:
 ECB6  E3 2B					jcxz    short grayscale2
 ECB8  60					pusha
 ECB9  8A F9					mov     bh, cl
 ECBB				grayscale1:        
 ECBB  B0 15					mov     al, 15h
 ECBD  CD 10					int     10h
 ECBF  C1 EA 08					shr     dx, 8
 ECC2  6B F2 4D					imul    si, dx, 77
 ECC5  8A D5					mov     dl, ch
 ECC7  69 D2 0097				imul    dx, 151
 ECCB  B5 00					mov     ch, 0
 ECCD  6B C9 1C					imul    cx, 28
 ECD0  03 D6					add     dx, si
 ECD2  03 D1					add     dx, cx
 ECD4  8A EE					mov     ch, dh
 ECD6  8A CE					mov     cl, dh
 ECD8  B0 10					mov     al, 10h
 ECDA  CD 10					int     10h
 ECDC  FE C3					inc     bl
 ECDE  FE CF					dec     bh
 ECE0  75 D9					jne     short grayscale1        
 ECE2  61					popa
 ECE3				grayscale2:        
 ECE3  C3					ret


				;---------------- fn 11h, character generator
 ECE4				loadUDF:    ; CX=chars, DX=first char, BH=bytes/char, ES:BP=font
 ECE4  60					pusha
 ECE5  92					xchg    ax, dx
 ECE6  87 CB					xchg    cx, bx
 ECE8  C1 E9 10					shr     cx, 16 ; 8 when fonts are installed
 ECEB  BA 03CB					mov     dx, 03cbh
 ECEE  8B F5					mov     si, bp
 ECF0				loadUDF1:
 ECF0  EF					out     dx, ax
 ECF1  51					push    cx
 ECF2  F3/ 26: 6E		        rep     outsb dx, es:[si]
 ECF5  59					pop     cx
 ECF6  40					inc     ax
 ECF7  4B					dec     bx
 ECF8  75 F6					jnz     short loadUDF1
 ECFA  61					popa
 ECFB  A8 10					test    al, 10h
 ECFD  74 31					jz      short loadUDFexit
 ECFF  6A 40					push    40h
 ED01  1F					pop     ds
 ED02  50					push    ax
 ED03  B8 0190					mov     ax, 400 ; screen lines in text mode
 ED06  F6 F7					div     bh
 ED08  48					dec     ax
 ED09  A2 0084					mov     ScreenRows, al
 ED0C  88 3E 0085				mov     byte ptr ScanLinesChar, bh
 ED10  2E: A0 E6A9 R				mov		al, cs:p3c0r10		; set/reset half bit
 ED14  32 C7					xor		al, bh		
 ED16  0C 10					or		al, 10h
 ED18  32 C7					xor		al, bh
 ED1A  A8 01					test	al, 1
 ED1C  75 11					jnz		short loadUDFexit1	; not in text mode
 ED1E  50					push	ax
 ED1F  BA 03DA					mov		dx, 3dah
 ED22  EC					in		al, dx
 ED23  BA 03C0					mov		dx, 3c0h
 ED26  B0 10					mov		al, 10h
 ED28  EE					out		dx, al
 ED29  58					pop		ax
 ED2A  EE					out		dx, al
 ED2B  2E: A2 E6A9 R				mov		cs:p3c0r10, al
 ED2F				loadUDFexit1:
 ED2F  58					pop     ax 
 ED30				loadUDFexit:        
 ED30  C3					ret

 ED31				chargen:
 ED31  A8 EF					test    al, not 10h     ; test for 00h and 10h  ; UDF
 ED33  74 AF					jz      short loadUDF
 ED35  A8 EE					test    al, not 11h     ; test for 01h and 11h  ; 8x14
 ED37  74 26					jz      short loadROMfont16
 ED39  A8 ED					test    al, not 12h     ; test for 02h and 12h  ; 8x8
 ED3B  74 17					jz      short loadROMfont8
 ED3D  A8 EB					test    al, not 14h     ; test for 04h and 14h  ; 8x16
 ED3F  74 1E					jz      short loadROMfont16
 ED41  3C 20					cmp     al, 20h
 ED43  72 EB					jb      loadUDFexit
 ED45  74 30					je      short set1f
 ED47  3C 21					cmp     al, 21h
 ED49  74 37					je      short setgrUDF
 ED4B  3C 24					cmp     al, 24h
 ED4D  76 60					jbe     short setROMgrFont
 ED4F  3C 30					cmp     al, 30h
 ED51  74 7A					je      short getfontinfo
 ED53  C3					ret

 ED54				loadROMFont8:
 ED54  60					pusha
 ED55  BB 0800					mov     bx, 0800h       ; 8x8 chars, block 0
 ED58  2E: 8B 2E EDFE R				mov     bp, cs:fontinfo[2]
 ED5D  EB 09					jmp     short loadROMFont161
					 
 ED5F				loadROMFont16:
 ED5F  60					pusha
 ED60  BB 1000					mov     bx, 1000h       ; 8x16 chars, block 0
 ED63  2E: 8B 2E EE04 R				mov     bp, cs:fontinfo[8]
 ED68				loadROMFont161:
 ED68  B9 0100					mov     cx, 100h        ; all chars
 ED6B  33 D2					xor     dx, dx
 ED6D  06					push    es
 ED6E  0E					push    cs
 ED6F  07					pop     es
 ED70  24 10					and     al, 10h
 ED72  CD 10					int     10h             ; loadUDF
 ED74  07					pop     es
 ED75  61					popa
 ED76  C3					ret

 ED77				set1f:
 ED77  33 F6					xor     si, si
 ED79  8E DE					mov     ds, si
 ED7B  89 6C 7C					mov     [si+1fh*4], bp
 ED7E  8C 44 7E					mov     [si+1fh*4+2], es
 ED81  C3					ret
						
 ED82				setgrUDF:
 ED82  60					pusha
 ED83  E3 AB					jcxz    short loadUDFexit
 ED85  1E					push    ds
 ED86  33 F6					xor     si, si
 ED88  8E DE					mov     ds, si
 ED8A  89 AC 010C				mov     [si+43h*4], bp
 ED8E  8C 84 010E				mov     [si+43h*4+2], es
 ED92  1F					pop     ds
 ED93  B8 00C8					mov     ax, 200
 ED96  80 3E 0049 13				cmp     byte ptr ActiveVideoMode, 13h
 ED9B  72 10					jb      short setgrUDFexit
 ED9D  74 03					je      short setgrUDF1
 ED9F  B8 01E0					mov     ax, 480         ; mode 25h, 480 lines
 EDA2				setgrUDF1:
 EDA2  89 0E 0085				mov     ScanLinesChar, cx
 EDA6  99					cwd
 EDA7  F7 F1					div     cx
 EDA9  48					dec     ax
 EDAA  A2 0084					mov     ScreenRows, al
 EDAD				setgrUDFexit:
 EDAD  61					popa
 EDAE  C3					ret

 EDAF				setROMgrFont:       
 EDAF  60					pusha
 EDB0  06					push    es
 EDB1  B9 0008					mov     cx, 8
 EDB4  0E					push    cs
 EDB5  07					pop     es
 EDB6  BD D800 R				mov     bp, font8x8
 EDB9  3C 23					cmp     al, 23h
 EDBB  74 03					je      short setROMgrFont1
 EDBD  BD C800 R				mov     bp, offset font8x16
 EDC0				setROMgrFont1:        
 EDC0  B0 21					mov     al, 21h
 EDC2  CD 10					int     10h     ; set graphic UDF
 EDC4  48					dec     ax
 EDC5  BD DC00 R				mov     bp, font8x8 + 128*8
 EDC8  CD 10					int     10h     ; set INT 1fh
 EDCA  07					pop     es
 EDCB  61					popa
 EDCC  C3					ret
						
 EDCD				getfontinfo:
 EDCD  8B 0E 0085				mov     cx, ScanLinesChar
 EDD1  8A 16 0084				mov     dl, ScreenRows
 EDD5  80 FF 01					cmp     bh, 1
 EDD8  77 0E					ja      short getfontinfo1
 EDDA  6A 00					push    0
 EDDC  1F					pop     ds
 EDDD  C4 2E 007C				les     bp, ds:[1fh*4] 
 EDE1  72 18					jb      short getfontinfoexit
 EDE3  C4 2E 010C				les     bp, ds:[43h*4]
 EDE7  C3					ret
 EDE8				getfontinfo1:
 EDE8  80 FF 07					cmp     bh, 7
 EDEB  77 0E					ja      short getfontinfoexit
 EDED  8B F3					mov     si, bx
 EDEF  C1 EE 08					shr     si, 8
 EDF2  03 F6					add     si, si
 EDF4  2E: 8B AC EDF8 R				mov     bp, cs:fontinfo[si-4]
 EDF9  0E					push    cs
 EDFA  07					pop     es                    
 EDFB				getfontinfoexit:
 EDFB  C3					ret

 EDFC BA00 R D800 R DC00 R	fontinfo    dw  font8x14, font8x8, font8x8+128*8, font8x14, font8x16, font8x16
       BA00 R C800 R C800 R

				;---------------- fn 12h, special functions
 EE08				special:
 EE08  80 FB 10					cmp     bl, 10h
 EE0B  75 0B					jne     short special1
 EE0D  8A 0E 0088				mov     cl, EgaMiscInfo2    ; cl = switch settings
 EE11  83 E1 0F					and     cx, 15              ; ch <- 0 (feature bits)
 EE14  BB 0003					mov     bx, 3               ; bh <- 0 (color mode), bl = video memory size
 EE17  C3					ret
 EE18				special1:
 EE18  80 FB 31					cmp     bl, 31h
 EE1B  75 0F					jne     short special2
 EE1D  F6 D8					neg     al
 EE1F  32 06 0089				xor     al, VgaFlags
 EE23  24 08					and     al, 8       ; transfer palette loading bit to VgaFlags
 EE25  30 06 0089				xor     VgaFlags, al
 EE29  B0 12					mov     al, 12h     ; supported function
 EE2B  C3					ret
 EE2C				special2:
 EE2C  B0 00					mov     al, 0       ; unsupported function
 EE2E  C3					ret


				;---------------- fn 13h, write string
 EE2F				writestr:
 EE2F  E3 31					jcxz    short wstrexit
 EE31  60					pusha
 EE32  8B F3					mov     si, bx
 EE34  C1 EE 08					shr     si, 8
 EE37  03 F6					add     si, si
 EE39  FF 74 50					push    CursorPos[si]
 EE3C  B4 09					mov     ah, 9       ; write tty char/attribute
 EE3E				wstr1:        
 EE3E  50					push    ax
 EE3F  A8 02					test    al, 2
 EE41  26: 8A 46 00				mov     al, es:[bp]
 EE45  74 05					jz      short noattr
 EE47  45					inc     bp
 EE48  26: 8A 5E 00				mov     bl, es:[bp]
 EE4C				noattr:
 EE4C  45					inc     bp
 EE4D  89 54 50					mov     CursorPos[si], dx
 EE50  E8 FC8B					call    tty
 EE53  58					pop     ax
 EE54  E2 E8					loop    short wstr1
 EE56  8F 44 50					pop     CursorPos[si]
 EE59  A8 01					test    al, 1
 EE5B  74 04					jz      short wstr2             
 EE5D  B4 02					mov     ah, 2       ; set cursor pos
 EE5F  CD 10					int     10h                
 EE61				wstr2:        
 EE61  61					popa
 EE62				wstrexit:        
 EE62  C3					ret

				;---------------- fn 1ah, get/set display combination code
 EE63				getdcc:
 EE63  3C 01					cmp     al, 1
 EE65  77 0C					ja      short getdccexit
 EE67  8A C4					mov     al, ah
 EE69  74 03					je      short setdcc
 EE6B  BB 0008					mov     bx, 08h
 EE6E				dccval  label word        
 EE6E				setdcc:
 EE6E  2E: 89 1E EE6C R				mov     cs:[dccval-2], bx
 EE73				getdccexit:        
 EE73  C3					ret        

				;---------------- fn 1bh, query status
 EE74				querystatus:
 EE74  60					pusha
 EE75  B8 EED3 R				mov     ax, offset staticfunctable
 EE78  AB					stosw
 EE79  8C C8					mov     ax, cs
 EE7B  AB					stosw
 EE7C  BE 0049					mov     si, offset ActiveVideoMode
 EE7F  80 3C 12					cmp     byte ptr [si], 12h
 EE82  B9 0021					mov     cx, 33          ; info copied from BDA        
 EE85  F3/ A4					rep     movsb
 EE87  B8 0008					mov     ax, 8
 EE8A  AB					stosw                   ; display info (one VGA analog color monitor)
 EE8B  BB 0208					mov     bx, 208h        ; 400 scan lines, 8 pages
 EE8E  B0 10					mov     al, 10h         ; 16 colors         
 EE90  72 14					jb      short querystatus1	; mode03h
 EE92  BB 0302					mov		bx, 302h	; 480 scan lines, 2 pageS
 EE95  74 0F					je		short querystatus1	; mode12h 
 EE97  B7 00					mov     bh, 0           ; scan lines code (0=200, 1=350, 2=400, 3=480)
 EE99  B8 0100					mov     ax, 100h        ; 256 colors
 EE9C  80 3E 0049 13				cmp     byte ptr ActiveVideoMode, 13h
 EEA1  74 0D					je      short querystatus3     ; mode13h
 EEA3  BB 0301					mov     bx, 301h        ; 480 scan lines, 1 page
 EEA6				querystatus1:
 EEA6  80 3E 0049 0D				cmp		byte ptr ActiveVideoMode, 0dh
 EEAB  75 03					jne		short querystatus3
 EEAD  BB 0008					mov		bx, 0008h	; 200 scan lines, 8 pages
 EEB0				querystatus3:
 EEB0  AB					stosw
 EEB1  93					xchg    ax, bx
 EEB2  AB					stosw
 EEB3  33 C0					xor     ax, ax
 EEB5  AB					stosw                   ; font block info (45)
 EEB6  A0 0089					mov     al, VgaFlags
 EEB9  24 2F					and     al, 00101111b
 EEBB  AB					stosw        
 EEBC  AB					stosw
 EEBD  A0 0087					mov     al, EgaMiscInfo
 EEC0  C0 E8 04					shr     al, 4
 EEC3  24 07					and     al, 7           ; video memory size
 EEC5  AB					stosw
 EEC6  B0 02					mov     al, 2
 EEC8  AA					stosb                   ; color display attached
 EEC9  B1 06					mov     cl, 6
 EECB  33 C0					xor     ax, ax
 EECD  F3/ AB					rep     stosw           ; 12 reserved bytes
 EECF  61					popa
 EED0  8A C4					mov     al, ah          ; supported function
 EED2  C3					ret

 EED3 0C			staticfunctable db  00001100b   ; video modes 2h, 3h supported
 EED4  60							db  01100000b	; video mode 0dh, 0eh supported
 EED5  0D							db  00001101b   ; video modes 10h, 12h, 13h supported
 EED6  00							db  00000000b
 EED7  20							db  00100000b   ; video mode 25h supported
 EED8  00 00							db  0, 0
 EEDA  04							db  00000100b   ; 400 scanline supported
 EEDB  01							db  1           ; font blocks available in text mode
 EEDC  01							db  1           ; max active font blocks available in text mode

				;Bit(s)  Description
				;0      all modes on all displays function supported
				;1      gray summing function supported
				;2      character font loading function supported
				;3      default palette loading enable/disable supported
				;4      cursor emulation function supported
				;5      EGA palette present
				;6      color palette present
				;7      color-register paging function supported
				;8      light pen supported (see AH=04h)
				;9      save/restore state function 1Ch supported
				;10     intensity/blinking function supported (see AX=1003h)
				;11     Display Combination Code supported (see #00039)
				;12-15  unused (0)
 EEDD  EF					db  11101111b   ; miscellaneous function support flags 
 EEDE  0C					db  00001100b   ; miscellaneous function support flags
								 
 EEDF  00 00					db  0, 0        ; reserved
 EEE1  00					db  0           ; save pointer function flags
 EEE2  00					db  0           ; reserved  

					   
 EEE3 E713 R E925 R E945 R	vidtbl  dw  setmode, cursor, curpos, getcurpos, lightpen, apage, scrollup, scrolldn, readchar, writecharattr
       E97A R E98A R E98D R
       E9E6 R EA26 R EA4D R
       EA73 R
 EEF7  EA89 R EA9A R E924 R			dw  writechar, setcolorpalette, nullproc, nullproc, writecharTTY, readmode
       E924 R EAC0 R EB37 R
 EF03  EB81 R ED31 R EE08 R			dw  pal, chargen, special, writestr, nullproc, nullproc, nullproc, nullproc, nullproc, nullproc, getdcc, querystatus, nullproc
       EE2F R E924 R E924 R
       E924 R E924 R E924 R
       E924 R EE63 R EE74 R
       E924 R
 EF1D				int10 endp

				; --------------------- INT 11h - Equipment ----------------
 = ds:[10h]			EquipmentWord       equ     <ds:[10h]>

 EF1D				int11   proc near
 EF1D  1E					push    ds
 EF1E  6A 40					push    40h
 EF20  1F					pop     ds
 EF21  A1 0010					mov     ax, EquipmentWord
 EF24  1F					pop     ds
 EF25  CF					iret
 EF26				int11   endp

				; --------------------- INT 12h - Memory size ----------------
 = ds:[13h]			MemorySize       equ     <ds:[13h]>

 EF26				int12   proc near
 EF26  1E					push    ds
 EF27  6A 40					push    40h
 EF29  1F					pop     ds
 EF2A  A1 0013					mov     ax, MemorySize
 EF2D  1F					pop     ds
 EF2E  CF					iret        
 EF2F				int12   endp

				; --------------------- INT 13h - Disk services ----------------
 = ds:[74h]			HDLastError       equ     <ds:[74h]>
 = ds:[92h]			HDOpStarted       equ     <ds:[92h]>    ; bit 3: in INT13h (all other bits must be 0)
 = ds:[94h]			HDSize            equ     <ds:[94h]>

 EF2F				int13   proc near
 EF2F  1E					push    ds
 EF30  55					push    bp
 EF31  6A 40					push    40h
 EF33  1F					pop     ds
 EF34  80 36 0092 08				xor     byte ptr HDOpStarted, 8
 EF39  74 13					jz      short inINT13
 EF3B  FB					sti                     
 EF3C  FC					cld
 EF3D  80 FC 1A					cmp     ah, 1ah
 EF40  76 10					jbe     short Disk1
 EF42  80 EC 26					sub     ah, 41h-1bh     ; extensions
 EF45  80 FC 22					cmp     ah, 22h
 EF48  76 08					jbe     short Disk1
 EF4A  B4 01					mov     ah, 1           ; bad command error
 EF4C  EB 14					jmp     short exit
 EF4E				inINT13:        
 EF4E  B4 AA					mov     ah, 0aah        ; drive not ready
 EF50  EB 14					jmp     short exit2
 EF52				Disk1:
 EF52  8B E8					mov     bp, ax
 EF54  C1 ED 07					shr     bp, 7
 EF57  81 E5 01FE				and     bp, 1feh
 EF5B  1E					push    ds
 EF5C  2E: FF 96 EF7A R				call    cs:disktbl[bp]
 EF61  1F					pop     ds
 EF62				exit:        
 EF62  88 26 0074				mov     HDLastError, ah
 EF66				exit2:
 EF66  80 36 0092 08				xor     byte ptr HDOpStarted, 8
 EF6B  F6 DC					neg     ah              ; CF <- (AH != 0)
 EF6D				exit1:
 EF6D  8B EC					mov     bp, sp
 EF6F  D0 5E 08					rcr     byte ptr [bp+8], 1
 EF72  D0 46 08					rol     byte ptr [bp+8], 1  ; insert error CF on stack
 EF75  F6 DC					neg     ah
 EF77  5D					pop     bp
 EF78  1F					pop     ds
 EF79  CF					iret

 EF7A EFEE R EFF1 R F000 R	disktbl dw      DiskReset, DiskGetStatus, DiskRead, DiskWrite, DiskVerify, DiskFormat, DiskFormat, DiskFormat, DiskGetParams, DiskInit, DiskRead, DiskWrite, DiskSeek, DiskRst, DiskReadSectBuffer, DiskWriteSectBuffer
       EFFB R EFF6 R F04A R
       F04A R F04A R F059 R
       F04A R F000 R EFFB R
       F04A R F04A R F119 R
       F119 R
 EF9A  F04A R F04A R F04A R			dw      DiskReady, DiskRecalibrate, DiskDiag, DiskDiag, DiskDiag, DiskGetType, DiskChanged, DiskSetDASDType, DiskSetMediaType, DiskPark, DiskFormat,  DiskExtInstCheck, DiskExtRead, DiskExtWrite, DiskExtVerify, DiskExtLock
       F04A R F04A R EFC0 R
       EFEE R F119 R F119 R
       EFEE R F04A R EFE0 R
       F09A R F095 R F090 R
       F119 R
 EFBA  F119 R F04A R F0CC R			dw      DiskExtEject, DiskExtSeek, DiskExtGetParams

 EFC0				DiskGetType:
 EFC0  80 FA 80					cmp     dl, 80h
 EFC3  75 29					jne     short DiskReset ; ah=0, drive not present
 EFC5  8B 0E 0094				mov     cx, HDSize      
 EFC9  8B D1					mov     dx, cx
 EFCB  85 C9					test    cx, cx
 EFCD  74 1F					jz      short DiskReset ; ah=0, drive not present
 EFCF  B4 FD					mov     ah, -3      ; HD present
 EFD1  C1 E9 06					shr     cx, 6
 EFD4  C1 E2 0A					shl     dx, 10      ; CX:DX = HDSize * 1024
 EFD7				DiskGetTypeexit:        
 EFD7  1F					pop     ds          ; discard ret address
 EFD8  1F					pop     ds          ; discard DS
 EFD9  80 36 0092 08				xor     byte ptr HDOpStarted, 8     ; CF <- 0 
 EFDE  EB 8D					jmp     short   exit1        

 EFE0				DiskExtInstCheck:
 EFE0  86 DF					xchg    bl, bh
 EFE2  B4 FF					mov     ah, -1
 EFE4  B9 0001					mov     cx, 1       ; extended disk access functions (AH=42h-44h,47h,48h) supported
 EFE7  80 FA 80					cmp     dl, 80h
 EFEA  75 6A					jne     short notready
 EFEC  EB E9					jmp     short DiskGetTypeexit

 EFEE				DiskReset:
 EFEE				DiskChanged:
 EFEE				DiskPark:
 EFEE  B4 00					mov     ah, 0       ; success
 EFF0  C3					ret

 EFF1				DiskGetStatus:
 EFF1  8A 26 0074				mov     ah, HDLastError
 EFF5  C3					ret
					  
 EFF6				DiskVerify:
 EFF6  BD F7D7 R				mov     bp, sdverify
 EFF9  EB 08					jmp     short   DiskRead1
 EFFB				DiskWrite:
 EFFB  BD F857 R				mov     bp, sdwrite
 EFFE  EB 03					jmp     short   DiskRead1
 F000				DiskRead:
 F000  BD F7DC R				mov     bp, sdread
 F003				DiskRead1:        
 F003  84 C0					test    al, al
 F005  74 E7					jz      short DiskReset
 F007  80 FA 80					cmp     dl, 80h
 F00A  75 4A					jne     short notready
 F00C  B4 04					mov     ah, 4
 F00E  F6 C1 3F					test    cl, 3fh
 F011  74 18					jz      short DiskReadend   ; bad sector 0
 F013  60					pusha
 F014  B4 00					mov     ah, 0
 F016  50					push    ax
 F017  E8 0012					call    HCStoLBA
 F01A  59					pop     cx
 F01B  51					push    cx        
 F01C  FF D5					call    bp              ; DX:AX sector, ES:BX buffer, CX=sectors, returns AX=read sectors
 F01E  59					pop     cx
 F01F  2B C8					sub     cx, ax
 F021  F7 D9					neg     cx              ; CF=1 if cx != 0
 F023  C0 D4 03					rcl     ah, 3           ; AH = 4*CF (sector not found / read error)
 F026  8E D8					mov     ds, ax
 F028  61					popa
 F029  8C D8					mov     ax, ds
 F02B				DiskReadend:
 F02B  C3					ret

 F02C				HCStoLBA:       ; CX = {cyl[7:0], cyl[9:8], sect[5:0]}, DH = head. Returns DX:AX LBA
 F02C  8A C5					mov     al, ch
 F02E  8A E1					mov     ah, cl
 F030  C0 EC 06					shr     ah, 6
 F033  C1 EA 08					shr     dx, 8
 F036  6B D2 3F					imul    dx, 63
 F039  83 E1 3F					and     cx, 3fh
 F03C  03 CA					add     cx, dx
 F03E  49					dec     cx
 F03F  BA 3EC1					mov     dx, 255*63
 F042  F7 E2					mul     dx
 F044  03 C1					add     ax, cx
 F046  83 D2 00					adc     dx, 0
 F049  C3					ret       
				;    unsigned int s = cs & 0x3f;
				;    unsigned int c = ((cs & 0xc0) << 2) | (cs >> 8);
				;    return (c*255l + h)*63l + s - 1l;

 F04A				DiskFormat:
 F04A				DiskInit:
 F04A				DiskSeek:
 F04A				DiskRst:
 F04A				DiskReady:
 F04A				DiskRecalibrate:
 F04A				DiskDiag:
 F04A				DiskExtSeek:
 F04A  83 3E 0094 00				cmp     word ptr HDSize, 0
 F04F  74 05					je      short notready
 F051  80 FA 80					cmp     dl, 80h
 F054  74 98					je      short DiskReset
 F056				notready:        
 F056  B4 AA					mov     ah, 0aah        ; disk not ready
 F058  C3					ret

 F059				DiskGetParams:
 F059  80 FA 80					cmp     dl, 80h
 F05C  B4 07					mov     ah, 7
 F05E  75 CB					jne     short DiskReadend   ; ret
 F060  B3 00					mov     bl, 0   ; ???
 F062  A1 0094					mov     ax, HDSize
 F065  8B D0					mov     dx, ax
 F067  C1 E0 0A					shl     ax, 10
 F06A  C1 EA 06					shr     dx, 6
 F06D  83 E8 1E					sub     ax, 30
 F070  83 DA 00					sbb     dx, 0
 F073  B9 3EC1					mov     cx, 63*255
 F076  F7 F1					div     cx
 F078  48					dec     ax
 F079  3D 03FE					cmp     ax, 3feh
 F07C  76 03					jbe     dgpok
 F07E  B8 03FE					mov     ax, 3feh
 F081				dgpok:        
 F081  86 C4					xchg    al, ah
 F083  C0 E0 06					shl     al, 6
 F086  0C 3F					or      al, 3fh
 F088  8B C8					mov     cx, ax
 F08A  BA FE01					mov     dx, 0fe01h
 F08D  33 C0					xor     ax, ax
 F08F  C3					ret        

 F090				DiskExtVerify:
 F090  BD F7D7 R				mov     bp, sdverify
 F093  EB 08					jmp     short DiskExtRead1
 F095				DiskExtWrite:
 F095  BD F857 R				mov     bp, sdwrite
 F098  EB 03					jmp     short DiskExtRead1
 F09A				DiskExtRead:
 F09A  BD F7DC R				mov     bp, sdread
 F09D				DiskExtRead1:
 F09D  80 FA 80					cmp     dl, 80h
 F0A0  75 B4					jne     short notready
 F0A2  06					push    es
 F0A3  50					push    ax
 F0A4  60					pusha
 F0A5  8B DC					mov     bx, sp
 F0A7  36: 8E 5F 1A				mov     ds, ss:[bx+26]
 F0AB  8B 4C 02					mov     cx, [si+2]
 F0AE  C4 5C 04					les     bx, [si+4]
 F0B1  8B 44 08					mov     ax, [si+8]
 F0B4  8B 54 0A					mov     dx, [si+10]
 F0B7  1E					push    ds
 F0B8  56					push    si
 F0B9  FF D5					call    bp
 F0BB  5E					pop     si
 F0BC  1F					pop     ds
 F0BD  2B 44 02					sub     ax, [si+2]
 F0C0  01 44 02					add     [si+2], ax
 F0C3  61					popa
 F0C4  58					pop     ax
 F0C5  1A E4					sbb     ah, ah
 F0C7  80 E4 04					and     ah, 4
 F0CA  07					pop     es
 F0CB  C3					ret

 F0CC				DiskExtGetParams:
 F0CC  80 FA 80					cmp     dl, 80h
 F0CF  75 85					jne     short notready
 F0D1  50					push    ax
 F0D2  A1 0094					mov     ax, HDSize   
 F0D5  8B EC					mov     bp, sp
 F0D7  8E 5E 08					mov     ds, [bp+8]
 F0DA  33 ED					xor     bp, bp
 F0DC  C7 04 001A				mov     word ptr [si], 1ah      ; size
 F0E0  C7 44 02 000B				mov     word ptr [si+2], 0bh    ; flags
 F0E5  C7 44 04 03FF				mov     word ptr [si+4], 1023   ; cylinders
 F0EA  89 6C 06					mov     word ptr [si+6], bp
 F0ED  C7 44 08 00FF				mov     word ptr [si+8], 255    ; heads
 F0F2  89 6C 0A					mov     word ptr [si+10], bp
 F0F5  C7 44 0C 003F				mov     word ptr [si+12], 63     ; sectors/track
 F0FA  89 6C 0E					mov     word ptr [si+14], bp
 F0FD  89 44 10					mov     word ptr [si+16], ax
 F100  C1 64 10 0A				shl     word ptr [si+16], 10
 F104  C1 E8 06					shr     ax, 6
 F107  89 44 12					mov     word ptr [si+18], ax
 F10A  89 6C 14					mov     word ptr [si+20], bp
 F10D  89 6C 16					mov     word ptr [si+22], bp
 F110  C7 44 18 0200				mov     word ptr [si+24], 512   ; bytes/sector
 F115  58					pop     ax
 F116  B4 00					mov     ah, 0
 F118  C3					ret 

 F119				DiskReadSectBuffer:
 F119				DiskWriteSectBuffer:
 F119				DiskSetDASDType:
 F119				DiskSetMediaType:
 F119				DiskExtLock:
 F119				DiskExtEject:
 F119  B4 01					mov     ah, 1       ; unsupported fn
 F11B  C3					ret

 F11C				int13   endp


				OFFDX MACRO n
					IF n LE -3 OR n GE 3
						add		dx, n
					ENDIF
					IF n EQ -2
						dec		dx
					ENDIF 
					IF n EQ -1 or n EQ -2
						dec		dx
					ENDIF
					IF n EQ 1 or n EQ 2
						inc		dx
					ENDIF 
					IF n eq 2
						inc		dx
					ENDIF
				ENDM
				; --------------------- INT 14h - Serial port I/O ----------------
 = 0000				ComPort		equ		0
 = 0000				THR			equ		0	; Transmit holding buffer
 = 0000				RBR			equ		0	; Receive buffer
 = 0000				DLL			equ		0	; divisor latch low byte (DLAB = 1)
 = 0001				DLH			equ		1	; divisor latch high byte	(DLAB = 1)
 = 0001				IER			equ		1	; Interrupt enable register
 = 0003				LCR			equ		3	; line control register (DLAB, BrkEnable, PPP, S, LL)
 = 0005				LSR			equ		5	; line status register
 = 0006				MSR			equ		6	; Modem status register

				; AH=function number, AL=char sent or received, DX=zero based COM index. Preserve all registers except AX
 F11C				int14 proc near
 F11C  1E					push	ds
 F11D  52					push	dx
 F11E  56					push	si
 F11F  6A 40					push	40h
 F121  1F					pop		ds
 F122  8B F2					mov		si, dx
 F124  03 F6					add		si, si
 F126  8B 14					mov		dx, ComPort[si]
						OFFDX	LCR
 F128  83 C2 03		     1			add		dx, LCR
 F12B  8B F0					mov		si, ax
 F12D  EC					in		al, dx
 F12E  24 7F					and		al, 7fh		; clear DLAB bit
 F130  EE					out		dx, al
						OFFDX	LSR-LCR
 F131  42		     1			inc		dx
 F132  42		     1			inc		dx
 F133  8B C6					mov		ax, si
 F135  C1 EE 08					shr		si, 8
 F138  74 0D					jz		short SetCharFormat
 F13A  4E					dec		si
 F13B  74 43					jz		short STransmit
 F13D  4E					dec		si
 F13E  74 51					jz		short SReceive
 F140  4E					dec		si
 F141  74 33					jz		short GetPortStatus
				;		dec		si
				;		jz		short SetCharFormatExt
 F143				SExit:
 F143  5E					pop		si
 F144  5A					pop		dx
 F145  1F					pop		ds
 F146  CF					iret

				; ----- Set COM char format --------
				; AL = BBBPPSLL (BB=000..111 for baud 110,150,300,600,1200,2400,4800,9600)
				; returns LSR in AH and MSR in AL
 F147				SetCharFormat:		; DX = LSR
 F147  52					push	dx
 F148  51					push	cx
 F149  8A C8					mov		cl, al
 F14B  8A E8					mov		ch, al
						OFFDX	LCR-LSR
 F14D  4A		     1			dec		dx
 F14E  4A		     1			dec		dx
 F14F  EC					in		al, dx
 F150  0C 80					or		al, 80h		; set DLAB=1
 F152  EE					out		dx, al
 F153  C0 E9 05					shr		cl, 5
 F156  B8 0417					mov		ax, 417h
 F159  74 05					jz		short Baud110
 F15B  B8 0300					mov		ax, 300h
 F15E  D3 E8					shr		ax, cl
 F160				Baud110:
						OFFDX	DLL-LCR
 F160  83 C2 FD		     1			add		dx, DLL-LCR
 F163  EE					out		dx, al		; set baud low
						OFFDX	DLH-DLL
 F164  42		     1			inc		dx
 F165  8A C4					mov		al, ah
 F167  EE					out		dx, al		; set baud high
						OFFDX	LCR-DLH
 F168  42		     1			inc		dx
 F169  42		     1			inc		dx
 F16A  8A C5					mov		al, ch
 F16C  24 1F					and		al, 1fh
 F16E  EE					out		dx, al		; set format, DLAB=0

						OFFDX	IER-LCR
 F16F  4A		     1			dec		dx
 F170  4A		     1			dec		dx
 F171  32 C0					xor		al, al
 F173  EE					out		dx, al		; disable all interrupts
 F174  59					pop		cx
 F175  5A					pop		dx

				; ----- get COM port status --------
 F176				GetPortStatus:			; DX = LSR
						OFFDX	MSR-LSR
 F176  42		     1			inc		dx
 F177  EC					in		al, dx		; read modem status
						OFFDX	LSR-MSR
 F178  4A		     1			dec		dx
 F179				GetPortStatus1:
 F179  8A E0					mov		ah, al
 F17B  EC					in		al, dx		; read line (port) status
 F17C  86 E0					xchg	ah, al
 F17E  EB C3					jmp		short SExit
						
				; ----- Transmit char to COM port --------
				; Waits for THRE(bit5 in LSR) and then sends AL. returns LSR in AH
 F180				STransmit:			; DX = LSR
 F180  52					push	dx
 F181  8A E0					mov		ah, al
 F183				STr1:
 F183  EC					in		al, dx
 F184  A8 20					test	al, 20h
 F186  74 FB					jz		short STr1
						OFFDX	THR-LSR
 F188  83 C2 FB		     1			add		dx, THR-LSR
 F18B  8A C4					mov		al, ah
 F18D  EE					out		dx, al
 F18E				STr2:
 F18E  5A					pop		dx
 F18F  EB E8					jmp		short GetPortStatus1

				; ----- receive char from COM port --------
				; Waits for RDA(bit0 in  LSR) and returns the received char in AL, and the LSR in AH
 F191				SReceive:			; DX = LSR
 F191  52					push	dx
 F192				SReceive1:
 F192  EC					in		al, dx
 F193  A8 01					test	al, 1
 F195  74 FB					jz		short SReceive1
						OFFDX	RBR-LSR
 F197  83 C2 FB		     1			add		dx, RBR-LSR
 F19A  EC					in		al, dx
 F19B  EB F1					jmp		short Str2


				; ----- Set COM char format extended --------
				;SetCharFormatExt:
 F19D				int14 endp

				; --------------------- INT 15h - Extended services ----------------
 = ds:[98h]			UFPtr           equ     <ds:[98h]>
 = ds:[9ch]			WaitCount       equ     <ds:[9ch]>
 = ds:[0a0h]			UWaitFlag       equ     <ds:[0a0h]>
 = ds:[0a1h]			HandlerPtr      equ     <ds:[0a1h]> ; 4 bytes
 = ds:[0a5h]			DataBuffer      equ     <ds:[0a5h]> ; 3 bytes
 = ds:[067h]			DataCounter     equ     <ds:[067h]> ; 1 byte
 = ds:[068h]			PacketSize      equ     <ds:[068h]> ; 1 byte, 0->3bytes, 1->4bytes
 = 7B60				FreeXMSKb       equ     RAMSize*64 - 640 - 512 - 32	;total - DOS - VGA - BIOS

				; ------------ MovExt
 F19D				IncSeg: ; DX = segment port address
 F19D  75 25					jnz     short SetSegExit
 F19F  ED					in      ax, dx
 F1A0  25 01FF					and     ax, RAMSize - 1
 F1A3  40					inc     ax
 F1A4  83 F8 12					cmp     ax, 12h
 F1A7  75 02					jne     short IncSeg1
 F1A9  33 C0					xor     ax, ax
 F1AB				IncSeg1:
 F1AB  83 F8 0C					cmp     ax, 0ch
 F1AE  75 0B					jne     short SetSeg2
 F1B0				SetSeg: ; DX = segment port address, ax = logical segment (0..RAMSize-1)    
 F1B0  25 01FF					and     ax, RAMSize - 1
 F1B3  83 F8 0C					cmp     ax, 0ch
 F1B6  72 0B					jb      short SetSeg1
 F1B8  83 C0 06					add     ax, 6
 F1BB				SetSeg2:        
 F1BB  3D 0200					cmp     ax, RAMSize
 F1BE  72 03					jb      short SetSeg1
 F1C0  2D 01F4					sub     ax, RAMSize - 0ch
 F1C3				SetSeg1:
 F1C3  EF					out     dx, ax          
 F1C4				SetSegExit:              
 F1C4  C3					ret

 = 0001				MovSeg  equ     01h
 F1C5 0000			savess  dw      0
 F1C7 F1CB R 0000		savesp  dw      MovExt, 0 ; tmp stack
				; Log(idx) to Phy(val) segment map (RAMSize segs): 0,1,2,3,4,5,6,7,8,9,a,b,12h,13h,...,RAMSize-2,RAMSize-1,c,d,e,f,10h,11h, then wrap to 0,1,2,...
 F1CB				MovExt:
 F1CB  06					push    es
 F1CC  1E					push    ds
 F1CD  60					pusha
 F1CE  FA					cli
 F1CF  2E: 8C 16 F1C5 R				mov     cs:savess, ss
 F1D4  0E					push    cs
 F1D5  17					pop     ss
 F1D6  2E: 87 26 F1C7 R				xchg    sp, cs:savesp
 F1DB  BA 0082					mov     dx, 80h + MovSeg + 1
 F1DE  E3 72					jcxz    short MovExt_exit
 F1E0  06					push    es
 F1E1  1F					pop     ds
 F1E2  FC					cld
 F1E3  8A 44 1C					mov     al, [si+1ch]
 F1E6  8A 64 1F					mov     ah, [si+1fh]
 F1E9  8A 5C 14					mov     bl, [si+14h]
 F1EC  8A 7C 17					mov     bh, [si+17h]
 F1EF  8B 7C 1A					mov     di, [si+1ah]
 F1F2  8B 74 12					mov     si, [si+12h]
 F1F5  E8 04EF					call    flush   
 F1F8  E8 FFB5					call    SetSeg      ; 02000h = destination, DX=82h
 F1FB  4A					dec     dx
 F1FC  93					xchg    ax, bx
 F1FD  E8 FFB0					call    SetSeg      ; 01000h = source, DX=81h
 F200  68 1000					push    MovSeg shl 12 
 F203  1F					pop     ds
 F204  68 2000					push    (MovSeg + 1) shl 12
 F207  07					pop     es
 F208  33 DB					xor     bx, bx
 F20A  03 C9					add     cx, cx
 F20C  13 DB					adc     bx, bx      ; BX:CX = bytes to transfer
				; move from 01000h:si to 02000h:di, 2*cx bytes
 F20E				MovExtLoop:
 F20E  42					inc     dx          ; 82h
 F20F  8B C6					mov     ax, si
 F211  3B C7					cmp     ax, di
 F213  77 02					ja      short MovExt1
 F215  8B C7					mov     ax, di
 F217				MovExt1:
 F217  F7 D8					neg     ax
 F219  83 D3 FF					adc     bx, -1
 F21C  2B C8					sub     cx, ax
 F21E  83 DB 00					sbb     bx, 0
 F221  91					xchg    ax, cx      ; cx = bytes to move, bx:ax = bytes left for the next transfer
 F222  79 05					jns     short MovExt2   ; ax <= bx:cx     
 F224  03 C8					add     cx, ax
 F226  33 C0					xor     ax, ax
 F228  43					inc     bx
 F229				MovExt2:
 F229  A4					movsb               ; if CX = 0 transfer 10000h bytes
 F22A  49					dec     cx
 F22B  74 0F					jz      short MovExt_next
 F22D  F7 C6 0001				test    si, 1       ; read align
 F231  74 02					jz      short raligned
 F233  A4					movsb
 F234  49					dec     cx
 F235				raligned:
 F235  D1 E9					shr     cx, 1
 F237  F3/ A5					rep     movsw
 F239  73 01					jnc     short MovExt_next
 F23B  A4					movsb
 F23C				MovExt_next:
 F23C  E8 04A8					call    flush
 F23F  8B C8					mov     cx, ax
 F241  0B C3					or      ax, bx
 F243  74 0D					jz      short MovExt_exit  ; finalized
 F245  85 FF					test    di, di
 F247  E8 FF53					call    incseg      ; does nothing if ZF == 0, dx = 8bh
 F24A  4A					dec     dx          ; 81h
 F24B  85 F6					test    si, si      
 F24D  E8 FF4D					call    incseg      ; dx = 81h
 F250  EB BC					jmp     short MovExtLoop
 F252				MovExt_exit:
 F252  B8 0002					mov     ax, MovSeg + 1
 F255  EF					out     dx, ax      ; 82h
 F256  48					dec     ax
 F257  4A					dec     dx
 F258  EF					out     dx, ax      ; 81h
 F259  2E: 8E 16 F1C5 R				mov     ss, cs:savess
 F25E  2E: 87 26 F1C7 R				xchg    sp, cs:savesp
 F263  61					popa
 F264  1F					pop     ds
 F265  07					pop     es
 F266  32 E4					xor     ah, ah
 F268  EB 38					jmp     short exit_ax
 F26A				MovExtProxy:
 F26A  E9 FF5E					jmp     MovExt        

 F26D				int15:
 F26D  80 FC 4F					cmp     ah, 4fh
 F270  74 34					je      short exit_iret
 F272  86 C4					xchg    al, ah
 F274  3C 80					cmp     al, 80h
 F276  72 27					jb      short exit15; CF=1  for <80h
 F278  3C 83					cmp     al, 83h
 F27A  72 22					jb      short done  ; no error for 80, 81, 82
 F27C  74 29					je      short SetEventWait; 83
 F27E  3C 86					cmp     al, 86h
 F280  72 1D					jb      short exit15; CF=1 for 84, 85
 F282  74 58					je      short Wait1 ; 86
 F284  3C 88					cmp     al, 88h
 F286  72 E2					jb      short MovExtProxy ; 87
 F288  74 6B					je      short ExtSize     ; 88
 F28A  3C 90					cmp     al, 90h
 F28C  72 11					jb      short  exit15; CF=1 for 89..8f
 F28E  3C 92					cmp     al, 92h
 F290  72 0C					jb      short done  ; no error for 90, 91
 F292  3C C0					cmp     al, 0c0h
 F294  72 09					jb      short exit15; CF=1 for 92..bf
 F296  74 62					je      short GetConfig   ; c0
 F298  3C C2					cmp     al, 0c2h
 F29A  72 03					jb      short exit15; CF=1 for c1
 F29C  74 65					je      short Mouse ; c2
 F29E				done:
 F29E  F5					cmc                 ; CF=1 for >c2
 F29F				exit15:
 F29F  B8 8600					mov     ax, 8600h
 F2A2				exit_ax:        
 F2A2  FB					sti
 F2A3  CA 0002					retf    2           ; discard flags (need to keep CF)
 F2A6				exit_iret:
 F2A6  CF					iret        

				; ------------ SetEventWait
 F2A7				SetEventWait:
 F2A7  1E					push    ds
 F2A8  6A 40					push    40h
 F2AA  1F					pop     ds
 F2AB  80 F4 01					xor     ah, 1
 F2AE  74 21					jz      short cancel
 F2B0  84 26 00A0				test    ah, byte ptr UWaitFlag ; ah=1
 F2B4  75 22					jnz     short busy  ; CF=0
 F2B6  B8 03E7					mov     ax, 1000-1  ; 1ms
 F2B9  E7 70					out     70h, ax     ; restart RTC timer
 F2BB  89 1E 0098				mov     UFPtr[0], bx
 F2BF  8C 06 009A				mov     UFPtr[2], es
 F2C3  03 C2					add     ax, dx
 F2C5  83 D1 00					adc     cx, 0
 F2C8  A3 009C					mov     WaitCount[0], ax
 F2CB  89 0E 009E				mov     WaitCount[2], cx
 F2CF  B4 01					mov     ah, 1       ; wait in progress
 F2D1				cancel:
 F2D1  88 26 00A0				mov     byte ptr UWaitFlag, ah   
 F2D5  CD 70					int     70h
 F2D7  F9					stc                 ; no error
 F2D8				busy:   
 F2D8  F5					cmc                 ; eror        
 F2D9				nowait:
 F2D9  1F					pop     ds
 F2DA  EB C3					jmp     short exit15

				; ------------ Wait
 F2DC				Wait1:
 F2DC  06					push    es
 F2DD  53					push    bx
 F2DE  B8 8300					mov     ax, 8300h
 F2E1  6A 4A					push    4ah
 F2E3  07					pop     es
 F2E4  33 DB					xor     bx, bx      ; user wait flag address=0040:00a0
 F2E6  CD 15					int     15h         ; returns with IF = 1
 F2E8  72 07					jc      short wbusy
 F2EA				wloop:        
 F2EA  F4					hlt   
 F2EB  26: F6 07 80				test    byte ptr es:[bx], 80h
 F2EF  74 F9					jz      short wloop
 F2F1				wbusy:        
 F2F1  5B					pop     bx
 F2F2  07					pop     es
 F2F3  EB AA					jmp     short exit15
						

				; ------------ ExtSize
 F2F5				ExtSize:
 F2F5  B8 7B60					mov     ax, FreeXMSKb
 F2F8  EB A8					jmp     short exit_ax
						
				; ------------ GetConfig
 F2FA				GetConfig:
 F2FA  33 C0					xor     ax, ax
 F2FC  0E					push    cs
 F2FD  07					pop     es
 F2FE  BB F41D R				mov     bx, offset SysParams
 F301  EB 9F					jmp     short exit_ax
						
				; ------------ Mouse 
 F303				Mouse:
 F303  1E					push    ds
 F304  52					push    dx
 F305  6A 40					push    40h
 F307  1F					pop     ds
 F308  F6 06 0010 04				test    byte ptr EquipmentWord, 4 ; ps2 mouse equipement word
 F30D  75 15					jnz     short mouse_present
 F30F				if_err:
 F30F  B8 03A7					mov     ax, 03a7h   ; interface error (no mouse present)
 F312  E6 64					out     64h, al     ; disable mouse
 F314				errexit:        
 F314  F9					stc                 ; error
 F315				exitok:        
 F315  9C					pushf               ; save CF
 F316  50					push    ax
 F317  E8 00D6					call    enablemouseinterrupt
 F31A  58					pop     ax

 F31B  E8 03BC					call    enableKbIfPresent
 F31E  9D					popf
 F31F  5A					pop     dx
 F320  1F					pop     ds
 F321  E9 FF7E					jmp     exit_ax
 F324				mouse_present:
 F324  8A C4					mov     al, ah                                  
 F326  B4 01					mov     ah, 1       ; invalid function
 F328  3C 07					cmp     al, 7
 F32A  77 E8					ja      short errexit
 F32C  50					push    ax

 F32D  E8 00D3					call    disablemouseinterrupt

 F330  FB					sti                 ; allow interrupts for a short time, to flush possible pending KB/mouse requests
 F331  B0 AD					mov     al, 0adh
 F333  E6 64					out     64h, al     ; disable kb interface
 F335  58					pop     ax
 F336  3C 01					cmp     al, 1
 F338  FA					cli                 ; from now on we are working with ints disabled, as the following code is highly non re-entrant
 F339  72 1C					jb      short en_dis
 F33B  74 33					je      short reset
 F33D  3C 03					cmp     al, 3
 F33F  72 40					jb      short sampling
 F341  74 5D					je      short resolution
 F343  3C 05					cmp     al, 5
 F345  72 63					jb      short gettype
 F347  74 27					je      short reset
 F349  3C 06					cmp     al, 6
 F34B  74 75					je      short extend

				; ------------- set handler
 F34D  89 1E 00A1				mov     HandlerPtr[0], bx
 F351  8C 06 00A3				mov     HandlerPtr[2], es
 F355  EB 15					jmp     short exit_success1        

				; ------------- enable/disable
 F357				en_dis:
 F357  B8 02F5					mov     ax, 02f5h   ; ah = invalid input
 F35A  2A C7					sub     al, bh
 F35C  38 E7					cmp     bh, ah
 F35E  73 B4					jnc     short errexit
 F360  8A E0					mov     ah, al
 F362  E8 0364					call    sendcmd     ; enable/disable data reporting (CF = 1)
 F365				if_err1:        
 F365  72 A8					jc      short if_err
 F367				exit_success:
 F367  C6 06 0067 00				mov     byte ptr DataCounter, 0
 F36C				exit_success1:
 F36C  32 E4					xor     ah, ah      ; success
 F36E  EB A5					jmp     short exitok

				; ------------- reset
 F370				reset:
 F370  B4 F6					mov     ah, 0f6h    ; set defaults
 F372  F9					stc                 ; mouse command
 F373  E8 0353					call    sendcmd     
 F376  72 97					jc      short if_err
 F378  BB 00AA					mov     bx, 00aah
 F37B  88 3E 0068				mov     byte ptr PacketSize, bh ; 3bytes packet
 F37F  EB E6					jmp     short exit_success

				; ------------- sampling
 F381				sampling:
 F381  80 FF 06					cmp     bh, 6
 F384				badparam:
 F384  B4 02					mov     ah, 2       ; invalid input
 F386  77 8C					ja      short errexit
 F388  C1 EB 08					shr     bx, 8
 F38B  2E: 8A A7 F416 R				mov     ah, cs:sample_tbl[bx]
 F390  50					push    ax
 F391  B4 F3					mov     ah, 0f3h    ; st sample rate
 F393				send2c:
 F393  F9					stc
 F394  E8 0332					call    sendcmd              
 F397  58					pop     ax
 F398  72 CB					jc      short if_err1
 F39A				send1c:
 F39A  F9					stc
 F39B  E8 032B					call    sendcmd
 F39E  EB C5					jmp     short if_err1

				; ------------- resolution
 F3A0				resolution:
 F3A0  80 FF 03					cmp     bh, 3
 F3A3  77 DF					ja      short badparam
 F3A5  53					push    bx
 F3A6  B4 E8					mov     ah, 0e8h    ; set resolution
 F3A8  EB E9					jmp     short send2c

				; ------------- gettype
 F3AA				gettype:
 F3AA  B4 F2					mov     ah, 0f2h
 F3AC  F9					stc
 F3AD  E8 0319					call    sendcmd
 F3B0  72 B3					jc      short if_err1
 F3B2  E8 02FA					call    getps2byte
 F3B5  72 AE					jc      short if_err1
 F3B7  8A F8					mov     bh, al
 F3B9  F6 D8					neg     al          ; CF=1 if al != 0
 F3BB  12 C7					adc     al, bh
 F3BD  A2 0068					mov     byte ptr PacketSize, al ; 3 or 4 bytes packet
 F3C0  EB A5					jmp     short exit_success
						
				; ------------- extended commands
 F3C2				extend:
 F3C2  84 FF					test    bh, bh
 F3C4  75 1F					jnz     short setscaling
 F3C6  B4 E9					mov     ah, 0e9h    ; status request
 F3C8  F9					stc
 F3C9  E8 02FD					call    sendcmd
 F3CC  72 97					jc      short if_err1
 F3CE  E8 02DE					call    getps2byte
 F3D1  72 92					jc      short if_err1
 F3D3  8A D8					mov     bl, al
 F3D5  E8 02D7					call    getps2byte
 F3D8  72 8B					jc      short if_err1
 F3DA  8A C8					mov     cl, al
 F3DC  E8 02D0					call    getps2byte
 F3DF  72 84					jc      short if_err1
 F3E1  5A					pop     dx  
 F3E2  50					push    ax          ; replace dx on stack
 F3E3  EB 82					jmp     short exit_success
 F3E5				setscaling:    
 F3E5  80 FF 02					cmp     bh, 2
 F3E8  77 9A					ja      short badparam
 F3EA  B4 E5					mov     ah, 0e5h    ; set scaling 1:1 or 2:1
 F3EC  02 E7					add     ah, bh
 F3EE  EB AA					jmp     short send1c

 F3F0				enablemouseinterrupt:
 F3F0  B0 20					mov     al, 20h
 F3F2  E6 64					out     064h, al
 F3F4  E4 60					in      al, 060h    ; read 8042 config byte
 F3F6  0C 02					or      al, 02h     ; set enable mouse interrupt
 F3F8  8A E0					mov     ah, al
 F3FA  B0 60					mov     al, 60h
 F3FC  E6 64					out     064h, al
 F3FE  8A C4					mov     al, ah
 F400  E6 60					out     060h, al    ; send 8042 config byte
 F402  C3					ret
 F403				disablemouseinterrupt:
 F403  B0 20					mov     al, 20h
 F405  E6 64					out     064h, al
 F407  E4 60					in      al, 060h    ; read 8042 config byte
 F409  24 FD					and     al, 0fdh     ; set disable mouse interrupt
 F40B  8A E0					mov     ah, al
 F40D  B0 60					mov     al, 60h
 F40F  E6 64					out     064h, al
 F411  8A C4					mov     al, ah
 F413  E6 60					out     060h, al    ; send 8042 config byte
 F415  C3					ret

 F416 0A 14 28 3C 50 64		sample_tbl  db  10, 20, 40, 60, 80, 100, 200
       C8
 F41D 08 00 FC 00 00		SysParams   db  8, 0, 0fch, 0, 0
				;--------------------------------------------------------------------------
				; Feature byte 1
				; b7: 1=DMA channel 3 used by hard disk
				; b6: 1=2 interrupt controllers present
				; b5: 1=RTC present
				; b4: 1=BIOS calls int 15h/4Fh every key
				; b3: 1=wait for extern event supported (Int 15h/41h)
				; b2: 1=extended BIOS data area used
				; b1: 0=AT or ESDI bus, 1=MicroChannel
				; b0: 1=Dual bus (MicroChannel + ISA)
				;--------------------------------------------------------------------------
 F422  10						db      10h
				;--------------------------------------------------------------------------
				; Feature byte 2
				; b7: 1=32-bit DMA supported
				; b6: 1=int16h, function 9 supported
				; b5: 1=int15h/C6h (get POS data) supported
				; b4: 1=int15h/C7h (get mem map info) supported
				; b3: 1=int15h/C8h (en/dis CPU) supported
				; b2: 1=non-8042 kb controller
				; b1: 1=data streaming supported
				; b0: reserved
				;--------------------------------------------------------------------------
 F423  44						db      44h
				;--------------------------------------------------------------------------
				; Feature byte 3
				; b7: not used
				; b6: reserved
				; b5: reserved
				; b4: POST supports ROM-to-RAM enable/disable
				; b3: SCSI on system board
				; b2: info panel installed
				; b1: Initial Machine Load (IML) system - BIOS on disk
				; b0: SCSI supported in IML
				;--------------------------------------------------------------------------
 F424  00						db      0
				;--------------------------------------------------------------------------
				; Feature byte 4
				; b7: IBM private
				; b6: EEPROM present
				; b5-3: ABIOS presence (011 = not supported)
				; b2: private
				; b1: memory split above 16Mb supported
				; b0: POSTEXT directly supported by POST
				;--------------------------------------------------------------------------
 F425  00						db      0
				;--------------------------------------------------------------------------
				; Feature byte 5 (IBM)
				; b1: enhanced mouse
				; b0: flash EPROM
				;--------------------------------------------------------------------------
 F426  00						db      0                                                


				; --------------------- INT 16h - keyboard interface ----------------
				;       AH      Description
				;       --      ------------------------------------------------
				;       00h     Get a key from the keyboard, return code in AX.
				;       01h     Test for available key, ZF=1 if none, ZF=0 and
				;               AX contains next key code if key available.
				;       02h     Get shift status. Returns shift key status in AL.
				;       03h     Set Autorepeat rate. BH=0,1,2,3 (delay time in quarter seconds), BL=0..1Fh for 30 char/sec to 2 char/sec repeat rate.
				;       05h     Store scan code (in CX) in the type ahead buffer.
				;       10h     Get a key (same as 00h in this implementation).
				;       11h     Test for key (same as 01h).
				;       12h     Get extended key status. Returns status in AX.

 = ds:[19h]			AltKpd          equ     <ds:[19h]>
 = ds:[1ah]			HeadPtr         equ     <ds:[1ah]>
 = ds:[1ch]			TailPtr         equ     <ds:[1ch]>
 = ds:[80h]			Buffer          equ     <ds:[80h]>;1eh
 = ds:[82h]			EndBuf          equ     <ds:[82h]>;3eh

 F427				int16 proc near
 F427  1E					push    ds
 F428  56					push    si
 F429  6A 40					push    40h
 F42B  1F					pop     ds
 F42C  86 C4					xchg    al, ah          ;shorter opcodes for al than ah
 F42E  48					dec     ax
 F42F  A8 EF					test    al, 0EFh        ;Check for 01h and 11h
 F431  74 3E					jz      short TestKey   ;TestKey does not need cld
 F433  40					inc     ax
 F434  FC					cld
 F435  A8 EF					test    al, 0EFh        ;Check for 0h and 10h
 F437  74 1C					jz      short GetKey
 F439  3C 03					cmp     al, 3           ;Check for 02h and 03h
 F43B  72 78					jb      short GetStatus
 F43D  74 7B					je      short SetAutoRpt   
 F43F  3C 05					cmp     al, 5           ;Check for StoreKey function.
 F441  74 3D					je      short StoreKey
 F443  3C 09					cmp     al, 9           ;Get KB functionality
 F445  74 08					je      short kbfunc     
 F447  3C 12					cmp     al, 12h         ;Extended status call
 F449  74 56					je      short ExtStatus
 F44B  3C 92					cmp     al, 92h         ;stupid keyb.com 
 F44D  75 02					jne     short Exit
 F44F				kbfunc:
 F44F  B0 24					mov     al, 24h         ;AL=20h (fn 10h, 12h supported, set typematic supported)        
 F451				Exit:        
 F451  5E					pop     si
 F452  1F					pop     ds
 F453  CF					iret                    ; unknown function, Restores flags.

 F454				GetKey1:                        ; wait for interrupt
 F454  F4					hlt
 F455				GetKey: ; ----------- fn 00h, 10h
 F455  B4 11					mov     ah, 11h
 F457  CD 16					int     16h             ;See if key is available (IF becomes 1 after this int)
 F459  74 F9					jz      short GetKey1   ;Wait for keystroke.
 F45B  FA					cli                     ;Critical region! Ints off.
 F45C  8B 36 001A				mov     si, HeadPtr     ;Ptr to next character.
 F460  AD					lodsw                   ;Get the character, Bump up HeadPtr
 F461  3B 36 0082				cmp     si, EndBuf
 F465  72 04					jb      short noWrap
 F467  8B 36 0080				mov     si, Buffer
 F46B				noWrap:             
 F46B  89 36 001A				mov     HeadPtr, si
 F46F  EB E0					jmp     short Exit

 F471				TestKey: ; ---------- fn 01h
 F471  8B 36 001A				mov     si, HeadPtr
 F475  3B 36 001C				cmp     si, TailPtr     ;ZF=1, if empty buffer
 F479  AD					lodsw                   ;BIOS returns avail keycode.
 F47A  FB					sti                     ;Ints back on.
 F47B  5E					pop     si
 F47C  1F					pop     ds
 F47D  CA 0002					retf    2               ;Pop flags (ZF is important!)

 F480				StoreKey: ; ---------- fn 05h - Inserts the value in CX into the type ahead buffer.  
 F480  8B 36 001C				mov     si, TailPtr     ;Address where we can put next key code.
 F484  89 0C					mov     [si], cx        ;Store the key code away
 F486  46					inc     si
 F487  46					inc     si              ;Move on to next entry in buf
 F488  3B 36 0082				cmp     si, EndBuf
 F48C  72 04					jb      short NoWrap1
 F48E  8B 36 0080				mov     si, Buffer
 F492				 NoWrap1:
 F492  B0 01					mov     al, 1           ;no room
 F494  3B 36 001A				cmp     si, HeadPtr     ;Data overrun?
 F498  74 B7					je      short Exit      ;if so, ignore key entry.
 F49A  89 36 001C				mov     TailPtr, si
 F49E  48					dec     ax              ;al=0
 F49F  EB B0					jmp     short Exit       

 F4A1				ExtStatus: ; ------- fn 12h - Retrieve the extended keyboard status and return it in AH, and the standard keyboard status in AL.    
 F4A1  A0 0018					mov     al, KbdFlags2
 F4A4  24 77					and     al, 01110111b   ;Clear final sysreq field, and final right alt bit.
 F4A6  A8 04					test    al, 100b        ;Test cur sysreq bit.
 F4A8  74 02					jz      short NoSysReq  ;Skip if it's zero.
 F4AA  2C 84					sub     al, 10000100b   ;Set final sysreq bit, clear final right ctl bit.
 F4AC				NoSysReq:
 F4AC  8A 26 0096				mov     ah, KbdFlags3
 F4B0  80 E4 0C					and     ah, 1100b       ;Grab rt alt/ctrl bits.
 F4B3  0A E0					or      ah, al          ;Merge into AH.

 F4B5				GetStatus: ; --------- fn 02h     
 F4B5  A0 0017					mov     al, KbdFlags1   ;Just return Std Status.
 F4B8				Exit1:
 F4B8  EB 97					jmp     short Exit

 F4BA				SetAutoRpt: ; ------ fn 03h
 F4BA  80 FC 05					cmp     ah, 5
 F4BD  75 92					jne     short Exit
 F4BF  52					push    dx
 F4C0  C0 E7 05					shl     bh, 5
 F4C3  80 E3 1F					and     bl, 1fh
 F4C6  0A DF					or      bl, bh
 F4C8  80 E3 7F					and     bl, 7fh
 F4CB  B4 00					mov     ah, 0           ; wait LED update progress to finalize
 F4CD  E8 0028					call    WaitFlag        ; leaves with IF=0
 F4D0  72 23					jc      short timeout
 F4D2  80 0E 0097 08				or      byte ptr KbdFlags4, SetRepeat    ; set auto repeat in progress
 F4D7  B4 F3					mov     ah, 0f3h        ; set typematic rate and delay
 F4D9  53					push    bx
 F4DA  32 DB					xor     bl, bl          ; send to kb
 F4DC  E8 01AB					call    sendps2byte
 F4DF  5B					pop     bx
 F4E0  72 0E					jc      short timeout1  ; send timeout
 F4E2  B4 18					mov     ah, SetRepeat or AckReceived ; test if ACK received
 F4E4  E8 0011					call    WaitFlag
 F4E7  72 07					jc      short timeout1
 F4E9  8A E3					mov     ah, bl
 F4EB  32 DB					xor     bl, bl          ; send to kb
 F4ED  E8 019A					call    sendps2byte     ; send data
 F4F0				timeout1:
 F4F0  80 26 0097 F7				and     byte ptr KbdFlags4, not SetRepeat   
 F4F5				timeout:
 F4F5  5A					pop     dx
 F4F6  EB C0					jmp     short Exit1


 F4F8				WaitFlag:   ; ah = desired KbdFlags4 & (AckReceived | LEDUpdate | SetRepeat)
 F4F8  BA 03DA					mov     dx, 3dah
 F4FB  B7 C8					mov     bh, 8*25    ; wait for max 25 * VGA frame time
 F4FD				wf_loop:
 F4FD  FA					cli
 F4FE  A0 0097					mov     al, KbdFlags4
 F501  24 58					and     al, AckReceived or LEDUpdate or SetRepeat
 F503  38 E0					cmp     al, ah
 F505  74 0A					je      short wf_ok ; flag ok, CF=0
 F507  FB					sti
 F508  EC					in      al, dx      ; get vblank
 F509  32 C7					xor     al, bh
 F50B  24 08					and     al, 8h
 F50D  2A F8					sub     bh, al
 F50F  73 EC					jnc     short wf_loop     ; IBF - buffer full, no timeout
 F511				wf_ok:
 F511  C3					ret
 F512				int16 endp

				; --------------------- INT 18h - BIOS Basic ------------------
 F512				int18 proc near
 F512  0E					push    cs
 F513  07					pop     es
 F514  BE F54A R				mov     si, offset booterrmsg
 F517  E8 020B					call    prts
 F51A  E8 01CA					call	flush

				;-------------- RS232 bootstrap
 F51D  B0 B4					mov     al, 0b4h
 F51F  E6 43					out     43h, al
 F521  B8 F000					mov     ax, 0f000h
 F524  E6 42					out     42h, al
 F526  E6 42					out     42h, al      ; 18Hz PIT CH2
 F528  E7 01					out		1, ax		; disable auto flush on vblank (bit0)
 F52A  8E D8					mov		ds,ax
 F52C  8E C0					mov		es,ax

 F52E  BE 0100					mov		si,100h
 F531  E8 012A					call	srecb
 F534  FA					cli
 F535  8A FC					mov		bh,ah
 F537  E8 0124					call	srecb
 F53A  8A DC					mov		bl,ah
 F53C				sloop:	
 F53C  E8 011F					call	srecb
 F53F  88 24					mov		[si],ah
 F541  46					inc		si
 F542  4B					dec		bx
 F543  75 F7					jnz		short sloop
 F545  EA					db		0eah
 F546  0100 F000				dw		100h,0f000h

 F54A 4E 6F 20 62 6F 6F		booterrmsg db   'No boot device available, waiting on RS232 (115200bps, f000:100) ...', 13, 10, 0
       74 20 64 65 76 69
       63 65 20 61 76 61
       69 6C 61 62 6C 65
       2C 20 77 61 69 74
       69 6E 67 20 6F 6E
       20 52 53 32 33 32
       20 28 31 31 35 32
       30 30 62 70 73 2C
       20 66 30 30 30 3A
       31 30 30 29 20 2E
       2E 2E 0D 0A 00
 F591				int18 endp

				; --------------------- INT 19h - OS Bootstrap loader ------------------
 F591				int19 proc near
 F591  B8 0201					mov     ax, 201h
 F594  B9 0001					mov     cx, 1
 F597  BA 0080					mov     dx, 80h
 F59A  6A 00					push    0
 F59C  07					pop     es
 F59D  BB 7C00					mov     bx, 7c00h
 F5A0  CD 13					int     13h
 F5A2  72 05					jc      int19err
 F5A4  EA					db      0eah
 F5A5  7C00 0000				dw      7c00h, 0     ; jmp far 0000h:7c00h
 F5A9				int19err:
 F5A9  CD 18					int     18h
 F5AB				int19 endp


				; --------------------- INT 1ah - Get System Time ------------------
 F5AB				int1a proc near
 F5AB  1E					push    ds
 F5AC  6A 40					push    40h
 F5AE  1F					pop     ds
 F5AF  80 FC 01					cmp     ah, 1
 F5B2  77 12					ja      clockexit
 F5B4  74 16					je      setclock
 F5B6  8B 16 006C				mov     dx, ds:[6ch]    ; read clock
 F5BA  8B 0E 006E				mov     cx, ds:[6eh]
 F5BE  A0 0070					mov     al, ds:[70h]
 F5C1				clockexit1:
 F5C1  C6 06 0070 00				mov     byte ptr ds:[70h], 0
 F5C6				clockexit:
 F5C6  F5					cmc     ; CF = 1 on error
 F5C7  1F					pop     ds
 F5C8  FB					sti
 F5C9  CA 0002					retf    2

 F5CC				setclock:
 F5CC  89 16 006C				mov     ds:[6ch], dx
 F5D0  89 0E 006E				mov     ds:[6eh], cx
 F5D4  F9					stc
 F5D5  EB EA					jmp     short clockexit1    
 F5D7				int1a endp


				; --------------------- INT 70h - RTC ------------------
 F5D7				int70 proc near
 F5D7  1E					push    ds
 F5D8  6A 40					push    40h
 F5DA  1F					pop     ds
 F5DB  F6 06 00A0 01				test    byte ptr UWaitFlag, 1    ; is wait in progress?
 F5E0  74 1B					jz      short exit1
 F5E2  81 2E 009C 03E8				sub     word ptr WaitCount[0], 1000
 F5E8  83 1E 009E 00				sbb     word ptr WaitCount[2], 0
 F5ED  73 14					jnc     short exit
 F5EF  C6 06 00A0 00				mov     byte ptr UWaitFlag, 0
 F5F4  53					push    bx
 F5F5  C5 1E 0098				lds     bx, UFPtr
 F5F9  80 0F 80					or      byte ptr [bx], 80h
 F5FC  5B					pop     bx
 F5FD				exit1:
 F5FD  50					push	ax
 F5FE  33 C0					xor		ax, ax
 F600  E7 70					out		70h, ax	; stop RTC
 F602  58					pop		ax
 F603				exit: 
 F603  50					push    ax
 F604  B0 20					mov     al, 20h
 F606  E6 A0					out     0a0h, al
 F608  B0 20					mov     al, 20h
 F60A  E6 20					out     20h, al
 F60C  58					pop     ax
 F60D  1F					pop     ds
 F60E  CF					iret
 F60F				int70 endp

						
				; --------------------- INT 74h - mouse ------------------
 F60F				int74 proc near
 F60F  FC					cld
 F610  60					pusha
 F611  1E					push    ds
 F612  6A 40					push    40h
 F614  1F					pop     ds
 F615  B4 00					mov     ah, 0
 F617  E4 60					in      al, 60h
 F619  8B D8					mov     bx, ax
 F61B  FE 06 0067				inc     byte ptr DataCounter
 F61F  A0 0067					mov     al, DataCounter
 F622  8B F0					mov     si, ax
 F624  2C 03					sub     al, 3
 F626  77 0C					ja      short docall
 F628  88 9C 00A4				mov     DataBuffer[si-1], bl
 F62C  3A 06 0068				cmp     al, PacketSize
 F630  75 21					jne     short nocall
 F632  B3 00					mov     bl, 0
 F634				docall:
 F634  88 3E 0067				mov     byte ptr DataCounter, bh    ; BH=0
 F638  BE 00A3					mov     si, offset DataBuffer-2
 F63B  AD					lodsw
 F63C  0B 44 FC					or      ax, [si-4]
 F63F  74 12					jz      short nocall
 F641  FB					sti
 F642  06					push    es
 F643  B4 00					mov     ah, 0
 F645  AC					lodsb
 F646  50					push    ax
 F647  AC					lodsb
 F648  50					push    ax
 F649  AC					lodsb
 F64A  50					push    ax
 F64B  53					push    bx
 F64C  FF 5C F9					call    far ptr [si-7]
 F64F  83 C4 08					add     sp, 8
 F652  07					pop     es
 F653				nocall:        
 F653  B0 20					mov     al, 20h
 F655  E6 A0					out     0a0h, al
 F657  B0 20					mov     al, 20h
 F659  E6 20					out     20h, al

 F65B  1F					pop     ds
 F65C  61					popa
 F65D  CF					iret
 F65E				int74 endp


				; ----------------  serial receive byte 115200 bps --------------
 F65E  B4 80			srecb:  mov     ah, 80h
 F660  BA 03DA					mov     dx, 3dah
 F663  B9 FA52					mov     cx, -5aeh ; (half start bit)
 F666  EC			srstb:  in      al, dx
 F667  C0 E8 02					shr     al, 2
 F66A  72 FA					jc      short srstb
 F66C  E4 42					in      al, 42h ; lo counter
 F66E  02 E8					add     ch, al
 F670  E4 42					in      al, 42h ; hi counter, ignore
 F672				l1:
 F672  E8 0008					call    dlybit
 F675  EC					in      al, dx
 F676  C0 E8 02					shr     al, 2
 F679  D0 DC					rcr     ah, 1
 F67B  73 F5					jnc     short l1
 F67D				dlybit:
 F67D  81 E9 0A5B				sub     cx, 0a5bh  ;  (full bit)
 F681				dly1:
 F681  E4 42					in      al, 42h
 F683  38 E8					cmp     al, ch
 F685  E4 42					in      al, 42h
 F687  75 F8					jnz     short dly1
 F689  C3					ret

				; -------------------- KB/Mouse access ----------------
 F68A				sendps2byte proc near   ; ah=data, bl!=0 for mouse, 0 for kb. returns cf=1 if timeout (al = 8)
				; changes BH, AL
 F68A  52					push    dx
 F68B  BA 03DA					mov     dx, 3dah
 F68E  B7 28					mov     bh, 8*5
 F690				sps2b2:
 F690  E4 64					in      al, 64h
 F692  A8 02					test    al, 2
 F694  74 0B					jz      short sps2b1; buffer empty
 F696  EC					in      al, dx      ; get vblank
 F697  32 C7					xor     al, bh
 F699  24 08					and     al, 8h
 F69B  2A F8					sub     bh, al
 F69D  73 F1					jnc     short sps2b2; IBF - buffer full, no timeout
 F69F  EB 0C					jmp     short exit  ; timeout, CF=1
 F6A1				sps2b1:
 F6A1  84 DB					test    bl, bl      ; CF=0
 F6A3  74 04					jz      short sps2_kb
 F6A5  B0 D4					mov     al, 0d4h    ; next mouse
 F6A7  E6 64					out     64h, al
 F6A9				sps2_kb:
 F6A9  8A C4					mov     al, ah
 F6AB  E6 60					out     60h, al     ; send byte
 F6AD				exit:        
 F6AD  5A					pop     dx
 F6AE  C3					ret
 F6AF				sendps2byte endp

 F6AF				getps2byte proc near    ; returns al=data, zf=0 for mouse, 1 for kb, cf=1 if timeout (al=8)
				; changes BH, DX, AL
 F6AF  BA 03DA					mov     dx, 3dah
 F6B2  B7 28					mov     bh, 8*5
 F6B4				gps2b2:
 F6B4  E4 64					in      al, 64h
 F6B6  A8 01					test    al, 1
 F6B8  75 0A					jnz     short gps2b1     ; OBF (buffer full), continue
 F6BA  EC					in      al, dx     ; get vblank
 F6BB  32 C7					xor     al, bh
 F6BD  24 08					and     al, 8
 F6BF  2A F8					sub     bh, al
 F6C1  73 F1					jnc     short gps2b2     ; buffer empty, no timeout
 F6C3  C3					ret                ; timeout, CF=1
 F6C4				gps2b1:
 F6C4  A8 20					test    al, 20h    ; CF=0, ZF <- !MOBF
 F6C6  E4 60					in      al, 60h    ; read byte (if IF=1, this data may be invalid)
 F6C8  C3					ret
 F6C9				getps2byte endp

 F6C9				sendcmd proc near     ; ah = command, CF=1 for mouse, CF=0 for kb. returns CF=1 on error
 F6C9  1A DB					sbb     bl, bl      ; bl <- CF
 F6CB  E8 FFBC					call    sendps2byte 
 F6CE  72 09					jc      short exit
 F6D0				retry:        
 F6D0  E8 FFDC					call    getps2byte
 F6D3  72 04					jc      short exit        
 F6D5  3C FA					cmp     al, 0fah    ; ack (returns CF=1 on error, when al=8)
 F6D7  75 F7					jne     short retry
 F6D9				exit:
 F6D9  C3					ret
 F6DA				sendcmd endp

 F6DA				enableKbIfPresent proc near ; input DS = 40h
				; modify AL, flags
 F6DA  F6 06 0096 10				test    byte ptr KbdFlags3, 10h
 F6DF  74 04					jz      short noenablekb
 F6E1  B0 AE					mov     al, 0aeh
 F6E3  E6 64					out     64h, al     ; enable kb interface
 F6E5				noenablekb:        
 F6E5  C3					ret
 F6E6				enableKbIfPresent endp

				; ----------------------- default interrupt handler ---------------
 F6E6				defint  proc near
 F6E6  CF					iret
 F6E7				defint  endp             

				; ------------------------------- flush --------------------------
 F6E7				flush:
 F6E7  2E: 8F 06 F708 R				pop     cs:flushret
 F6EC				flush_nostack:        
 F6EC  2E: 89 1E F70A R				mov     cs:flushbh, bx
 F6F1  BB 2000					mov     bx, 2000h       ; flush all cache lines
 F6F4				flush1:        
 F6F4  2E: 84 9F BF00				test    bl, cs:[bx + 0bf00h]
 F6F9  83 EB 40					sub		bx, 40h
 F6FC  75 F6					jnz     short flush1
 F6FE  2E: 8B 1E F70A R				mov     bx, cs:flushbh
 F703  2E: FF 26 F708 R				jmp     word ptr cs:flushret
 F708 0000			flushret dw 0
 F70A 0000			flushbh  dw 0          

				; ------------------------------- misc --------------------------
 F70C				dispAX: 
 F70C  52					push    dx
 F70D  33 D2					xor     dx, dx
 F70F  2E: F7 36 F723 R				div     word ptr cs:ten
 F714  85 C0					test    ax, ax
 F716  74 03					jz      dispAX1
 F718  E8 FFF1					call    dispAX
 F71B				dispAX1:
 F71B  92					xchg    ax, dx
 F71C  05 0E30					add     ax, 0e00h + '0'
 F71F  CD 10					int     10h
 F721  5A					pop     dx
 F722  C3					ret        
 F723 000A			ten     dw      10

 F725				prts:   ; es:si = string
 F725  B4 0E					mov     ah, 0eh    
 F727  26: AC					lodsb   es:[si]
 F729  0A C0					or      al, al
 F72B  74 04					jz      short prtse
 F72D  CD 10					int     10h
 F72F  EB F4					jmp     short prts
 F731				prtse:
 F731  C3					ret



				;---------------------  read/write byte ----------------------
 F732  B0 FF			sdrb:   mov al,0ffh
 F734				sdsb:               ; in AL=byte, DX = 03dah, out AX=result
 F734  EE					out     dx, al
 F735  03 C0					add     ax, ax
 F737  EE					out     dx, al
 F738  03 C0					add     ax, ax
 F73A  EE					out     dx, al
 F73B  03 C0					add     ax, ax
 F73D  EE					out     dx, al
 F73E  03 C0					add     ax, ax
 F740  EE					out     dx, al
 F741  03 C0					add     ax, ax
 F743  EE					out     dx, al
 F744  03 C0					add     ax, ax
 F746  EE					out     dx, al
 F747  03 C0					add     ax, ax
 F749  EE					out     dx, al
 F74A  ED					in      ax, dx
 F74B  C3					ret

				;---------------------  write block ----------------------
 F74C				sdwblk proc near              ; in SI=data ptr, DX=03dah, CX=size
 F74C  D1 E9					shr     cx, 1
 F74E				sdwblk1:
 F74E  AC					lodsb
 F74F  EE					out     dx, al
 F750  03 C0					add     ax, ax
 F752  EE					out     dx, al
 F753  03 C0					add     ax, ax
 F755  EE					out     dx, al
 F756  03 C0					add     ax, ax
 F758  EE					out     dx, al
 F759  03 C0					add     ax, ax
 F75B  EE					out     dx, al
 F75C  03 C0					add     ax, ax
 F75E  EE					out     dx, al
 F75F  03 C0					add     ax, ax
 F761  EE					out     dx, al
 F762  03 C0					add     ax, ax
 F764  EE					out     dx, al
 F765  AC					lodsb
 F766  EE					out     dx, al
 F767  03 C0					add     ax, ax
 F769  EE					out     dx, al
 F76A  03 C0					add     ax, ax
 F76C  EE					out     dx, al
 F76D  03 C0					add     ax, ax
 F76F  EE					out     dx, al
 F770  03 C0					add     ax, ax
 F772  EE					out     dx, al
 F773  03 C0					add     ax, ax
 F775  EE					out     dx, al
 F776  03 C0					add     ax, ax
 F778  EE					out     dx, al
 F779  03 C0					add     ax, ax
 F77B  EE					out     dx, al
 F77C  E2 D0					loop    short sdwblk1
 F77E  C3					ret
 F77F				sdwblk endp

				;---------------------  read block ----------------------
 F77F				sdrblk proc near              ; in DI=data ptr, DX=03dah, CX=size. Returns CF = 0
 F77F  B0 FF					mov     al, 0ffh
 F781  EE					out     dx, al
 F782  D1 E9					shr     cx, 1         ; CF = 0
 F784  EE					out     dx, al
 F785  EB 05					jmp     short sdrblk2 
 F787				sdrblk1:
 F787  EE					out     dx, al
 F788  88 25					mov     [di], ah
 F78A  EE					out     dx, al
 F78B  47					inc     di
 F78C				sdrblk2:
 F78C  EE					out     dx, al
 F78D  90					nop
 F78E  EE					out     dx, al
 F78F  90					nop
 F790  EE					out     dx, al
 F791  90					nop
 F792  EE					out     dx, al
 F793  90					nop
 F794  EE					out     dx, al
 F795  90					nop
 F796  EE					out     dx, al
 F797  ED					in      ax, dx
 F798  EE					out     dx, al
 F799  88 25					mov     [di], ah
 F79B  EE					out     dx, al
 F79C  47					inc     di
 F79D  EE					out     dx, al
 F79E  90					nop
 F79F  EE					out     dx, al
 F7A0  90					nop
 F7A1  EE					out     dx, al
 F7A2  90					nop
 F7A3  EE					out     dx, al
 F7A4  90					nop
 F7A5  EE					out     dx, al
 F7A6  90					nop
 F7A7  EE					out     dx, al
 F7A8  ED					in      ax, dx
 F7A9  E2 DC					loop    short sdrblk1
 F7AB  88 25					mov     [di], ah
 F7AD  47					inc     di
 F7AE  C3					ret
 F7AF				sdrblk endp

				;---------------------  verify block ----------------------
 F7AF				sdvblk:              ; in DI=data ptr, DX=03dah, CX=size. Returns CF=1 on error
 F7AF  53					push    bx
 F7B0  32 DB					xor     bl, bl
 F7B2				sdvblk1:
 F7B2  E8 FF7D					call    sdrb
 F7B5  2A 25					sub     ah, [di]
 F7B7  0A DC					or      bl, ah
 F7B9  47					inc     di
 F7BA  E2 F6					loop    short sdvblk1
 F7BC  F6 DB					neg     bl  ; CF=1 if BL != 0
 F7BE  5B					pop     bx
 F7BF  C3					ret

				;---------------------  write command ----------------------
 F7C0				sdcmd8T:
 F7C0  E8 FF6F					call    sdrb
 F7C3				sdcmd:              ; in SI=6 bytes cmd buffer, DX=03dah, out AH = 0ffh on error
 F7C3  B9 0006					mov     cx, 6
 F7C6  E8 FF83					call    sdwblk
 F7C9				sdresp:
 F7C9  33 F6					xor     si, si
 F7CB				sdresp1:
 F7CB  E8 FF64					call    sdrb
 F7CE  46					inc     si
 F7CF  74 05					jz      short sdcmd1
 F7D1  80 FC FF					cmp     ah, 0ffh
 F7D4  74 F5					je      short sdresp1
 F7D6  C3			sdcmd1: ret         

				;---------------------  read ----------------------
 F7D7				sdverify:
 F7D7  68 F7AF R				push    sdvblk
 F7DA  EB 03					jmp     short sdread1
 F7DC				sdread:   ; DX:AX sector, ES:BX buffer, CX=sectors. returns AX=read sectors
 F7DC  68 F77F R				push    sdrblk   ; push proc address (read or verify) on stack
 F7DF				sdread1:        
 F7DF  50					push    ax
 F7E0  8A C2					mov     al, dl
 F7E2  50					push    ax
 F7E3  B2 51					mov     dl, 51h  ; CMD17
 F7E5  83 F9 01					cmp     cx, 1
 F7E8  74 01					je      short sdr1s
 F7EA  42					inc     dx      ; CMD18 - multiple sectors
 F7EB				sdr1s:
 F7EB  52					push    dx
 F7EC  8B F4					mov     si, sp 

 F7EE  BA 03DA					mov     dx, 3dah
 F7F1  B4 01					mov     ah, 1
 F7F3  EF					out     dx, ax       ; CS on
 F7F4  8B FB					mov     di, bx
 F7F6  8B D9					mov     bx, cx
 F7F8  8B E9					mov     bp, cx       ; save sectors number
 F7FA  16					push    ss
 F7FB  1F					pop     ds
 F7FC  C6 44 05 FF			mov	byte ptr [si+5], 0ffh ; checksum
 F800  E8 FFC0					call    sdcmd
 F803  83 C4 06					add     sp, 6
 F806  0A E4					or      ah, ah
 F808  75 41					jnz     short sdr11   ; error
 F80A  06					push    es
 F80B  1F					pop     ds
 F80C				sdrms:
 F80C  8B C7					mov     ax, di
 F80E  C1 E8 04					shr     ax, 4
 F811  8C DE					mov     si, ds
 F813  03 C6					add     ax, si
 F815  8E D8					mov     ds, ax
 F817  83 E7 0F					and     di, 15
 F81A  E8 FFAC					call    sdresp     ; wait for 0feh token
 F81D  80 FC FE					cmp     ah, 0feh
 F820  75 29					jne     short sdr11; read token error 
 F822  B5 02					mov     ch, 2      ; 512 byte sector
 F824  5E					pop     si
 F825  FF D6					call    si         ; sdrblk or sdvblk
 F827  56					push    si
 F828  9C					pushf
 F829  E8 FF06					call    sdrb       ; ignore CRC
 F82C  E8 FF03					call    sdrb       ; ignore CRC
 F82F  9D					popf
 F830  72 03					jc      short sdr3 ; verify error   
 F832  4B					dec     bx
 F833  75 D7					jnz     short sdrms; multiple sectors
 F835				sdr3:        
 F835  83 FD 01					cmp     bp, 1
 F838  74 11					je      short sdr11; single sector
 F83A  BE F984 R				mov     si, offset SD_CMD12 ; stop transfer
 F83D  0E					push    cs
 F83E  1F					pop     ds
 F83F  E8 FF81					call    sdcmd
 F842				sdr2:
 F842  D0 EC					shr     ah, 1
 F844  73 05					jnc     short sdr11
 F846  E8 FEE9					call    sdrb
 F849  EB F7					jmp     short sdr2
 F84B				sdr11:
 F84B  58					pop     ax         ; remove proc address from stack
 F84C				sdr1:       
 F84C  33 C0					xor     ax, ax
 F84E  EF					out     dx, ax
 F84F  E8 FEE0					call    sdrb       ; 8T
 F852  8B C5					mov     ax, bp
 F854  2B C3					sub     ax, bx
 F856  C3					ret     

				;---------------------  write ----------------------
 F857				sdwrite:   ; DX:AX sector, ES:BX buffer, CX=sectors, returns AX=wrote sectors
 F857  50					push    ax
 F858  8A C2					mov     al, dl
 F85A  50					push    ax
 F85B  B2 58					mov     dl, 58h  ; CMD24
 F85D  83 F9 01					cmp     cx, 1
 F860  74 01					je      short sdw1s
 F862  42					inc     dx      ; CMD25 - multiple sectors
 F863				sdw1s:
 F863  52					push    dx
 F864  8B F4					mov     si, sp 

 F866  BA 03DA					mov     dx, 3dah
 F869  B4 01					mov     ah, 1
 F86B  EF					out     dx, ax       ; CS on
 F86C  8B E9					mov     bp, cx       ; save sectors number
 F86E  16					push    ss
 F86F  1F					pop     ds
 F870  C6 44 05 FF			mov	byte ptr [si+5], 0ffh ; checksum
 F874  E8 FF4C					call    sdcmd
 F877  83 C4 06					add     sp, 6
 F87A  8B F3					mov     si, bx
 F87C  8B DD					mov     bx, bp
 F87E  0A E4					or      ah, ah
 F880  75 CA					jnz     short sdr1   ; error
 F882  06					push    es
 F883  1F					pop     ds
 F884				sdwms:
 F884  8B C6					mov     ax, si
 F886  C1 E8 04					shr     ax, 4
 F889  8C DF					mov     di, ds
 F88B  03 C7					add     ax, di
 F88D  8E D8					mov     ds, ax
 F88F  83 E6 0F					and     si, 15
 F892  B0 FE					mov     al, 0feh      ; start token
 F894  83 FD 01					cmp     bp, 1
 F897  74 02					je      short sdw1s1
 F899  B0 FC					mov     al, 0fch   ; multiple sectors
 F89B				sdw1s1:        
 F89B  E8 FE96					call    sdsb     
 F89E  B5 02					mov     ch, 2      ; 512 byte sector
 F8A0  E8 FEA9					call    sdwblk
 F8A3  E8 FE8C		call    sdrb       ; ignore CRC
 F8A6  E8 FE89					call    sdrb       ; ignore CRC
 F8A9  E8 FE86					call    sdrb       ; read response byte xxx00101
 F8AC  80 E4 0E					and     ah, 0eh
 F8AF  80 FC 04					cmp     ah, 4
 F8B2  75 98					jne     short sdr1 ; write error
 F8B4				sdwwait:
 F8B4  E8 FE7B					call    sdrb
 F8B7  D0 EC					shr     ah, 1
 F8B9  73 F9					jnc     short sdwwait     ; wait write completion
 F8BB  4B					dec     bx
 F8BC  75 C6					jnz     short sdwms       ; multiple sectors

 F8BE  83 FD 01					cmp     bp, 1
 F8C1  74 89					je      short sdr1
 F8C3  B0 FD					mov     al, 0fdh     ; multiple end transfer
 F8C5  E8 FE6C					call    sdsb 
 F8C8  E8 FE67					call	sdrb     
 F8CB				sdwwait1:
 F8CB  E8 FE64					call    sdrb
 F8CE  D0 EC					shr     ah, 1
 F8D0  73 F9					jnc     short sdwwait1     ; wait write completion
 F8D2  E9 FF77					jmp     sdr1
						
				;---------------------  init SD ----------------------
 F8D5				sdinit  proc near       ; returns AX = num kilosectors
 F8D5  1E					push    ds
 F8D6  51					push    cx
 F8D7  52					push    dx
 F8D8  56					push    si
 F8D9  57					push    di
 F8DA  BA 03DA					mov     dx, 3dah
 F8DD  B9 000A					mov     cx, 10
 F8E0				sdinit1:                   ; send 80T
 F8E0  E8 FE4F					call    sdrb
 F8E3  E2 FB					loop    short sdinit1

 F8E5  B4 01					mov     ah, 1
 F8E7  EF					out     dx, ax       ; select SD

 F8E8  BE F972 R				mov     si, offset SD_CMD0
 F8EB  0E					push    cs
 F8EC  1F					pop     ds
 F8ED  E8 FED3					call    sdcmd
 F8F0  FE CC					dec     ah
 F8F2  75 70					jnz     short sdexit ; error
						
 F8F4  BE F978 R				mov     si, offset SD_CMD8
 F8F7  E8 FEC6					call    sdcmd8T
 F8FA  FE CC					dec     ah
 F8FC  75 66					jnz     short sdexit ; error
 F8FE  B1 04					mov     cl, 4
 F900  2B E1					sub     sp, cx
 F902  8B FC					mov     di, sp
 F904  16					push    ss
 F905  1F					pop     ds
 F906  E8 FE76					call    sdrblk
 F909  58					pop     ax
 F90A  58					pop     ax
 F90B  80 FC AA					cmp     ah, 0aah
 F90E  75 54					jne     short sdexit ; CMD8 error
 F910				repinit:        
 F910  BE F990 R				mov     si, offset SD_CMD55
 F913  0E					push    cs
 F914  1F					pop     ds
 F915  E8 FEA8					call    sdcmd8T
 F918  E8 FE17					call    sdrb
 F91B  BE F98A R				mov     si, offset SD_CMD41
 F91E  E8 FEA2					call    sdcmd
 F921  FE CC					dec     ah
 F923  74 EB					jz      short repinit
						
 F925  BE F996 R				mov     si, offset SD_CMD58
 F928  E8 FE95					call    sdcmd8T
 F92B  B1 04					mov     cl, 4
 F92D  2B E1					sub     sp, cx
 F92F  8B FC					mov     di, sp
 F931  16					push    ss
 F932  1F					pop     ds
 F933  E8 FE49					call    sdrblk
 F936  58					pop     ax
 F937  A8 40					test    al, 40h     ; test OCR bit 30 (CCS)
 F939  58					pop     ax
 F93A  74 28					jz      short sdexit; no SDHC

 F93C  BE F97E R				mov     si, offset SD_CMD9 ; get size info
 F93F  0E					push    cs
 F940  1F					pop     ds
 F941  E8 FE7C					call    sdcmd8T
 F944  0A E4					or      ah, ah
 F946  75 1C					jnz     short sdexit
 F948  E8 FE7E					call    sdresp     ; wait for 0feh token
 F94B  80 FC FE					cmp     ah, 0feh
 F94E  75 14					jne     short sdexit
 F950  B1 12					mov     cl, 18       ; 16bytes + 2bytes CRC
 F952  2B E1					sub     sp, cx
 F954  8B FC					mov     di, sp
 F956  16					push    ss
 F957  1F					pop     ds
 F958  E8 FE24					call    sdrblk
 F95B  8B 4D F6					mov     cx, [di-10]
 F95E  C1 C1 08					rol     cx, 8
 F961  41					inc     cx
 F962  8B E7					mov     sp, di
 F964				sdexit: 
 F964  33 C0					xor     ax, ax       ; raise CS
 F966  EF					out     dx, ax
 F967  E8 FDC8					call    sdrb
 F96A  5F					pop     di
 F96B  5E					pop     si
 F96C  5A					pop     dx
 F96D  8B C1					mov     ax, cx       
 F96F  59					pop     cx
 F970  1F					pop     ds
 F971  C3					ret
 F972				sdinit endp
					
 F972 40 00 00 00 00 95		SD_CMD0     db  40h, 0, 0, 0, 0, 95h
 F978 48 00 00 01 AA 87		SD_CMD8     db  48h, 0, 0, 1, 0aah, 087h
 F97E 49 00 00 00 00 FF		SD_CMD9     db  49h, 0, 0, 0, 0, 0ffh
 F984 4C 00 00 00 00 FF		SD_CMD12    db  4ch, 0, 0, 0, 0, 0ffh
 F98A 69 40 00 00 00 FF		SD_CMD41    db  69h, 40h, 0, 0, 0, 0ffh
 F990 77 00 00 00 00 FF		SD_CMD55    db  77h, 0, 0, 0, 0, 0ffh
 F996 7A 00 00 00 00 FF		SD_CMD58    db  7ah, 0, 0, 0, 0, 0ffh


 F99C				Pal256:
 F99C  00 00 00 00 00 2A			db  00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,15h,00h, 2ah,2ah,2ah 
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 15 00 2A 2A 2A
 F9B4  15 15 15 15 15 3F			db  15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh 
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 F9CC  00 00 00 05 05 05			db  00h,00h,00h, 05h,05h,05h, 08h,08h,08h, 0bh,0bh,0bh, 0eh,0eh,0eh, 11h,11h,11h, 14h,14h,14h, 18h,18h,18h 
       08 08 08 0B 0B 0B
       0E 0E 0E 11 11 11
       14 14 14 18 18 18
 F9E4  1C 1C 1C 20 20 20			db  1ch,1ch,1ch, 20h,20h,20h, 24h,24h,24h, 28h,28h,28h, 2dh,2dh,2dh, 32h,32h,32h, 38h,38h,38h, 3fh,3fh,3fh 
       24 24 24 28 28 28
       2D 2D 2D 32 32 32
       38 38 38 3F 3F 3F
 F9FC  00 00 3F 10 00 3F			db  00h,00h,3fh, 10h,00h,3fh, 1fh,00h,3fh, 2fh,00h,3fh, 3fh,00h,3fh, 3fh,00h,2fh, 3fh,00h,1fh, 3fh,00h,10h 
       1F 00 3F 2F 00 3F
       3F 00 3F 3F 00 2F
       3F 00 1F 3F 00 10
 FA14  3F 00 00 3F 10 00			db  3fh,00h,00h, 3fh,10h,00h, 3fh,1fh,00h, 3fh,2fh,00h, 3fh,3fh,00h, 2fh,3fh,00h, 1fh,3fh,00h, 10h,3fh,00h 
       3F 1F 00 3F 2F 00
       3F 3F 00 2F 3F 00
       1F 3F 00 10 3F 00
 FA2C  00 3F 00 00 3F 10			db  00h,3fh,00h, 00h,3fh,10h, 00h,3fh,1fh, 00h,3fh,2fh, 00h,3fh,3fh, 00h,2fh,3fh, 00h,1fh,3fh, 00h,10h,3fh 
       00 3F 1F 00 3F 2F
       00 3F 3F 00 2F 3F
       00 1F 3F 00 10 3F
 FA44  1F 1F 3F 27 1F 3F			db  1fh,1fh,3fh, 27h,1fh,3fh, 2fh,1fh,3fh, 37h,1fh,3fh, 3fh,1fh,3fh, 3fh,1fh,37h, 3fh,1fh,2fh, 3fh,1fh,27h
       2F 1F 3F 37 1F 3F
       3F 1F 3F 3F 1F 37
       3F 1F 2F 3F 1F 27
 FA5C  00 01 02 03 04 05			db	00h, 01h, 02h, 03h, 04h, 05h, 06h, 07h, 08h, 09h, 0ah, 0bh, 0ch, 0dh, 0eh, 0fh	; EGA palette registers
       06 07 08 09 0A 0B
       0C 0D 0E 0F

				;		db  3fh,1fh,1fh, 3fh,27h,1fh, 3fh,2fh,1fh, 3fh,37h,1fh, 3fh,3fh,1fh, 37h,3fh,1fh, 2fh,3fh,1fh, 27h,3fh,1fh 
				;		db  1fh,3fh,1fh, 1fh,3fh,27h, 1fh,3fh,2fh, 1fh,3fh,37h, 1fh,3fh,3fh, 1fh,37h,3fh, 1fh,2fh,3fh, 1fh,27h,3fh 
				;		db  2dh,2dh,3fh, 31h,2dh,3fh, 36h,2dh,3fh, 3ah,2dh,3fh, 3fh,2dh,3fh, 3fh,2dh,3ah, 3fh,2dh,36h, 3fh,2dh,31h 
				;		db  3fh,2dh,2dh, 3fh,31h,2dh, 3fh,36h,2dh, 3fh,3ah,2dh, 3fh,3fh,2dh, 3ah,3fh,2dh, 36h,3fh,2dh, 31h,3fh,2dh 
				;		db  2dh,3fh,2dh, 2dh,3fh,31h, 2dh,3fh,36h, 2dh,3fh,3ah, 2dh,3fh,3fh, 2dh,3ah,3fh, 2dh,36h,3fh, 2dh,31h,3fh 
				;		db  00h,00h,1ch, 07h,00h,1ch, 0eh,00h,1ch, 15h,00h,1ch, 1ch,00h,1ch, 1ch,00h,15h, 1ch,00h,0eh, 1ch,00h,07h 
				;		db  1ch,00h,00h, 1ch,07h,00h, 1ch,0eh,00h, 1ch,15h,00h, 1ch,1ch,00h, 15h,1ch,00h, 0eh,1ch,00h, 07h,1ch,00h 
				;		db  00h,1ch,00h, 00h,1ch,07h, 00h,1ch,0eh, 00h,1ch,15h, 00h,1ch,1ch, 00h,15h,1ch, 00h,0eh,1ch, 00h,07h,1ch 

				;		db  0eh,0eh,1ch, 11h,0eh,1ch, 15h,0eh,1ch, 18h,0eh,1ch, 1ch,0eh,1ch, 1ch,0eh,18h, 1ch,0eh,15h, 1ch,0eh,11h 
				;		db  1ch,0eh,0eh, 1ch,11h,0eh, 1ch,15h,0eh, 1ch,18h,0eh, 1ch,1ch,0eh, 18h,1ch,0eh, 15h,1ch,0eh, 11h,1ch,0eh 
				;		db  0eh,1ch,0eh, 0eh,1ch,11h, 0eh,1ch,15h, 0eh,1ch,18h, 0eh,1ch,1ch, 0eh,18h,1ch, 0eh,15h,1ch, 0eh,11h,1ch 
				;		db  14h,14h,1ch, 16h,14h,1ch, 18h,14h,1ch, 1ah,14h,1ch, 1ch,14h,1ch, 1ch,14h,1ah, 1ch,14h,18h, 1ch,14h,16h 
				;		db  1ch,14h,14h, 1ch,16h,14h, 1ch,18h,14h, 1ch,1ah,14h, 1ch,1ch,14h, 1ah,1ch,14h, 18h,1ch,14h, 16h,1ch,14h 
				;		db  14h,1ch,14h, 14h,1ch,16h, 14h,1ch,18h, 14h,1ch,1ah, 14h,1ch,1ch, 14h,1ah,1ch, 14h,18h,1ch, 14h,16h,1ch 
				;		db  00h,00h,10h, 04h,00h,10h, 08h,00h,10h, 0ch,00h,10h, 10h,00h,10h, 10h,00h,0ch, 10h,00h,08h, 10h,00h,04h 
				;		db  10h,00h,00h, 10h,04h,00h, 10h,08h,00h, 10h,0ch,00h, 10h,10h,00h, 0ch,10h,00h, 08h,10h,00h, 04h,10h,00h 

				;		db  00h,10h,00h, 00h,10h,04h, 00h,10h,08h, 00h,10h,0ch, 00h,10h,10h, 00h,0ch,10h, 00h,08h,10h, 00h,04h,10h 
				;		db  08h,08h,10h, 0ah,08h,10h, 0ch,08h,10h, 0eh,08h,10h, 10h,08h,10h, 10h,08h,0eh, 10h,08h,0ch, 10h,08h,0ah 
				;		db  10h,08h,08h, 10h,0ah,08h, 10h,0ch,08h, 10h,0eh,08h, 10h,10h,08h, 0eh,10h,08h, 0ch,10h,08h, 0ah,10h,08h 
				;		db  08h,10h,08h, 08h,10h,0ah, 08h,10h,0ch, 08h,10h,0eh, 08h,10h,10h, 08h,0eh,10h, 08h,0ch,10h, 08h,0ah,10h 
				;		db  0bh,0bh,10h, 0ch,0bh,10h, 0dh,0bh,10h, 0fh,0bh,10h, 10h,0bh,10h, 10h,0bh,0fh, 10h,0bh,0dh, 10h,0bh,0ch 
				;		db  10h,0bh,0bh, 10h,0ch,0bh, 10h,0dh,0bh, 10h,0fh,0bh, 10h,10h,0bh, 0fh,10h,0bh, 0dh,10h,0bh, 0ch,10h,0bh 
				;		db  0bh,10h,0bh, 0bh,10h,0ch, 0bh,10h,0dh, 0bh,10h,0fh, 0bh,10h,10h, 0bh,0fh,10h, 0bh,0dh,10h, 0bh,0ch,10h 
				;		db  00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h

 FA6C				PalEGA:
 FA6C  00 00 00 00 00 2A			db	00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,15h,00h, 2ah,2ah,2ah
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 15 00 2A 2A 2A
 FA84  00 00 00 00 00 2A			db	00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,15h,00h, 2ah,2ah,2ah
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 15 00 2A 2A 2A
 FA9C  15 15 15 15 15 3F			db	15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 FAB4  15 15 15 15 15 3F			db	15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 FACC  00 00 00 00 00 2A			db	00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,15h,00h, 2ah,2ah,2ah
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 15 00 2A 2A 2A
 FAE4  00 00 00 00 00 2A			db	00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,15h,00h, 2ah,2ah,2ah
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 15 00 2A 2A 2A
 FAFC  15 15 15 15 15 3F			db	15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 FB14  15 15 15 15 15 3F			db	15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 FB2C  00 01 02 03 04 05			db	00h, 01h, 02h, 03h, 04h, 05h, 06h, 07h, 10h, 11h, 12h, 13h, 14h, 15h, 16h, 17h	; EGA palette registers
       06 07 10 11 12 13
       14 15 16 17

 FB3C				PalVGA:
 FB3C  00 00 00 00 00 2A			db	00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,2ah,00h, 2ah,2ah,2ah
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 2A 00 2A 2A 2A
 FB54  00 00 15 00 00 3F			db	00h,00h,15h, 00h,00h,3fh, 00h,2ah,15h, 00h,2ah,3fh, 2ah,00h,15h, 2ah,00h,3fh, 2ah,2ah,15h, 2ah,2ah,3fh
       00 2A 15 00 2A 3F
       2A 00 15 2A 00 3F
       2A 2A 15 2A 2A 3F
 FB6C  00 15 00 00 15 2A			db	00h,15h,00h, 00h,15h,2ah, 00h,3fh,00h, 00h,3fh,2ah, 2ah,15h,00h, 2ah,15h,2ah, 2ah,3fh,00h, 2ah,3fh,2ah
       00 3F 00 00 3F 2A
       2A 15 00 2A 15 2A
       2A 3F 00 2A 3F 2A
 FB84  00 15 15 00 15 3F			db	00h,15h,15h, 00h,15h,3fh, 00h,3fh,15h, 00h,3fh,3fh, 2ah,15h,15h, 2ah,15h,3fh, 2ah,3fh,15h, 2ah,3fh,3fh
       00 3F 15 00 3F 3F
       2A 15 15 2A 15 3F
       2A 3F 15 2A 3F 3F
 FB9C  15 00 00 15 00 2A			db	15h,00h,00h, 15h,00h,2ah, 15h,2ah,00h, 15h,2ah,2ah, 3fh,00h,00h, 3fh,00h,2ah, 3fh,2ah,00h, 3fh,2ah,2ah
       15 2A 00 15 2A 2A
       3F 00 00 3F 00 2A
       3F 2A 00 3F 2A 2A
 FBB4  15 00 15 15 00 3F			db	15h,00h,15h, 15h,00h,3fh, 15h,2ah,15h, 15h,2ah,3fh, 3fh,00h,15h, 3fh,00h,3fh, 3fh,2ah,15h, 3fh,2ah,3fh
       15 2A 15 15 2A 3F
       3F 00 15 3F 00 3F
       3F 2A 15 3F 2A 3F
 FBCC  15 15 00 15 15 2A			db	15h,15h,00h, 15h,15h,2ah, 15h,3fh,00h, 15h,3fh,2ah, 3fh,15h,00h, 3fh,15h,2ah, 3fh,3fh,00h, 3fh,3fh,2ah
       15 3F 00 15 3F 2A
       3F 15 00 3F 15 2A
       3F 3F 00 3F 3F 2A
 FBE4  15 15 15 15 15 3F			db	15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 FBFC  00 01 02 03 04 05			db	00h, 01h, 02h, 03h, 04h, 05h, 14h, 07h, 38h, 39h, 3ah, 3bh, 3ch, 3dh, 3eh, 3fh	; EGA palette registers
       14 07 38 39 3A 3B
       3C 3D 3E 3F

				IFDEF SCANCODE1 ; use SCANCODE1
 FC0C				KeyIndex:
 FC0C  00 52 31 32 34 33			db	0, 82, 49, 50, 52, 51, 54, 55    ;0-7
       36 37
 FC14  38 39 3C 3B 41 44			db 56, 57, 60, 59, 65, 68, 72, 47    ;8-f
       48 2F
 FC1C  01 05 09 0D 0C 12			db	1,  5,  9, 13, 12, 18, 21, 23    ;10-17
       15 17
 FC24  18 1A 43 46 45 00			db 24, 26, 67, 70, 69,  0,  4,  3    ;18-1f
       04 03
 FC2C  08 0B 11 10 14 16			db	8, 11, 17, 16, 20, 22, 25, 64    ;20-27
       19 40
 FC34  42 30 00 47 02 07			db 66, 48,  0, 71,  2,  7,  6, 10    ;28-2f
       06 0A
 FC3C  0F 0E 13 3A 3D 3E			db 15, 14, 19, 58, 61, 62,  0, 87    ;30-37
       00 57
 FC44  00 35 00 28 29 27			db	0, 53,  0, 40, 41, 39, 46, 38    ;38-3f
       2E 26
 FC4C  2D 5A 2C 4F 2B 00			db 45, 90, 44, 79, 43,  0, 89, 29    ;40-47
       59 1D
 FC54  22 24 56 1C 25 21			db 34, 36, 86, 28, 37, 33, 84, 27    ;48-4f
       54 1B
 FC5C  20 23 1E 1F 00 00			db 32, 35, 30, 31,  0,  0,	0, 83    ;50-57  
       00 53
 FC64  2A					db 42
 FC65				E0KeyList:
 FC65  35 1C 4F 4B 47 52		db	35h, 1ch, 4fh, 4bh, 47h, 52h, 53h, 50h, 4dh, 48h, 51h, 49h 
       53 50 4D 48 51 49

				ELSE    ; use SCANCODE2
				ENDIF

 FC71				E0KeyIndex:
 FC71  3F 45 49 4A 4B 4C		db	63,  69,  73,  74,  75,  76,  77,  78,  80,  81,  85,  88
       4D 4E 50 51 55 58

 FC7D				KeyCode:	  
				; Keys affected by CapsLock
				;		norm   shft   ctrl   alt
 FC7D  0000 0000 0000				dw	0000h, 0000h, 0000h, 0000h ;17 - <0>
       0000
 FC85  1071 1051 1011				dw	1071h, 1051h, 1011h, 1000h ;15 - Q, (E0)PrevTrack <1>
       1000
 FC8D  2C7A 2C5A 2C1A				dw	2c7ah, 2c5ah, 2c1ah, 2c00h ;1a - Z <2>
       2C00
 FC95  1F73 1F53 1F13				dw	1f73h, 1f53h, 1f13h, 1f00h ;1b - S <3>
       1F00
 FC9D  1E61 1E41 1E01				dw	1e61h, 1e41h, 1e01h, 1e00h ;1c - A <4>
       1E00
 FCA5  1177 1157 1117				dw	1177h, 1157h, 1117h, 1100h ;1d - W <5>
       1100
 FCAD  2E63 2E43 2E03				dw	2e63h, 2e43h, 2e03h, 2e00h ;21 - C, (E0)Volume Down <6>
       2E00
 FCB5  2D78 2D58 2D18				dw	2d78h, 2d58h, 2d18h, 2d00h ;22 - X <7>
       2D00
 FCBD  2064 2044 2004				dw	2064h, 2044h, 2004h, 2000h ;23 - D, (E0)Mute <8>
       2000
 FCC5  1265 1245 1205				dw	1265h, 1245h, 1205h, 1200h ;24 - E <9>
       1200
 FCCD  2F76 2F56 2F16				dw	2f76h, 2f56h, 2f16h, 2f00h ;2a - V <10>
       2F00
 FCD5  2166 2146 2106				dw	2166h, 2146h, 2106h, 2100h ;2b - F, (E0)Calculator <11>
       2100
 FCDD  1474 1454 1414				dw	1474h, 1454h, 1414h, 1400h ;2c - T <12>
       1400
 FCE5  1372 1352 1312				dw	1372h, 1352h, 1312h, 1300h ;2d - R <13>
       1300
 FCED  316E 314E 310E				dw	316eh, 314eh, 310eh, 3100h ;31 - N <14>
       3100
 FCF5  3062 3042 3002				dw	3062h, 3042h, 3002h, 3000h ;32 - B, (E0)Volume Up <15>
       3000
 FCFD  2368 2348 2308				dw	2368h, 2348h, 2308h, 2300h ;33 - H <16>
       2300
 FD05  2267 2247 2207				dw	2267h, 2247h, 2207h, 2200h ;34 - G, (E0)Play/Pause <17>
       2200
 FD0D  1579 1559 1519				dw	1579h, 1559h, 1519h, 1500h ;35 - Y <18>
       1500
 FD15  326D 324D 320D				dw	326dh, 324dh, 320dh, 3200h ;3a - M, (E0)WWW Home <19>
       3200
 FD1D  246A 244A 240A				dw	246ah, 244ah, 240ah, 2400h ;3b - J, (E0)Stop <20>
       2400
 FD25  1675 1655 1615				dw	1675h, 1655h, 1615h, 1600h ;3c - U <21>
       1600
 FD2D  256B 254B 250B				dw	256bh, 254bh, 250bh, 2500h ;42 - K <22>
       2500
 FD35  1769 1749 1709				dw	1769h, 1749h, 1709h, 1700h ;43 - I <23>
       1700
 FD3D  186F 184F 180F				dw	186fh, 184fh, 180fh, 1800h ;44 - O <24>
       1800
 FD45  266C 264C 260C				dw	266ch, 264ch, 260ch, 2600h ;4b - L <25>
       2600
 FD4D  1970 1950 1910				dw	1970h, 1950h, 1910h, 1900h ;4d - P, (E0)Next Track <26>
       1900
				; keys affected by NumLock	
 FD55  4F00 4F31 7500				dw	4f00h, 4f31h, 7500h, 0002h ;69 - KP1 <27>
       0002
 FD5D  4B00 4B34 7300				dw	4b00h, 4b34h, 7300h, 0005h ;6b - KP4 <28>
       0005
 FD65  4700 4737 7700				dw	4700h, 4737h, 7700h, 0008h ;6c - KP7 <29>
       0008
 FD6D  5200 5230 9200				dw	5200h, 5230h, 9200h, 0001h ;70 - KP0 <30>
       0001
 FD75  5300 532E 9300				dw	5300h, 532eh, 9300h, 0000h ;71 - KP. <31>
       0000
 FD7D  5000 5032 9100				dw	5000h, 5032h, 9100h, 0003h ;72 - KP2 <32>
       0003
 FD85  4D00 4D36 7400				dw	4d00h, 4d36h, 7400h, 0007h ;74 - KP6 <33>
       0007
 FD8D  4800 4838 8D00				dw	4800h, 4838h, 8d00h, 0009h ;75 - KP8 <34>
       0009
 FD95  5100 5133 7600				dw	5100h, 5133h, 7600h, 0004h ;7a - KP3 <35>
       0004
 FD9D  4900 4939 8400				dw	4900h, 4939h, 8400h, 000ah ;7d - KP9 <36>
       000A
 FDA5  4C00 4C35 8F00				dw	4c00h, 4c35h, 8f00h, 0006h ;73 - KP5 --- on VMWare, it does not send 4c00 <37>
       0006
				; keys unaffected by CapsLock or N
 FDAD  3F00 5800 6200				dw	3f00h, 5800h, 6200h, 6c00h ;03 - F5 <38>
       6C00
 FDB5  3D00 5600 6000				dw	3d00h, 5600h, 6000h, 6a00h ;04 - F3 <39>
       6A00
 FDBD  3B00 5400 5E00				dw	3b00h, 5400h, 5e00h, 6800h ;05 - F1 <40>
       6800
 FDC5  3C00 5500 5F00				dw	3c00h, 5500h, 5f00h, 6900h ;06 - F2 <41>
       6900
 FDCD  8600 8800 8A00				dw	8600h, 8800h, 8a00h, 8c00h ;07 - F12 <42>	
       8C00
 FDD5  4400 5D00 6700				dw	4400h, 5d00h, 6700h, 7100h ;09 - F10 <43>
       7100
 FDDD  4200 5B00 6500				dw	4200h, 5b00h, 6500h, 6f00h ;0a - F8 <44>
       6F00
 FDE5  4000 5900 6300				dw	4000h, 5900h, 6300h, 6d00h ;0b - F6 <45>
       6D00
 FDED  3E00 5700 6100				dw	3e00h, 5700h, 6100h, 6b00h ;0c - F4 <46>
       6B00
 FDF5  0F09 0F00 9400				dw	0f09h, 0f00h, 9400h, 0000h ;0d - TAB <47>	
       0000
 FDFD  2960 297E 0000				dw	2960h, 297eh, 0000h, 2900h ;0e - ` ~ <48>	
       2900
 FE05  0231 0221 0000				dw	0231h, 0221h, 0000h, 7800h ;16 - 1 ! <49>	
       7800
 FE0D  0332 0340 0300				dw	0332h, 0340h, 0300h, 7900h ;1e - 2 @ <50>	
       7900
 FE15  0534 0524 0000				dw	0534h, 0524h, 0000h, 7b00h ;25 - 4 $ <51>
       7B00
 FE1D  0433 0423 0000				dw	0433h, 0423h, 0000h, 7a00h ;26 - 3 # <52>
       7A00
 FE25  3920 3920 3920				dw	3920h, 3920h, 3920h, 3920h ;29 - SPC <53>	
       3920
 FE2D  0635 0625 0000				dw	0635h, 0625h, 0000h, 7c00h ;2e - 5 % <54>
       7C00
 FE35  0736 075E 071E				dw	0736h, 075eh, 071eh, 7d00h ;36 - 6 ^ <55>
       7D00
 FE3D  0837 0826 0000				dw	0837h, 0826h, 0000h, 7e00h ;3d - 7 & <56>
       7E00
 FE45  0938 092A 0000				dw	0938h, 092ah, 0000h, 7f00h ;3e - 8 * <57>
       7F00
 FE4D  332C 333C 0000				dw	332ch, 333ch, 0000h, 3300h ;41 - , < <58>
       3300
 FE55  0B30 0B29 0000				dw	0b30h, 0b29h, 0000h, 8100h ;45 - 0 ) <59>
       8100
 FE5D  0A39 0A28 0000				dw	0a39h, 0a28h, 0000h, 8000h ;46 - 9 ( <60>
       8000
 FE65  342E 343E 0000				dw	342eh, 343eh, 0000h, 3400h ;49 - . > <61>
       3400
 FE6D  352F 353F 0000				dw	352fh, 353fh, 0000h, 3500h ;4a - / ? <62>
       3500
 FE75  E02F E02F 9500				dw	0e02fh, 0e02fh, 9500h, 0a400h ;4a - (e0)KP/ <63>
       A400
 FE7D  273B 273A 0000				dw	273bh, 273ah, 0000h, 2700h ;4c - ; : <64>
       2700
 FE85  0C2D 0C5F 0C1F				dw	0c2dh, 0c5fh, 0c1fh, 8200h ;4e - - _ <65>
       8200
 FE8D  2827 2822 0000				dw	2827h, 2822h, 0000h, 2800h ;52 -   <66>
       2800
 FE95  1A5B 1A7B 1A1B				dw	1a5bh, 1a7bh, 1a1bh, 1a00h ;54 - [ { <67>
       1A00
 FE9D  0D3D 0D2B 0000				dw	0d3dh, 0d2bh, 0000h, 8300h ;55 - = + <68>	
       8300
 FEA5  1C0D 1C0D 1C0A				dw	1c0dh, 1c0dh, 1c0ah, 1c00h ;5a - Enter, (E0)KPEnter <69>
       1C00
 FEAD  1B5D 1B7D 1B1D				dw	1b5dh, 1b7dh, 1b1dh, 1b00h ;5b - ] } <70>
       1B00
 FEB5  2B5C 2B7C 2B1C				dw	2b5ch, 2b7ch, 2b1ch, 2b00h ;5d - \ | <71>
       2B00
 FEBD  0E08 0E08 0E7F				dw	0e08h, 0e08h, 0e7fh, 0e00h ;66 - BKSP <72>
       0E00
 FEC5  4F00 4F00 7500				dw	4f00h, 4f00h, 7500h, 9f00h ;69 - (E0)END <73>
       9F00
 FECD  4B00 4B00 7300				dw	4b00h, 4b00h, 7300h, 9b00h ;6b - (E0)LEFT <74>
       9B00
 FED5  4700 4700 7700				dw	4700h, 4700h, 7700h, 9700h ;6c - (E0)HOME <75>
       9700
 FEDD  5200 5200 9200				dw	5200h, 5200h, 9200h, 0a200h ;70 - (E0)INS <76>
       A200
 FEE5  5300 5300 9300				dw	5300h, 5300h, 9300h, 0a300h ;71 - (E0)DEL <77>
       A300
 FEED  5000 5000 9100				dw	5000h, 5000h, 9100h, 0a000h ;72 - (E0)DOWN <78>
       A000
 FEF5  4300 5C00 6600				dw	4300h, 5c00h, 6600h, 7000h ;01 - F9 <79>
       7000
 FEFD  4D00 4D00 7400				dw	4d00h, 4d00h, 7400h, 9d00h ;74 - (E0)RIGHT <80>
       9D00
 FF05  4800 4800 8D00				dw	4800h, 4800h, 8d00h, 9800h ;75 - (E0)UP <81>
       9800
 FF0D  011B 011B 011B				dw	011bh, 011bh, 011bh, 0100h ;76 - ESC <82>
       0100
 FF15  8500 8700 8900				dw	8500h, 8700h, 8900h, 8b00h ;78 - F11 <83>
       8B00
 FF1D  4E2B 4E2B 9000				dw	4e2bh, 4e2bh, 9000h, 4e00h ;79 - KP+ <84>
       4E00
 FF25  5100 5100 7600				dw	5100h, 5100h, 7600h, 0a100h ;7a - (E0)PGDN <85>
       A100
 FF2D  4A2D 4A2D 8E00				dw	4a2dh, 4a2dh, 8e00h, 4a00h ;7b - KP- <86>
       4A00
 FF35  372A 372A 9600				dw	372ah, 372ah, 9600h, 3700h ;7c - KP* --- on VMWare, it does not send 3710h with CTL <87>
       3700
 FF3D  4900 4900 8400				dw	4900h, 4900h, 8400h, 9900h ;7d - (E0)PGUP <88>
       9900
 FF45  4600 4600 4600				dw	4600h, 4600h, 4600h, 4600h ;7e - SCRL <89>
       4600
 FF4D  4100 5A00 6400				dw	4100h, 5a00h, 6400h, 6e00h ;83 - F7 <90>
       6E00

				; ------------------------- POWER ON RESET -----------------------
						org     0fff0h
						
 FFF0  EA					db      0eah
 FFF1  E05B R F000				dw      coldboot, 0f000h
 FFF5  30 39 2F 31 30 2F			db      '09/10/17'
       31 37
 FFFD  FF FF 00					db      0ffh, 0ffh, 0
				end bios
Microsoft (R) Macro Assembler Version 6.14.8444		    03/07/22 17:52:44
BIOS_Next186.asm					     Symbols 2 - 1




Macros:

                N a m e                 Type

OFFDX  . . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_TEXT  . . . . . . . . . . . . .	16 Bit	 00010000 Word	  Public  'CODE'	
_DATA  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

KeyLock  . . . . . . . . . . . .	P Near	 E58D	  _TEXT	Length= 0016 Public
  s2 . . . . . . . . . . . . . .	L Near	 E59A	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 E5A2	  _TEXT	
defint . . . . . . . . . . . . .	P Near	 F6E6	  _TEXT	Length= 0001 Public
enableKbIfPresent  . . . . . . .	P Near	 F6DA	  _TEXT	Length= 000C Public
  noenablekb . . . . . . . . . .	L Near	 F6E5	  _TEXT	
getps2byte . . . . . . . . . . .	P Near	 F6AF	  _TEXT	Length= 001A Public
  gps2b2 . . . . . . . . . . . .	L Near	 F6B4	  _TEXT	
  gps2b1 . . . . . . . . . . . .	L Near	 F6C4	  _TEXT	
int07  . . . . . . . . . . . . .	P Near	 E2FA	  _TEXT	Length= 0030 Public
  int07_pfx  . . . . . . . . . .	L Near	 E303	  _TEXT	
  int072 . . . . . . . . . . . .	L Near	 E31C	  _TEXT	
int08  . . . . . . . . . . . . .	P Near	 E32A	  _TEXT	Length= 0056 Public
  int08_nodec  . . . . . . . . .	L Near	 E339	  _TEXT	
  int081 . . . . . . . . . . . .	L Near	 E362	  _TEXT	
  kloop  . . . . . . . . . . . .	L Near	 E368	  _TEXT	
  kbdata . . . . . . . . . . . .	L Near	 E37A	  _TEXT	
  nokey  . . . . . . . . . . . .	L Near	 E37C	  _TEXT	
int09  . . . . . . . . . . . . .	P Near	 E380	  _TEXT	Length= 020D Public
  SecondACK  . . . . . . . . . .	L Near	 E3AA	  _TEXT	
  ToggleACK  . . . . . . . . . .	L Near	 E3AD	  _TEXT	
  SetFlags1  . . . . . . . . . .	L Near	 E3B0	  _TEXT	
  noACK  . . . . . . . . . . . .	L Near	 E3B3	  _TEXT	
  noE0 . . . . . . . . . . . . .	L Near	 E3C6	  _TEXT	
  noE1 . . . . . . . . . . . . .	L Near	 E3CF	  _TEXT	
  noDEL  . . . . . . . . . . . .	L Near	 E3EB	  _TEXT	
  noLSDown . . . . . . . . . . .	L Near	 E3F9	  _TEXT	
  noLSUp . . . . . . . . . . . .	L Near	 E402	  _TEXT	
  noRSDown . . . . . . . . . . .	L Near	 E40B	  _TEXT	
  noRSUp . . . . . . . . . . . .	L Near	 E414	  _TEXT	
  LALTDn . . . . . . . . . . . .	L Near	 E425	  _TEXT	
  noALTDown  . . . . . . . . . .	L Near	 E42B	  _TEXT	
  LALTUp . . . . . . . . . . . .	L Near	 E43C	  _TEXT	
  ALTUp  . . . . . . . . . . . .	L Near	 E440	  _TEXT	
  noALTUp  . . . . . . . . . . .	L Near	 E44D	  _TEXT	
  SetFlagsKey2 . . . . . . . . .	L Near	 E45C	  _TEXT	
  LCTLDn . . . . . . . . . . . .	L Near	 E45E	  _TEXT	
  noCTLDown  . . . . . . . . . .	L Near	 E464	  _TEXT	
  LCTLUp . . . . . . . . . . . .	L Near	 E475	  _TEXT	
  noCTLUp  . . . . . . . . . . .	L Near	 E47B	  _TEXT	
  noScrLock  . . . . . . . . . .	L Near	 E4AE	  _TEXT	
  testINS  . . . . . . . . . . .	L Near	 E4BD	  _TEXT	
  noIns  . . . . . . . . . . . .	L Near	 E4C3	  _TEXT	
  SetFlagsKey1 . . . . . . . . .	L Near	 E4D7	  _TEXT	
  E0Key  . . . . . . . . . . . .	L Near	 E4DA	  _TEXT	
  NormalKey  . . . . . . . . . .	L Near	 E4EF	  _TEXT	
  KeyDown  . . . . . . . . . . .	L Near	 E503	  _TEXT	
  noShift  . . . . . . . . . . .	L Near	 E50C	  _TEXT	
  noCaps . . . . . . . . . . . .	L Near	 E51A	  _TEXT	
  NumDown  . . . . . . . . . . .	L Near	 E525	  _TEXT	
  noNum  . . . . . . . . . . . .	L Near	 E528	  _TEXT	
  noCtrl . . . . . . . . . . . .	L Near	 E52F	  _TEXT	
  noAlt  . . . . . . . . . . . .	L Near	 E536	  _TEXT	
  pushKey  . . . . . . . . . . .	L Near	 E554	  _TEXT	
  SetFlagsKey  . . . . . . . . .	L Near	 E55F	  _TEXT	
  SetFlags . . . . . . . . . . .	L Near	 E562	  _TEXT	
  SF1  . . . . . . . . . . . . .	L Near	 E57D	  _TEXT	
  int09Exit  . . . . . . . . . .	L Near	 E585	  _TEXT	
int10  . . . . . . . . . . . . .	P Near	 E5A3	  _TEXT	Length= 097A Public
  exit . . . . . . . . . . . . .	L Near	 E5C2	  _TEXT	
  svga . . . . . . . . . . . . .	L Near	 E5C5	  _TEXT	
  VESAGetInfo  . . . . . . . . .	L Near	 E5DA	  _TEXT	
  VESASupportedClear . . . . . .	L Near	 E5E7	  _TEXT	
  VESASupported  . . . . . . . .	L Near	 E5ED	  _TEXT	
  VESASupportedErr . . . . . . .	L Near	 E5EF	  _TEXT	
  VESAGetModeInfo  . . . . . . .	L Near	 E5F3	  _TEXT	
  VESAGetModeInfo1 . . . . . . .	L Near	 E5F7	  _TEXT	
  VESASetMode  . . . . . . . . .	L Near	 E60A	  _TEXT	
  VESASetMode1 . . . . . . . . .	L Near	 E61C	  _TEXT	
  VESAGetMode  . . . . . . . . .	L Near	 E624	  _TEXT	
  VESAGetMode1 . . . . . . . . .	L Near	 E63A	  _TEXT	
  VESAMemControl . . . . . . . .	L Near	 E640	  _TEXT	
  VESAMemControlCB . . . . . . .	L Near	 E644	  _TEXT	
  getpageinfo  . . . . . . . . .	L Near	 E661	  _TEXT	
  VESAModeInfo . . . . . . . . .	L Near	 E697	  _TEXT	
  ModeTab  . . . . . . . . . . .	L Near	 E6AA	  _TEXT	
  setmode  . . . . . . . . . . .	L Near	 E713	  _TEXT	
  setmode1 . . . . . . . . . . .	L Near	 E778	  _TEXT	
  setmode1a  . . . . . . . . . .	L Near	 E79A	  _TEXT	
  setmode11  . . . . . . . . . .	L Near	 E7B8	  _TEXT	
  setmode12  . . . . . . . . . .	L Near	 E7D0	  _TEXT	
  setmode1221  . . . . . . . . .	L Near	 E7DA	  _TEXT	
  setmode122 . . . . . . . . . .	L Near	 E7E8	  _TEXT	
  setmode121 . . . . . . . . . .	L Near	 E802	  _TEXT	
  setmode13  . . . . . . . . . .	L Near	 E811	  _TEXT	
  setmode3 . . . . . . . . . . .	L Near	 E829	  _TEXT	
  setmode21  . . . . . . . . . .	L Near	 E842	  _TEXT	
  setmode2 . . . . . . . . . . .	L Near	 E84A	  _TEXT	
  setmode2a  . . . . . . . . . .	L Near	 E85B	  _TEXT	
  clearnext  . . . . . . . . . .	L Near	 E8A5	  _TEXT	
  clearok  . . . . . . . . . . .	L Near	 E8B9	  _TEXT	
  setmode4 . . . . . . . . . . .	L Near	 E8B9	  _TEXT	
  setmodeexit  . . . . . . . . .	L Near	 E912	  _TEXT	
  nullproc . . . . . . . . . . .	L Near	 E924	  _TEXT	
  cursor . . . . . . . . . . . .	L Near	 E925	  _TEXT	
  cursor8  . . . . . . . . . . .	L Near	 E936	  _TEXT	
  curpos . . . . . . . . . . . .	L Near	 E945	  _TEXT	
  curpos1  . . . . . . . . . . .	L Near	 E977	  _TEXT	
  getcurpos  . . . . . . . . . .	L Near	 E97A	  _TEXT	
  lightpen . . . . . . . . . . .	L Near	 E98A	  _TEXT	
  apage  . . . . . . . . . . . .	L Near	 E98D	  _TEXT	
  apage1 . . . . . . . . . . . .	L Near	 E9B8	  _TEXT	
  apage3 . . . . . . . . . . . .	L Near	 E9C6	  _TEXT	
  apage2 . . . . . . . . . . . .	L Near	 E9C8	  _TEXT	
  apage4 . . . . . . . . . . . .	L Near	 E9CB	  _TEXT	
  scrollup . . . . . . . . . . .	L Near	 E9E6	  _TEXT	
  scrollup6  . . . . . . . . . .	L Near	 E9F0	  _TEXT	
  scrollup4  . . . . . . . . . .	L Near	 EA07	  _TEXT	
  scrollup3  . . . . . . . . . .	L Near	 EA14	  _TEXT	
  scrollup5  . . . . . . . . . .	L Near	 EA19	  _TEXT	
  scrollexit . . . . . . . . . .	L Near	 EA23	  _TEXT	
  scrolldn . . . . . . . . . . .	L Near	 EA26	  _TEXT	
  scr_params . . . . . . . . . .	L Near	 EA37	  _TEXT	
  readchar . . . . . . . . . . .	L Near	 EA4D	  _TEXT	
  mode3chaddr  . . . . . . . . .	L Near	 EA55	  _TEXT	
  writecharattr  . . . . . . . .	L Near	 EA73	  _TEXT	
  writechar  . . . . . . . . . .	L Near	 EA89	  _TEXT	
  writechar3 . . . . . . . . . .	L Near	 EA90	  _TEXT	
  writecharskip  . . . . . . . .	L Near	 EA99	  _TEXT	
  setcolorpalette  . . . . . . .	L Near	 EA9A	  _TEXT	
  setcolorpalette_pal  . . . . .	L Near	 EAB2	  _TEXT	
  setcolorpalette_out  . . . . .	L Near	 EAB9	  _TEXT	
  writecharTTY . . . . . . . . .	L Near	 EAC0	  _TEXT	
  tty  . . . . . . . . . . . . .	L Near	 EADE	  _TEXT	
  tty1 . . . . . . . . . . . . .	L Near	 EB03	  _TEXT	
  bell . . . . . . . . . . . . .	L Near	 EB05	  _TEXT	
  bs . . . . . . . . . . . . . .	L Near	 EB07	  _TEXT	
  lf . . . . . . . . . . . . . .	L Near	 EB0F	  _TEXT	
  crlf . . . . . . . . . . . . .	L Near	 EB13	  _TEXT	
  cr . . . . . . . . . . . . . .	L Near	 EB15	  _TEXT	
  readmode . . . . . . . . . . .	L Near	 EB37	  _TEXT	
  pal  . . . . . . . . . . . . .	L Near	 EB81	  _TEXT	
  palexit  . . . . . . . . . . .	L Near	 EB8E	  _TEXT	
  setonereg  . . . . . . . . . .	L Near	 EB8F	  _TEXT	
  setonereg1 . . . . . . . . . .	L Near	 EB9E	  _TEXT	
  setallreg  . . . . . . . . . .	L Near	 EB9F	  _TEXT	
  setallreg1 . . . . . . . . . .	L Near	 EBA6	  _TEXT	
  setblink . . . . . . . . . . .	L Near	 EBB3	  _TEXT	
  setblink1  . . . . . . . . . .	L Near	 EBDD	  _TEXT	
  readonereg . . . . . . . . . .	L Near	 EBDF	  _TEXT	
  readallreg . . . . . . . . . .	L Near	 EBF4	  _TEXT	
  readllreg1 . . . . . . . . . .	L Near	 EBF9	  _TEXT	
  readoverscan . . . . . . . . .	L Near	 EC0B	  _TEXT	
  setoneDAC  . . . . . . . . . .	L Near	 EC0E	  _TEXT	
  setblockDAC  . . . . . . . . .	L Near	 EC24	  _TEXT	
  paging . . . . . . . . . . . .	L Near	 EC35	  _TEXT	
  paging1  . . . . . . . . . . .	L Near	 EC56	  _TEXT	
  paging3  . . . . . . . . . . .	L Near	 EC5D	  _TEXT	
  paging2  . . . . . . . . . . .	L Near	 EC62	  _TEXT	
  readoneDAC . . . . . . . . . .	L Near	 EC65	  _TEXT	
  readblockDAC . . . . . . . . .	L Near	 EC7D	  _TEXT	
  setPELmask . . . . . . . . . .	L Near	 EC8E	  _TEXT	
  getPELmask . . . . . . . . . .	L Near	 EC97	  _TEXT	
  getpaging  . . . . . . . . . .	L Near	 ECA0	  _TEXT	
  getpaging1 . . . . . . . . . .	L Near	 ECB5	  _TEXT	
  grayscale  . . . . . . . . . .	L Near	 ECB6	  _TEXT	
  grayscale1 . . . . . . . . . .	L Near	 ECBB	  _TEXT	
  grayscale2 . . . . . . . . . .	L Near	 ECE3	  _TEXT	
  loadUDF  . . . . . . . . . . .	L Near	 ECE4	  _TEXT	
  loadUDF1 . . . . . . . . . . .	L Near	 ECF0	  _TEXT	
  loadUDFexit1 . . . . . . . . .	L Near	 ED2F	  _TEXT	
  loadUDFexit  . . . . . . . . .	L Near	 ED30	  _TEXT	
  chargen  . . . . . . . . . . .	L Near	 ED31	  _TEXT	
  loadROMFont8 . . . . . . . . .	L Near	 ED54	  _TEXT	
  loadROMFont16  . . . . . . . .	L Near	 ED5F	  _TEXT	
  loadROMFont161 . . . . . . . .	L Near	 ED68	  _TEXT	
  set1f  . . . . . . . . . . . .	L Near	 ED77	  _TEXT	
  setgrUDF . . . . . . . . . . .	L Near	 ED82	  _TEXT	
  setgrUDF1  . . . . . . . . . .	L Near	 EDA2	  _TEXT	
  setgrUDFexit . . . . . . . . .	L Near	 EDAD	  _TEXT	
  setROMgrFont . . . . . . . . .	L Near	 EDAF	  _TEXT	
  setROMgrFont1  . . . . . . . .	L Near	 EDC0	  _TEXT	
  getfontinfo  . . . . . . . . .	L Near	 EDCD	  _TEXT	
  getfontinfo1 . . . . . . . . .	L Near	 EDE8	  _TEXT	
  getfontinfoexit  . . . . . . .	L Near	 EDFB	  _TEXT	
  special  . . . . . . . . . . .	L Near	 EE08	  _TEXT	
  special1 . . . . . . . . . . .	L Near	 EE18	  _TEXT	
  special2 . . . . . . . . . . .	L Near	 EE2C	  _TEXT	
  writestr . . . . . . . . . . .	L Near	 EE2F	  _TEXT	
  wstr1  . . . . . . . . . . . .	L Near	 EE3E	  _TEXT	
  noattr . . . . . . . . . . . .	L Near	 EE4C	  _TEXT	
  wstr2  . . . . . . . . . . . .	L Near	 EE61	  _TEXT	
  wstrexit . . . . . . . . . . .	L Near	 EE62	  _TEXT	
  getdcc . . . . . . . . . . . .	L Near	 EE63	  _TEXT	
  setdcc . . . . . . . . . . . .	L Near	 EE6E	  _TEXT	
  getdccexit . . . . . . . . . .	L Near	 EE73	  _TEXT	
  querystatus  . . . . . . . . .	L Near	 EE74	  _TEXT	
  querystatus1 . . . . . . . . .	L Near	 EEA6	  _TEXT	
  querystatus3 . . . . . . . . .	L Near	 EEB0	  _TEXT	
int11  . . . . . . . . . . . . .	P Near	 EF1D	  _TEXT	Length= 0009 Public
int12  . . . . . . . . . . . . .	P Near	 EF26	  _TEXT	Length= 0009 Public
int13  . . . . . . . . . . . . .	P Near	 EF2F	  _TEXT	Length= 01ED Public
  inINT13  . . . . . . . . . . .	L Near	 EF4E	  _TEXT	
  Disk1  . . . . . . . . . . . .	L Near	 EF52	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 EF62	  _TEXT	
  exit2  . . . . . . . . . . . .	L Near	 EF66	  _TEXT	
  exit1  . . . . . . . . . . . .	L Near	 EF6D	  _TEXT	
  DiskGetType  . . . . . . . . .	L Near	 EFC0	  _TEXT	
  DiskGetTypeexit  . . . . . . .	L Near	 EFD7	  _TEXT	
  DiskExtInstCheck . . . . . . .	L Near	 EFE0	  _TEXT	
  DiskReset  . . . . . . . . . .	L Near	 EFEE	  _TEXT	
  DiskChanged  . . . . . . . . .	L Near	 EFEE	  _TEXT	
  DiskPark . . . . . . . . . . .	L Near	 EFEE	  _TEXT	
  DiskGetStatus  . . . . . . . .	L Near	 EFF1	  _TEXT	
  DiskVerify . . . . . . . . . .	L Near	 EFF6	  _TEXT	
  DiskWrite  . . . . . . . . . .	L Near	 EFFB	  _TEXT	
  DiskRead . . . . . . . . . . .	L Near	 F000	  _TEXT	
  DiskRead1  . . . . . . . . . .	L Near	 F003	  _TEXT	
  DiskReadend  . . . . . . . . .	L Near	 F02B	  _TEXT	
  HCStoLBA . . . . . . . . . . .	L Near	 F02C	  _TEXT	
  DiskFormat . . . . . . . . . .	L Near	 F04A	  _TEXT	
  DiskInit . . . . . . . . . . .	L Near	 F04A	  _TEXT	
  DiskSeek . . . . . . . . . . .	L Near	 F04A	  _TEXT	
  DiskRst  . . . . . . . . . . .	L Near	 F04A	  _TEXT	
  DiskReady  . . . . . . . . . .	L Near	 F04A	  _TEXT	
  DiskRecalibrate  . . . . . . .	L Near	 F04A	  _TEXT	
  DiskDiag . . . . . . . . . . .	L Near	 F04A	  _TEXT	
  DiskExtSeek  . . . . . . . . .	L Near	 F04A	  _TEXT	
  notready . . . . . . . . . . .	L Near	 F056	  _TEXT	
  DiskGetParams  . . . . . . . .	L Near	 F059	  _TEXT	
  dgpok  . . . . . . . . . . . .	L Near	 F081	  _TEXT	
  DiskExtVerify  . . . . . . . .	L Near	 F090	  _TEXT	
  DiskExtWrite . . . . . . . . .	L Near	 F095	  _TEXT	
  DiskExtRead  . . . . . . . . .	L Near	 F09A	  _TEXT	
  DiskExtRead1 . . . . . . . . .	L Near	 F09D	  _TEXT	
  DiskExtGetParams . . . . . . .	L Near	 F0CC	  _TEXT	
  DiskReadSectBuffer . . . . . .	L Near	 F119	  _TEXT	
  DiskWriteSectBuffer  . . . . .	L Near	 F119	  _TEXT	
  DiskSetDASDType  . . . . . . .	L Near	 F119	  _TEXT	
  DiskSetMediaType . . . . . . .	L Near	 F119	  _TEXT	
  DiskExtLock  . . . . . . . . .	L Near	 F119	  _TEXT	
  DiskExtEject . . . . . . . . .	L Near	 F119	  _TEXT	
int14  . . . . . . . . . . . . .	P Near	 F11C	  _TEXT	Length= 0081 Public
  SExit  . . . . . . . . . . . .	L Near	 F143	  _TEXT	
  SetCharFormat  . . . . . . . .	L Near	 F147	  _TEXT	
  Baud110  . . . . . . . . . . .	L Near	 F160	  _TEXT	
  GetPortStatus  . . . . . . . .	L Near	 F176	  _TEXT	
  GetPortStatus1 . . . . . . . .	L Near	 F179	  _TEXT	
  STransmit  . . . . . . . . . .	L Near	 F180	  _TEXT	
  STr1 . . . . . . . . . . . . .	L Near	 F183	  _TEXT	
  STr2 . . . . . . . . . . . . .	L Near	 F18E	  _TEXT	
  SReceive . . . . . . . . . . .	L Near	 F191	  _TEXT	
  SReceive1  . . . . . . . . . .	L Near	 F192	  _TEXT	
int16  . . . . . . . . . . . . .	P Near	 F427	  _TEXT	Length= 00EB Public
  kbfunc . . . . . . . . . . . .	L Near	 F44F	  _TEXT	
  Exit . . . . . . . . . . . . .	L Near	 F451	  _TEXT	
  GetKey1  . . . . . . . . . . .	L Near	 F454	  _TEXT	
  GetKey . . . . . . . . . . . .	L Near	 F455	  _TEXT	
  noWrap . . . . . . . . . . . .	L Near	 F46B	  _TEXT	
  TestKey  . . . . . . . . . . .	L Near	 F471	  _TEXT	
  StoreKey . . . . . . . . . . .	L Near	 F480	  _TEXT	
  NoWrap1  . . . . . . . . . . .	L Near	 F492	  _TEXT	
  ExtStatus  . . . . . . . . . .	L Near	 F4A1	  _TEXT	
  NoSysReq . . . . . . . . . . .	L Near	 F4AC	  _TEXT	
  GetStatus  . . . . . . . . . .	L Near	 F4B5	  _TEXT	
  Exit1  . . . . . . . . . . . .	L Near	 F4B8	  _TEXT	
  SetAutoRpt . . . . . . . . . .	L Near	 F4BA	  _TEXT	
  timeout1 . . . . . . . . . . .	L Near	 F4F0	  _TEXT	
  timeout  . . . . . . . . . . .	L Near	 F4F5	  _TEXT	
  WaitFlag . . . . . . . . . . .	L Near	 F4F8	  _TEXT	
  wf_loop  . . . . . . . . . . .	L Near	 F4FD	  _TEXT	
  wf_ok  . . . . . . . . . . . .	L Near	 F511	  _TEXT	
int18  . . . . . . . . . . . . .	P Near	 F512	  _TEXT	Length= 007F Public
  sloop  . . . . . . . . . . . .	L Near	 F53C	  _TEXT	
int19  . . . . . . . . . . . . .	P Near	 F591	  _TEXT	Length= 001A Public
  int19err . . . . . . . . . . .	L Near	 F5A9	  _TEXT	
int1a  . . . . . . . . . . . . .	P Near	 F5AB	  _TEXT	Length= 002C Public
  clockexit1 . . . . . . . . . .	L Near	 F5C1	  _TEXT	
  clockexit  . . . . . . . . . .	L Near	 F5C6	  _TEXT	
  setclock . . . . . . . . . . .	L Near	 F5CC	  _TEXT	
int70  . . . . . . . . . . . . .	P Near	 F5D7	  _TEXT	Length= 0038 Public
  exit1  . . . . . . . . . . . .	L Near	 F5FD	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 F603	  _TEXT	
int74  . . . . . . . . . . . . .	P Near	 F60F	  _TEXT	Length= 004F Public
  docall . . . . . . . . . . . .	L Near	 F634	  _TEXT	
  nocall . . . . . . . . . . . .	L Near	 F653	  _TEXT	
sdinit . . . . . . . . . . . . .	P Near	 F8D5	  _TEXT	Length= 009D Public
  sdinit1  . . . . . . . . . . .	L Near	 F8E0	  _TEXT	
  repinit  . . . . . . . . . . .	L Near	 F910	  _TEXT	
  sdexit . . . . . . . . . . . .	L Near	 F964	  _TEXT	
sdrblk . . . . . . . . . . . . .	P Near	 F77F	  _TEXT	Length= 0030 Public
  sdrblk1  . . . . . . . . . . .	L Near	 F787	  _TEXT	
  sdrblk2  . . . . . . . . . . .	L Near	 F78C	  _TEXT	
sdwblk . . . . . . . . . . . . .	P Near	 F74C	  _TEXT	Length= 0033 Public
  sdwblk1  . . . . . . . . . . .	L Near	 F74E	  _TEXT	
sendcmd  . . . . . . . . . . . .	P Near	 F6C9	  _TEXT	Length= 0011 Public
  retry  . . . . . . . . . . . .	L Near	 F6D0	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 F6D9	  _TEXT	
sendps2byte  . . . . . . . . . .	P Near	 F68A	  _TEXT	Length= 0025 Public
  sps2b2 . . . . . . . . . . . .	L Near	 F690	  _TEXT	
  sps2b1 . . . . . . . . . . . .	L Near	 F6A1	  _TEXT	
  sps2_kb  . . . . . . . . . . .	L Near	 F6A9	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 F6AD	  _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0001h	 
@code  . . . . . . . . . . . . .	Text   	 DGROUP
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
AckReceived  . . . . . . . . . .	Number	 0010h	 
ActivePage . . . . . . . . . . .	Text   	 ds:[62h]
ActiveVideoMode  . . . . . . . .	Text   	 ds:[49h]
AltDown  . . . . . . . . . . . .	Number	 0008h	 
AltKpd . . . . . . . . . . . . .	Text   	 ds:[19h]
Buffer . . . . . . . . . . . . .	Text   	 ds:[80h]
COMFlush . . . . . . . . . . . .	L Near	 E217	  _TEXT	
CapsLockDown . . . . . . . . . .	Number	 0040h	 
CapsLockLED  . . . . . . . . . .	Number	 0004h	 
CapsLock . . . . . . . . . . . .	Number	 0040h	 
ComPort  . . . . . . . . . . . .	Number	 0000h	 
CrtMode  . . . . . . . . . . . .	Text   	 ds:[65h]
CrtPalette . . . . . . . . . . .	Text   	 ds:[66h]
CtrlBreak  . . . . . . . . . . .	Text   	 ds:[71h]
CtrlDown . . . . . . . . . . . .	Number	 0004h	 
CursorPos  . . . . . . . . . . .	Text   	 ds:[50h]
CursorShape  . . . . . . . . . .	Text   	 ds:[60h]
DLH  . . . . . . . . . . . . . .	Number	 0001h	 
DLL  . . . . . . . . . . . . . .	Number	 0000h	 
DataBuffer . . . . . . . . . . .	Text   	 ds:[0a5h]
DataCounter  . . . . . . . . . .	Text   	 ds:[067h]
E0KeyIndex . . . . . . . . . . .	L Near	 FC71	  _TEXT	
E0KeyList  . . . . . . . . . . .	L Near	 FC65	  _TEXT	
EgaMiscInfo2 . . . . . . . . . .	Text   	 ds:[88h]
EgaMiscInfo  . . . . . . . . . .	Text   	 ds:[87h]
EndBuf . . . . . . . . . . . . .	Text   	 ds:[82h]
EquipmentWord  . . . . . . . . .	Text   	 ds:[10h]
ExtSize  . . . . . . . . . . . .	L Near	 F2F5	  _TEXT	
FreeXMSKb  . . . . . . . . . . .	Number	 7B60h	 
GetConfig  . . . . . . . . . . .	L Near	 F2FA	  _TEXT	
HDLastError  . . . . . . . . . .	Text   	 ds:[74h]
HDOpStarted  . . . . . . . . . .	Text   	 ds:[92h]
HDSize . . . . . . . . . . . . .	Text   	 ds:[94h]
HandlerPtr . . . . . . . . . . .	Text   	 ds:[0a1h]
HeadPtr  . . . . . . . . . . . .	Text   	 ds:[1ah]
IER  . . . . . . . . . . . . . .	Number	 0001h	 
IncSeg1  . . . . . . . . . . . .	L Near	 F1AB	  _TEXT	
IncSeg . . . . . . . . . . . . .	L Near	 F19D	  _TEXT	
InsDown  . . . . . . . . . . . .	Number	 0080h	 
Insert . . . . . . . . . . . . .	Number	 0080h	 
KbdFlags1  . . . . . . . . . . .	Text   	 ds:[17h]
KbdFlags2  . . . . . . . . . . .	Text   	 ds:[18h]
KbdFlags3  . . . . . . . . . . .	Text   	 ds:[96h]
KbdFlags4  . . . . . . . . . . .	Text   	 ds:[97h]
KeyCode  . . . . . . . . . . . .	L Near	 FC7D	  _TEXT	
KeyIndex . . . . . . . . . . . .	L Near	 FC0C	  _TEXT	
LAltDown . . . . . . . . . . . .	Number	 0002h	 
LCR  . . . . . . . . . . . . . .	Number	 0003h	 
LCtrDown . . . . . . . . . . . .	Number	 0001h	 
LEDUpdate  . . . . . . . . . . .	Number	 0040h	 
LSR  . . . . . . . . . . . . . .	Number	 0005h	 
LShfDown . . . . . . . . . . . .	Number	 0002h	 
LastE0 . . . . . . . . . . . . .	Number	 0002h	 
LastE1 . . . . . . . . . . . . .	Number	 0001h	 
LastF0 . . . . . . . . . . . . .	Number	 0020h	 
MSR  . . . . . . . . . . . . . .	Number	 0006h	 
MemorySize . . . . . . . . . . .	Text   	 ds:[13h]
Mouse  . . . . . . . . . . . . .	L Near	 F303	  _TEXT	
MovExt1  . . . . . . . . . . . .	L Near	 F217	  _TEXT	
MovExt2  . . . . . . . . . . . .	L Near	 F229	  _TEXT	
MovExtLoop . . . . . . . . . . .	L Near	 F20E	  _TEXT	
MovExtProxy  . . . . . . . . . .	L Near	 F26A	  _TEXT	
MovExt_exit  . . . . . . . . . .	L Near	 F252	  _TEXT	
MovExt_next  . . . . . . . . . .	L Near	 F23C	  _TEXT	
MovExt . . . . . . . . . . . . .	L Near	 F1CB	  _TEXT	
MovSeg . . . . . . . . . . . . .	Number	 0001h	 
NumLockDown  . . . . . . . . . .	Number	 0020h	 
NumLockLED . . . . . . . . . . .	Number	 0002h	 
NumLock  . . . . . . . . . . . .	Number	 0020h	 
PacketSize . . . . . . . . . . .	Text   	 ds:[068h]
PageOffset . . . . . . . . . . .	Text   	 ds:[4eh]
Pal256 . . . . . . . . . . . . .	L Near	 F99C	  _TEXT	
PalEGA . . . . . . . . . . . . .	L Near	 FA6C	  _TEXT	
PalOffset  . . . . . . . . . . .	Text   	 ds:[69h]
PalVGA . . . . . . . . . . . . .	L Near	 FB3C	  _TEXT	
Pause  . . . . . . . . . . . . .	Number	 0008h	 
PortAddress  . . . . . . . . . .	Text   	 ds:[63h]
RAMSize  . . . . . . . . . . . .	Number	 0200h	 
RAltDown . . . . . . . . . . . .	Number	 0008h	 
RBR  . . . . . . . . . . . . . .	Number	 0000h	 
RCtrDown . . . . . . . . . . . .	Number	 0004h	 
RShfDown . . . . . . . . . . . .	Number	 0001h	 
RegenLength  . . . . . . . . . .	Text   	 ds:[4ch]
SCANCODE1  . . . . . . . . . . .	Number	 0001h	 
SD_CMD0  . . . . . . . . . . . .	Byte	 F972	  _TEXT	
SD_CMD12 . . . . . . . . . . . .	Byte	 F984	  _TEXT	
SD_CMD41 . . . . . . . . . . . .	Byte	 F98A	  _TEXT	
SD_CMD55 . . . . . . . . . . . .	Byte	 F990	  _TEXT	
SD_CMD58 . . . . . . . . . . . .	Byte	 F996	  _TEXT	
SD_CMD8  . . . . . . . . . . . .	Byte	 F978	  _TEXT	
SD_CMD9  . . . . . . . . . . . .	Byte	 F97E	  _TEXT	
ScanLinesChar  . . . . . . . . .	Text   	 ds:[85h]
ScrLockDown  . . . . . . . . . .	Number	 0010h	 
ScrLockLED . . . . . . . . . . .	Number	 0001h	 
ScrLock  . . . . . . . . . . . .	Number	 0010h	 
ScreenRows . . . . . . . . . . .	Text   	 ds:[84h]
ScreenWidth  . . . . . . . . . .	Text   	 ds:[4ah]
SetEventWait . . . . . . . . . .	L Near	 F2A7	  _TEXT	
SetRepeat  . . . . . . . . . . .	Number	 0008h	 
SetSeg1  . . . . . . . . . . . .	L Near	 F1C3	  _TEXT	
SetSeg2  . . . . . . . . . . . .	L Near	 F1BB	  _TEXT	
SetSegExit . . . . . . . . . . .	L Near	 F1C4	  _TEXT	
SetSeg . . . . . . . . . . . . .	L Near	 F1B0	  _TEXT	
SysParams  . . . . . . . . . . .	Byte	 F41D	  _TEXT	
SysReqDown . . . . . . . . . . .	Number	 0004h	 
THR  . . . . . . . . . . . . . .	Number	 0000h	 
TailPtr  . . . . . . . . . . . .	Text   	 ds:[1ch]
UFPtr  . . . . . . . . . . . . .	Text   	 ds:[98h]
UWaitFlag  . . . . . . . . . . .	Text   	 ds:[0a0h]
VESAInfo . . . . . . . . . . . .	Byte	 E66C	  _TEXT	
VESAModes  . . . . . . . . . . .	Word	 E693	  _TEXT	
VESAOEM  . . . . . . . . . . . .	Byte	 E680	  _TEXT	
VgaFlags2  . . . . . . . . . . .	Text   	 ds:[8ah]
VgaFlags . . . . . . . . . . . .	Text   	 ds:[89h]
Wait1  . . . . . . . . . . . . .	L Near	 F2DC	  _TEXT	
WaitCount  . . . . . . . . . . .	Text   	 ds:[9ch]
badparam . . . . . . . . . . . .	L Near	 F384	  _TEXT	
bioscont . . . . . . . . . . . .	Byte	 E27E	  _TEXT	
biosmsg  . . . . . . . . . . . .	Byte	 E000	  _TEXT	
bios . . . . . . . . . . . . . .	L Near	 E000	  _TEXT	
booterrmsg . . . . . . . . . . .	Byte	 F54A	  _TEXT	
busy . . . . . . . . . . . . . .	L Near	 F2D8	  _TEXT	
cancel . . . . . . . . . . . . .	L Near	 F2D1	  _TEXT	
coldboot . . . . . . . . . . . .	L Near	 E05B	  _TEXT	
crtc12 . . . . . . . . . . . . .	Byte	 E6BF	  _TEXT	
crtc13 . . . . . . . . . . . . .	Byte	 E6D4	  _TEXT	
crtc9  . . . . . . . . . . . . .	Byte	 E6AA	  _TEXT	
dac10  . . . . . . . . . . . . .	Byte	 E6E9	  _TEXT	
dccval . . . . . . . . . . . . .	Word	 EE6E	  _TEXT	
disablemouseinterrupt  . . . . .	L Near	 F403	  _TEXT	
disktbl  . . . . . . . . . . . .	Word	 EF7A	  _TEXT	
dispAX1  . . . . . . . . . . . .	L Near	 F71B	  _TEXT	
dispAX . . . . . . . . . . . . .	L Near	 F70C	  _TEXT	
dly1 . . . . . . . . . . . . . .	L Near	 F681	  _TEXT	
dlybit . . . . . . . . . . . . .	L Near	 F67D	  _TEXT	
done . . . . . . . . . . . . . .	L Near	 F29E	  _TEXT	
en_dis . . . . . . . . . . . . .	L Near	 F357	  _TEXT	
enablemouseinterrupt . . . . . .	L Near	 F3F0	  _TEXT	
errexit  . . . . . . . . . . . .	L Near	 F314	  _TEXT	
exit15 . . . . . . . . . . . . .	L Near	 F29F	  _TEXT	
exit_ax  . . . . . . . . . . . .	L Near	 F2A2	  _TEXT	
exit_iret  . . . . . . . . . . .	L Near	 F2A6	  _TEXT	
exit_success1  . . . . . . . . .	L Near	 F36C	  _TEXT	
exit_success . . . . . . . . . .	L Near	 F367	  _TEXT	
exitok . . . . . . . . . . . . .	L Near	 F315	  _TEXT	
extend . . . . . . . . . . . . .	L Near	 F3C2	  _TEXT	
flush1 . . . . . . . . . . . . .	L Near	 F6F4	  _TEXT	
flush_nostack  . . . . . . . . .	L Near	 F6EC	  _TEXT	
flushbh  . . . . . . . . . . . .	Word	 F70A	  _TEXT	
flushret . . . . . . . . . . . .	Word	 F708	  _TEXT	
flush  . . . . . . . . . . . . .	L Near	 F6E7	  _TEXT	
font8x14 . . . . . . . . . . . .	Text   	 font8x16 - 0e00h
font8x16 . . . . . . . . . . . .	Text   	 font8x8 - 1000h
font8x8  . . . . . . . . . . . .	Text   	 bios - 800h
fontinfo . . . . . . . . . . . .	Word	 EDFC	  _TEXT	
gettype  . . . . . . . . . . . .	L Near	 F3AA	  _TEXT	
if_err1  . . . . . . . . . . . .	L Near	 F365	  _TEXT	
if_err . . . . . . . . . . . . .	L Near	 F30F	  _TEXT	
int15  . . . . . . . . . . . . .	L Near	 F26D	  _TEXT	
kbi1 . . . . . . . . . . . . . .	L Near	 E17A	  _TEXT	
kbi2 . . . . . . . . . . . . . .	L Near	 E189	  _TEXT	
kbok . . . . . . . . . . . . . .	L Near	 E1BD	  _TEXT	
l1 . . . . . . . . . . . . . . .	L Near	 F672	  _TEXT	
mapi1  . . . . . . . . . . . . .	L Near	 E0A8	  _TEXT	
mapi . . . . . . . . . . . . . .	L Near	 E09F	  _TEXT	
mouse_present  . . . . . . . . .	L Near	 F324	  _TEXT	
mousei0  . . . . . . . . . . . .	L Near	 E1C5	  _TEXT	
mousei1  . . . . . . . . . . . .	L Near	 E1D3	  _TEXT	
mouseok  . . . . . . . . . . . .	L Near	 E1EF	  _TEXT	
msgkb  . . . . . . . . . . . . .	Byte	 E042	  _TEXT	
msgmb  . . . . . . . . . . . . .	Byte	 E035	  _TEXT	
msgmouse . . . . . . . . . . . .	Byte	 E269	  _TEXT	
nokbmsg  . . . . . . . . . . . .	L Near	 E24E	  _TEXT	
nokb . . . . . . . . . . . . . .	L Near	 E1B8	  _TEXT	
nomousemsg . . . . . . . . . . .	L Near	 E25B	  _TEXT	
nomouse  . . . . . . . . . . . .	L Near	 E1E6	  _TEXT	
nowait . . . . . . . . . . . . .	L Near	 F2D9	  _TEXT	
p3c0r10  . . . . . . . . . . . .	Byte	 E6A9	  _TEXT	
paltable . . . . . . . . . . . .	Word	 EB49	  _TEXT	
prtse  . . . . . . . . . . . . .	L Near	 F731	  _TEXT	
prts . . . . . . . . . . . . . .	L Near	 F725	  _TEXT	
raligned . . . . . . . . . . . .	L Near	 F235	  _TEXT	
reset  . . . . . . . . . . . . .	L Near	 F370	  _TEXT	
resolution . . . . . . . . . . .	L Near	 F3A0	  _TEXT	
sample_tbl . . . . . . . . . . .	Byte	 F416	  _TEXT	
sampling . . . . . . . . . . . .	L Near	 F381	  _TEXT	
savesp . . . . . . . . . . . . .	Word	 F1C7	  _TEXT	
savess . . . . . . . . . . . . .	Word	 F1C5	  _TEXT	
sc1  . . . . . . . . . . . . . .	Byte	 E6FE	  _TEXT	
sdcmd1 . . . . . . . . . . . . .	L Near	 F7D6	  _TEXT	
sdcmd8T  . . . . . . . . . . . .	L Near	 F7C0	  _TEXT	
sdcmd  . . . . . . . . . . . . .	L Near	 F7C3	  _TEXT	
sdr11  . . . . . . . . . . . . .	L Near	 F84B	  _TEXT	
sdr1s  . . . . . . . . . . . . .	L Near	 F7EB	  _TEXT	
sdr1 . . . . . . . . . . . . . .	L Near	 F84C	  _TEXT	
sdr2 . . . . . . . . . . . . . .	L Near	 F842	  _TEXT	
sdr3 . . . . . . . . . . . . . .	L Near	 F835	  _TEXT	
sdrb . . . . . . . . . . . . . .	L Near	 F732	  _TEXT	
sdread1  . . . . . . . . . . . .	L Near	 F7DF	  _TEXT	
sdread . . . . . . . . . . . . .	L Near	 F7DC	  _TEXT	
sdresp1  . . . . . . . . . . . .	L Near	 F7CB	  _TEXT	
sdresp . . . . . . . . . . . . .	L Near	 F7C9	  _TEXT	
sdrms  . . . . . . . . . . . . .	L Near	 F80C	  _TEXT	
sdsb . . . . . . . . . . . . . .	L Near	 F734	  _TEXT	
sdvblk1  . . . . . . . . . . . .	L Near	 F7B2	  _TEXT	
sdvblk . . . . . . . . . . . . .	L Near	 F7AF	  _TEXT	
sdverify . . . . . . . . . . . .	L Near	 F7D7	  _TEXT	
sdw1s1 . . . . . . . . . . . . .	L Near	 F89B	  _TEXT	
sdw1s  . . . . . . . . . . . . .	L Near	 F863	  _TEXT	
sdwms  . . . . . . . . . . . . .	L Near	 F884	  _TEXT	
sdwrite  . . . . . . . . . . . .	L Near	 F857	  _TEXT	
sdwwait1 . . . . . . . . . . . .	L Near	 F8CB	  _TEXT	
sdwwait  . . . . . . . . . . . .	L Near	 F8B4	  _TEXT	
send1c . . . . . . . . . . . . .	L Near	 F39A	  _TEXT	
send2c . . . . . . . . . . . . .	L Near	 F393	  _TEXT	
setscaling . . . . . . . . . . .	L Near	 F3E5	  _TEXT	
srecb  . . . . . . . . . . . . .	L Near	 F65E	  _TEXT	
srstb  . . . . . . . . . . . . .	L Near	 F666	  _TEXT	
staticfunctable  . . . . . . . .	Byte	 EED3	  _TEXT	
ten  . . . . . . . . . . . . . .	Word	 F723	  _TEXT	
vidtbl . . . . . . . . . . . . .	Word	 EEE3	  _TEXT	
warmboot . . . . . . . . . . . .	L Near	 E05B	  _TEXT	
wbusy  . . . . . . . . . . . . .	L Near	 F2F1	  _TEXT	
wloop  . . . . . . . . . . . . .	L Near	 F2EA	  _TEXT	

	   0 Warnings
	   0 Errors
