Microsoft (R) Macro Assembler Version 6.14.8444		    08/21/22 22:05:47
BIOS_Next186.asm					     Page 1 - 1


				; This file is part of the Next186 SoC PC project
				; http://opencores.org/project,next186

				; Filename: BIOS_Next186.asm
				; Description: Part of the Next186 SoC PC project, ROM BIOS code
				; Version 1.0
				; Creation date: Feb-Jun 2013

				; Author: Nicolae Dumitrache 
				; e-mail: ndumitrache@opencores.org

				; -------------------------------------------------------------------------------------
				 
				; Copyright (C) 2013 Nicolae Dumitrache
				 
				; This source file may be used and distributed without 
				; restriction provided that this copyright statement is not 
				; removed from the file and that any derivative work contains 
				; the original copyright notice and the associated disclaimer.
				 
				; This source file is free software; you can redistribute it 
				; and/or modify it under the terms of the GNU Lesser General 
				; Public License as published by the Free Software Foundation;
				; either version 2.1 of the License, or (at your option) any 
				; later version. 
				 
				; This source is distributed in the hope that it will be 
				; useful, but WITHOUT ANY WARRANTY; without even the implied 
				; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
				; PURPOSE. See the GNU Lesser General Public License for more 
				; details. 
				 
				; You should have received a copy of the GNU Lesser General 
				; Public License along with this source; if not, download it 
				; from http://www.opencores.org/lgpl.shtml 
				 
				; -----------------------------------------------------------------------

				; Additional Comments: 
				; Assembled with MASM v6.14.8444
				; Next186 SoC PC have no ROM, only RAM. The bootstrap code is the initial value of cache 
				;  (last half 1K = 4 lines of 256bytes each), initially marked as "dirty", in order to
				;  be saved in RAM at first flush
				; The bootstrap code may load the BIOS from SD, or from RS232, and place it at F000:E000



				.186
				.model tiny
 0000				.code

 = 0001				SCANCODE1   equ 1

				;-------------------------- BIOS data area (BDA) -----------------
				;40:0000   2  Base port address of first RS-232 adapter (COM1) See COM Ports
				;40:0002   2  Port of COM2
				;40:0004   2  Port of COM3
				;40:0006   2  Port of COM4
				;40:0008   2  Base port addr of first parallel printer (LPT1)  Printer Ports
				;40:000A   2  Port of LPT2
				;40:000C   2  Port of LPT3
				;40:000E   2  Port of LPT4
				;40:0010   2  Equipment/hardware installed/active; see Equipment List
				;40:0012   1  Errors in PCjr infrared keyboard link
				;40:0013   2  Total memory in K-bytes (same as obtained via INT 12H)
				;40:0015   2  Scratch pad for manufacturing error tests
				;
				;40:0017   2  Keyboard status bits; see Keyboard Shift Status Flags
				;40:0019   1  Current (accumulating) value of Alt+numpad pseudo-key input;
				;             normally 0.  When [Alt] is released, value is stored in
				;             keyboard buffer at 001e.
				;40:001a   2  Addr of keyboard buffer head (keystroke at that addr is next)
				;40:001c   2  Address of keyboard buffer tail
				;40:001e  32  Keyboard buffer.  BIOS stores keystrokes here (head and tail
				;             point to addresses from 041eH to 043dH inclusive).
				;
				;40:003e   1  Diskette drive needs recalibration (bit 0=A, bit 1=B, etc.)
				;             bits 4-5 indicate which drive is currently selected
				;40:003f   1  Diskette motor is running (bit 0=drive A, bit 1=B, etc.)
				;40:0040   1  Time until motor off. INT 08H turns motor off when this is 0.
				;40:0041   1  Diskette error status; same as status returned by INT 13H
				;40:0042   7  Diskette controller status information area
				;
				;40:0049   1  Current active video mode.  See Video Modes and INT 10H.
				;40:004a   2  Screen width in text columns
				;40:004c   2  Length (in bytes) of video area (regen size)
				;40:004e   2  Offset from video segment of active video memory page
				;40:0050  16  Cursor location (8 byte-pairs; low byte=clm, hi byte=row)
				;40:0060   2  Cursor size/shape.  Low byte=end scan line; hi byte=start line.
				;40:0062   1  Current active video page number
				;40:0063   2  Port address for 6845 video controller chip; see CGA I/O Ports
				;40:0065   1  Current value of 6845 video ctrlr CRT_MODE (port 3x8H register)
				;40:0066   1  Current value of 6845 video ctrlr CRT_PALETTE (port 3x9H reg)
				;
				;40:0067   5  Cassette data area or POST data area
				;               40:0067: 1 byte mouse buffer counter (DataCounter)
				;               40:0068: 1 byte mouse packet size (PacketSize): 0 for 3 bytes, 1 for 4 bytes (Intellimouse)
				;				40:0069: 2 bytes palette offset during set video mode	
				;
				;40:006c   4  Timer tick counter (count of 55ms ticks since CPU reset)
				;40:0070   1  Timer overflow flag (timer has rolled over 24 hr)
				;40:0071   1  Ctrl-Break flag.  Bit 7=1 when break was pressed.  This never
				;             gets reset unless you do it yourself.
				;
				;40:0072   2  1234H means Ctrl+Alt+Del reboot is in progress.  BIOS checks
				;             this to avoid doing a "cold boot" with the time-consuming POST
				;             4321H means reset, preserving memory
				;             5678H, 9abcH, and abcdH (are internal PC Convertible codes)
				;
				;40:0074   4  PCjr diskette or AT hard disk control area
				;  (0074)   1 Status of last fixed-disk drive operation
				;  (0075)   1 Number of hard disk drives for AT
				;  (0077)   1 Hard disk port for XT.  See XT Hard Disk Ports.
				;40:0078   4  Printer time-out values (478H=Lpt1, 478H=Lpt2...)
				;40:007c   4  RS-232 time-out values  (47cH=Com1, 47dH=Com2...)
				;
				;40:0080   2  AT PS/2 keyboard buffer offset start address (usually 01eH)
				;40:0082   2                                   end address (usually 003eH)
				;
				;40:0084   1  EGA text rows-1  (maximum valid row value)
				;40:0085   2  EGA bytes per character (scan-lines/char used in active mode)
				;40:0087   1  EGA flags; see EgaMiscInfoRec
				;40:0088   1  EGA flags; see EgaMiscInfo2Rec
				;40:0089   1  VGA flags; see VgaFlagsRec
				;             See also:  EGA/VGA Data Areas
				;
				;40:008b   1  AT PS/2 Media control: data rate, step rate
				;40:008c   1  AT PS/2 Hard disk drive controller status
				;40:008d   1  AT PS/2 Hard disk drive error status
				;40:008e   1  AT PS/2 Hard disk drive interrupt control
				;
				;40:0090   1  AT PS/2 Disk media state bits for drive 0
				;40:0091   1                                for drive 1
				;40:0092   1  AT PS/2 Disk operation started flag for drive 0
				;40:0093   1                                      for drive 1

				;40:0094   1  AT PS/2 Present cylinder number for drive 0
				;40:0095   1                                  for drive 1
						; 2 - Number of 512bytes sectors of HD0
				;
				;40:0096   1  AT Keyboard flag bit 4=1 (10H) if 101-key keyboard is attached
				;40:0097   1  AT Keyboard flag for LED 'key lock' display
				;             bits 0-2 are ScrollLock, NumLock, CapsLock
				;
				;40:0098   4  AT Pointer to 8-bit user wait flag; see INT 15H 86H
				;40:009c   4  AT Microseconds before user wait is done
				;40:00a0   1  AT User wait activity flag:
				;                01H=busy, 80H=posted, 00H=acknowledged
				;
				;40:00a1   7  AT Reserved for network adapters
				;               40:00a1: 4 bytes far pointer to mouse callback (HandlerPtr)
				;               40:00a5: 3 bytes mouse buffer (DataBuffer)
				;
				;40:00a8   4  EGA Address of table of pointers; see EgaSavePtrRec
				;40:00ac  68  Reserved
				;40:00f0  16  (IAC) Inter-Aapplication Communication area.  Programs may use
				;             this area to store status, etc.  Might get overwritten by
				;             another program.

				; http://www.ctyme.com/intr/int.htm

				; video memory: 8 physical segments at 0a000h, 0b000h, 0c000h, 0d000h, 0e000h, 0f000h, 10000h, 11000h
				; Memory segments mapping
				; 1Mb virtual seg address   physical seg address
				;       0000h                   0000h
				;       1000h                   1000h
				;       2000h                   2000h
				;       3000h                   3000h
				;       4000h                   4000h
				;       5000h                   5000h
				;       6000h                   6000h
				;       7000h                   7000h
				;       8000h                   8000h
				;       9000h                   9000h
				;       a000h                   a000h       - video
				;       b000h                   b000h       - video
				;       c000h                   12000h
				;       d000h                   13000h
				;       e000h                   14000h
				;       f000h                   15000h


 = 0200				RAMSize   equ    200h        ; 64KB segments

				; Graphics character set
 = bios - 800h			font8x8		equ	bios - 800h        
 = font8x8 - 1000h		font8x16	equ	font8x8 - 1000h    
 = font8x16 - 0e00h		font8x14	equ	font8x16 - 0e00h


						org 0c000h
 C000				bios:        
 C000 4E 65 78 74 31 38		biosmsg     db 'Next186 MiST SoC PC BIOS (C) 2017 Nicolae Dumitrache', 0
       36 20 4D 69 53 54
       20 53 6F 43 20 50
       43 20 42 49 4F 53
       20 28 43 29 20 32
       30 31 37 20 4E 69
       63 6F 6C 61 65 20
       44 75 6D 69 74 72
       61 63 68 65 00
 C035 4D 42 20 53 44 20		msgmb       db 'MB SD Card', 13, 10, 0
       43 61 72 64 0D 0A
       00
 C042 50 53 32 20 4B 42		msgkb       db 'PS2 KB detected', 13, 10, 0
       20 64 65 74 65 63
       74 65 64 0D 0A 00

						org 0c05bh
 C05B				coldboot:
 C05B				warmboot:
 C05B  FA					cli
 C05C  FC					cld
 C05D  B8 0030					mov     ax, 30h
 C060  8E D0					mov     ss, ax
 C062  BC 0100					mov     sp, 100h
						
 C065  6A 00					push    0
 C067  9D					popf
						
 C068  B0 36					mov     al, 36h
 C06A  E6 43					out     43h, al
 C06C  33 C0					xor     ax, ax
 C06E  E7 07			        out     7, ax       ; NMIonIORQ_HI = 0
 C070  E6 40					out     40h, al
 C072  E6 40					out     40h, al      ; 18Hz PIT CH0
 C074  E6 61					out     61h, al      ; speaker off
 C076  F6 D0					not     al
 C078  E6 21					out     21h, al      ; disable all interrupts
 C07A  E6 A1					out		0a1h, al
 C07C  E7 06			        out     6, ax       ; NMIonIORQ_LO = 255 -> disabled
						

				; ------------------ MAP init
 C07E  B8 0015					mov     ax, 15h     ; BIOS physical segment 15h mapped on virtual segment 0ch
 C081  E7 8C					out     8ch, ax
 C083  68 C000					push    0c000h
 C086  07					pop     es
 C087  68 F000					push    0f000h
 C08A  1F					pop     ds
 C08B  33 F6					xor     si, si
 C08D  33 FF					xor     di, di
 C08F  B9 8000					mov     cx, 8000h
 C092  F3/ A5					rep     movsw       ; copy BIOS virtual segment 0fh over physical segment 15h

 C094  BA 0080					mov     dx, 80h      
 C097  33 C0					xor     ax, ax
 C099				mapi:        
 C099  EF					out     dx, ax
 C09A  40					inc     ax
 C09B  42					inc     dx
 C09C  3C 0C					cmp     al, 0ch
 C09E  75 02					jne     short mapi1
 C0A0  04 06					add     al, 6
 C0A2				mapi1:        
 C0A2  3C 16					cmp     al, 16h
 C0A4  75 F3					jne     short mapi
						
				; -------------------- Interrupt table init
 C0A6  6A 00					push    0
 C0A8  1F					pop     ds
 C0A9  1E					push    ds
 C0AA  07					pop     es
 C0AB  33 F6					xor     si, si
 C0AD  BF 0004					mov     di, 4
 C0B0  C7 04 D808 R				mov     word ptr [si], offset defint
 C0B4  8C 4C 02					mov     word ptr [si+2], cs
 C0B7  B9 00FE					mov     cx, 256-2
 C0BA  F3/ A5					rep     movsw
 C0BC  C7 06 001C C2F1 R			mov     word ptr ds:[7*4], offset int07
 C0C2  C7 06 0020 C321 R			mov     word ptr ds:[8*4], offset int08
 C0C8  C7 06 0024 C377 R			mov     word ptr ds:[9*4], offset int09
 C0CE  C7 06 0040 C59A R			mov     word ptr ds:[10h*4], offset int10        
 C0D4  C7 06 0044 D048 R			mov     word ptr ds:[11h*4], offset int11        
 C0DA  C7 06 0048 D051 R			mov     word ptr ds:[12h*4], offset int12        
 C0E0  C7 06 004C D05A R			mov     word ptr ds:[13h*4], offset int13        
 C0E6  C7 06 0050 D247 R			mov     word ptr ds:[14h*4], offset int14        
 C0EC  C7 06 0054 D392 R			mov     word ptr ds:[15h*4], offset int15
 C0F2  C7 06 0058 D54C R			mov     word ptr ds:[16h*4], offset int16
 C0F8  C7 06 0060 D637 R			mov     word ptr ds:[18h*4], offset int18
 C0FE  C7 06 0064 D6B3 R			mov     word ptr ds:[19h*4], offset int19
 C104  C7 06 0068 D6CD R			mov     word ptr ds:[1ah*4], offset int1a
 C10A  C7 06 01C0 D6F9 R			mov     word ptr ds:[70h*4], offset int70
 C110  C7 06 01D0 D731 R			mov     word ptr ds:[74h*4], offset int74

				; ------------------- BDA init
 C116  6A 40					push    40h
 C118  1F					pop     ds
 C119  1E					push    ds
 C11A  07					pop     es
 C11B  33 FF					xor     di, di
 C11D  33 F6					xor     si, si
 C11F  33 C0					xor     ax, ax
 C121  B1 80					mov     cl, 80h
 C123  F3/ AB					rep     stosw
 C125  C7 04 03F8				mov		word ptr [si+00h], 3f8h	 ; COM1 base port address
 C129  C7 44 08 0378				mov		word ptr [si+08h], 378h	 ; LPT1 base port address
 C12E  C6 44 10 24				mov     byte ptr [si+10h], 24h   ; equipment word (color 80x25, PS2 mouse present)
 C132  C7 44 13 0280				mov     word ptr [si+13h], 640   ; memory size in KB
 C137  83 44 1A 1E				add     word ptr [si+1ah], 1eh   ; next char pointer in kb buffer
 C13B  83 44 1C 1E				add     word ptr [si+1ch], 1eh   ; last char pointer in kb buffer
 C13F  C7 44 60 0E0F				mov     word ptr [si+60h], 0e0fh ; cursor shape
 C144  C7 44 63 03D4				mov     word ptr [si+63h], 3d4h  ; video port address
 C149  83 84 0080 1E				add     word ptr [si+80h], 1eh   ; start kb buffer
 C14E  83 84 0082 3E				add     word ptr [si+82h], 3eh   ; end kb buffer
 C153  C7 84 0087 0940				mov     word ptr [si+87h], 0940h ; video adapter options (512Kb video)
 C159  C7 84 0089 0B71				mov     word ptr [si+89h], 0b71h ; VGA video flags: 400 line text mode, default palette loading on (0), blinking on
 C15F  C6 84 0096 10				mov     byte ptr [si+96h], 10h   ; 101 keyboard installed
				 
				; ------------------- Graph mode init
 C164  B8 0003					mov     ax, 3
 C167  CD 10					int     10h

				 ; ------------------- KB init ----------------
 C169  B0 AE					mov     al, 0aeh
 C16B  E6 64					out     64h, al     ; enable kb
 C16D  B0 A7					mov     al, 0a7h
 C16F  E6 64					out     64h, al     ; disable mouse
 C171  B9 0019					mov     cx, 25
 C174				kbi1:       
 C174  E8 165A					call    getps2byte
 C177  E2 FB					loop    short kbi1  ; wait for kb timeout
 C179  B4 FF					mov     ah, 0ffh    ; reset kb
 C17B  F8					clc                 ; kb command
 C17C  E8 166C					call    sendcmd   
 C17F  72 31					jc      short nokb
 C181  B1 19					mov     cl, 25
 C183				kbi2:        
 C183  49					dec     cx
 C184  E3 2C					jcxz    short nokb
 C186  E8 1648					call    getps2byte
 C189  72 F8					jc      short kbi2  ; wait for BAT
 C18B  3C AA					cmp     al, 0aah
 C18D  75 23					jne     short nokb
 C18F  B4 F2					mov     ah, 0f2h    ; kb id
 C191  E8 1657					call    sendcmd     ; CF = 0
 C194  72 1C					jc      short nokb
 C196  E8 1638					call    getps2byte
 C199  3C AB					cmp     al, 0abh
 C19B  75 15					jne     short nokb
 C19D  E8 1631					call    getps2byte
 C1A0  3C 83					cmp     al, 83h
				; set scan code 1
				IFDEF SCANCODE1
 C1A2  75 0E					jne     short nokb
 C1A4  B4 F0					mov     ah, 0f0h    ; kb scan set
 C1A6  E8 1642					call    sendcmd   
 C1A9  72 07					jc      short nokb
 C1AB  B4 01					mov     ah, 1       ; scan set 1
 C1AD  E8 163B					call    sendcmd   
 C1B0  73 05					jnc     short kbok
				ELSE
				ENDIF        

 C1B2				nokb:   
 C1B2  C6 06 0096 00				mov     byte ptr KbdFlags3, 0   ; kb not present
 C1B7				kbok:
 C1B7  B0 AD					mov     al, 0adh
 C1B9  E6 64					out     64h, al      ; disable kb interface

				; ------------------- Mouse init ----------------
 C1BB  B0 A8					mov     al, 0a8h
 C1BD  E6 64					out     64h, al      ; enable mouse
 C1BF				mousei0:        
 C1BF  E8 160F					call    getps2byte
 C1C2  73 FB					jnc     short mousei0
 C1C4  B4 FF					mov     ah, 0ffh
 C1C6  E8 1622					call    sendcmd      ; reset mouse (CF = 1)
 C1C9  72 15					jc      short nomouse
 C1CB  B1 19					mov     cl, 25
 C1CD				mousei1:        
 C1CD  49					dec     cx
 C1CE  E3 10					jcxz    short nomouse
 C1D0  E8 15FE					call    getps2byte
 C1D3  72 F8					jc      short mousei1
 C1D5  3C AA					cmp     al, 0aah     ; BAT
 C1D7  75 07					jne     short nomouse
 C1D9  E8 15F5					call    getps2byte
 C1DC  3C 00					cmp     al, 0        ; mouse ID
 C1DE  74 09					je      short mouseok
 C1E0				nomouse:
 C1E0  B0 A7					mov     al, 0a7h        
 C1E2  E6 64					out     64h, al      ; disable mouse
 C1E4  80 26 0010 FB				and     byte ptr EquipmentWord, not 4 ; ps2 mouse not present in equipement word
 C1E9				mouseok:
 C1E9  E8 1610					call    enableKbIfPresent

 C1EC  B0 20					mov     al, 20h
 C1EE  E6 64					out     64h, al
 C1F0  E4 60					in      al, 60h
 C1F2  0C 03					or      al, 3
 C1F4  8A E0					mov     ah, al
 C1F6  B0 60					mov     al, 60h
 C1F8  E6 64					out     64h, al
 C1FA  8A C4					mov     al, ah
 C1FC  E6 60					out     60h, al     ; enable 8042 mouse and kb interrupts

 C1FE  B8 0000					mov     ax, 0		; 1000-1   ; 1ms
 C201  E7 70					out     70h, ax     ; set RTC frequency (stop)

				;		mov     al, 0
 C203  E6 21					out     21h, al     ; enable all PIC interrupts (8h, 9h, 0ch)
 C205  E6 A1					out		0a1h, al	; enable all PIC interrupts (70h, 74h)
 C207  E6 01					out		1, al		; intialize COM mux
 C209  FB					sti                 ; enable CPU interrupts

				; ---------------------- COM flush
 C20A  B4 03			        mov     ah, 3       ; get serial port status
 C20C  33 D2			        xor     dx, dx      ; COM1
 C20E				COMFlush:
 C20E  CD 14			        int     14h
 C210  D0 EC			        shr     ah, 1
 C212  B4 02			        mov     ah, 2
 C214  72 F8			        jc      short COMFlush

				; ---------------------   HDD init
 C216  E8 17B9					call    sdinit
 C219  A3 0094					mov     HDSize, ax
 C21C  0E					push    cs
 C21D  07					pop     es
 C21E  BE C000 R				mov     si, offset biosmsg
 C221  E8 15FE					call    prts
 C224  BE C275 R				mov     si, offset bioscont
 C227  E8 15F8					call    prts
 C22A  A1 0094					mov     ax, HDSize
 C22D  D1 E8					shr     ax, 1
 C22F  E8 15D7					call    dispAX
 C232  BE C035 R				mov     si, offset msgmb
 C235  E8 15EA					call    prts
 C238  F6 06 0096 10				test    byte ptr KbdFlags3, 10h
 C23D  74 06					jz      nokbmsg
 C23F  BE C042 R				mov     si, offset msgkb
 C242  E8 15DD					call    prts
 C245				nokbmsg:
 C245  F6 06 0010 04				test    byte ptr EquipmentWord, 4
 C24A  74 06					jz      nomousemsg
 C24C  BE C260 R				mov     si, offset msgmouse
 C24F  E8 15D0					call    prts
 C252				nomousemsg:

				;-------------- HD bootstrap
 C252  B8 00E3					mov		ax, 00e3h
 C255  CD 14					int		14h		; init COM to 9.6K, 8n1
 C257  B8 0305					mov     ax, 305h
 C25A  33 DB					xor     bx, bx
 C25C  CD 16					int     16h     ; set typematic rate and delay to fastest
 C25E  CD 19					int     19h

 C260 50 53 32 20 4D 6F		msgmouse    db 'PS2 Mouse detected', 13, 10, 0        
       75 73 65 20 64 65
       74 65 63 74 65 64
       0D 0A 00
 C275 0D 0A 43 50 55 3A		bioscont    db 13, 10, 'CPU: 80186 50Mhz (50MIPS, 100Mhz 32bit bus)', 13, 10
       20 38 30 31 38 36
       20 35 30 4D 68 7A
       20 28 35 30 4D 49
       50 53 2C 20 31 30
       30 4D 68 7A 20 33
       32 62 69 74 20 62
       75 73 29 0D 0A
 C2A4  52 41 4D 3A 20 33	            db 'RAM: 32MB SDR 100Mhz 16bit', 13, 10
       32 4D 42 20 53 44
       52 20 31 30 30 4D
       68 7A 20 31 36 62
       69 74 0D 0A
 C2C0  43 61 63 68 65 3A	            db 'Cache: 8KB, 4-way, 128x64 bytes data/inst', 13, 10
       20 38 4B 42 2C 20
       34 2D 77 61 79 2C
       20 31 32 38 78 36
       34 20 62 79 74 65
       73 20 64 61 74 61
       2F 69 6E 73 74 0D
       0A
 C2EB  48 44 30 3A 20 00				db 'HD0: ', 0

				; ---------------------------- INT 07 ---------------------
 C2F1				int07 proc near ; coprocessor ESC sequence
 C2F1  50					push    ax
 C2F2  53					push    bx
 C2F3  1E					push    ds
 C2F4  55					push    bp
 C2F5  8B EC					mov     bp, sp
 C2F7  C5 5E 08					lds     bx, [bp+8]  
 C2FA				int07_pfx:        
 C2FA  8A 07					mov     al, [bx]
 C2FC  43					inc     bx
 C2FD  24 F8					and     al, 0f8h
 C2FF  3C D8					cmp     al, 0d8h        ; ESC code
 C301  75 F7					jne     short int07_pfx
							  
 C303  80 3F C0					cmp     byte ptr [bx], 0c0h ; mod reg r/m of ESC 8087 instruction
 C306  1A C0					sbb     al, al
 C308  22 07					and     al, [bx]
 C30A  25 00C7					and     ax, 0c7h
 C30D  3C 06					cmp     al, 6
 C30F  75 02					jne     int072
 C311  B0 80					mov     al, 80h
 C313				int072:
 C313  C0 E8 06					shr     al, 6
 C316  40					inc     ax
 C317  03 C3					add     ax, bx
 C319  89 46 08					mov     [bp+8], ax
 C31C  5D					pop     bp
 C31D  1F					pop     ds
 C31E  5B					pop     bx
 C31F  58					pop     ax
 C320  CF					iret
 C321				int07 endp


				; ---------------------------- INT 08 ---------------------
 C321				int08 proc near
 C321  1E					push    ds
 C322  53					push    bx
 C323  6A 40					push    40h
 C325  1F					pop     ds

 C326  BB 0040					mov     bx, 40h
 C329  83 3F 00					cmp     word ptr [bx], 0
 C32C  74 02					jz      int08_nodec
 C32E  FF 0F					dec     word ptr [bx]
 C330				int08_nodec:
 C330  50					push    ax
 C331  B0 20					mov     al, 20h
 C333  E6 20					out     20h, al
 C335  58					pop     ax
 C336  BB 006C					mov     bx, 6ch
 C339  83 07 01					add     word ptr [bx], 1
 C33C  83 57 02 00				adc     word ptr [bx+2], 0
 C340  83 7F 02 18				cmp     word ptr [bx+2], 18h
 C344  75 13					jne     short int081
 C346  81 3F 00B0				cmp     word ptr [bx], 0b0h
 C34A  75 0D					jne     short int081
 C34C  C7 07 0000				mov     word ptr [bx], 0
 C350  C7 47 02 0000				mov     word ptr [bx+2], 0
 C355  C6 47 04 01				mov     byte ptr [bx+4], 1
 C359				int081:
 C359  CD 1C					int     1ch
 C35B  FB					sti
 C35C  50					push    ax
 C35D  B4 04					mov     ah, 4
 C35F				kloop:        
 C35F  E4 64					in      al, 64h
 C361  A8 01					test    al, 1
 C363  74 0E					jz      short nokey
 C365  FE CC					dec     ah
 C367  75 F6					jnz     short kloop
 C369  A8 20					test    al, 20h
 C36B  74 04					jz      short kbdata
 C36D  CD 74					int     74h
 C36F  EB 02					jmp     short nokey
 C371				kbdata:
 C371  CD 09					int     9h        
 C373				nokey:
 C373  58					pop     ax
 C374  5B					pop     bx
 C375  1F					pop     ds
 C376  CF					iret
 C377				int08 endp

				; --------------------- INT 09 - keyboard ------------------
 = ds:[17h]			KbdFlags1       equ     <ds:[17h]>
 = ds:[18h]			KbdFlags2       equ     <ds:[18h]>
 = ds:[19h]			AltKpd          equ     <ds:[19h]>
 = ds:[71h]			CtrlBreak       equ     <ds:[71h]>
 = ds:[96h]			KbdFlags3       equ     <ds:[96h]>
 = ds:[97h]			KbdFlags4       equ     <ds:[97h]>

				; Bits for the KbdFlags1
 = 0001				RShfDown        equ     1
 = 0002				LShfDown        equ     2
 = 0004				CtrlDown        equ     4
 = 0008				AltDown         equ     8
 = 0010				ScrLock         equ     10h
 = 0020				NumLock         equ     20h
 = 0040				CapsLock        equ     40h
 = 0080				Insert          equ     80h

				; Bits for the KbdFlags2
 = 0001				LCtrDown        equ     1
 = 0002				LAltDown        equ     2
 = 0004				SysReqDown      equ     4
 = 0008				Pause           equ     8
 = 0010				ScrLockDown     equ     10h
 = 0020				NumLockDown     equ     20h
 = 0040				CapsLockDown    equ     40h
 = 0080				InsDown         equ     80h
				 
				; Bits for the KbdFlags3
 = 0001				LastE1          equ     1
 = 0002				LastE0          equ     2
 = 0004				RCtrDown        equ     4
 = 0008				RAltDown        equ     8
 = 0020				LastF0          equ     20h

				; Bits for the KbdFlags4
 = 0001				ScrLockLED      equ     1
 = 0002				NumLockLED      equ     2
 = 0004				CapsLockLED     equ     4
 = 0008				SetRepeat       equ     8       ; Set auto repeat command in progress
 = 0010				AckReceived     equ     10h
 = 0040				LEDUpdate       equ     40h

				IFDEF SCANCODE1

 C377				int09 proc near
 C377  60					pusha
 C378  1E					push    ds
 C379  06					push    es
 C37A  6A 40					push    40h
 C37C  1F					pop     ds
 C37D  E4 60					in      al, 60h         ; al contains the scan code
 C37F  8B 16 0017				mov     dx, KbdFlags1
 C383  8B 0E 0096				mov     cx, KbdFlags3
 C387  3C FA					cmp     al, 0fah        ; ACK
 C389  75 1F					jne     short noACK
				; ------------ manage ACK response
 C38B  F6 C5 40					test    ch, LEDUpdate
 C38E  74 14					jz      short ToggleACK ; no LED update
 C390  F6 C5 10					test    ch, AckReceived
 C393  75 0C					jnz     short SecondACK ; second ACK received
 C395  8A E5					mov     ah, ch          ; LED update command sent, ACK received, need to send second byte
 C397  80 E4 07					and     ah, ScrLockLED or NumLockLED or CapsLockLED
 C39A  B3 00					mov     bl, 0
 C39C  E8 140D					call    sendps2byte
 C39F  EB 03					jmp     short ToggleACK
 C3A1				SecondACK:        
 C3A1  80 F5 40					xor     ch, LEDUpdate   ; second ACK, clear LED update bit
 C3A4				ToggleACK:
 C3A4  80 F5 10					xor     ch, AckReceived ; toggle ACK bit 
 C3A7				SetFlags1:                                  
 C3A7  E9 01AF					jmp     SetFlags               
						
				; ------------ no ACK
 C3AA				noACK:
 C3AA  B4 4F					mov     ah,4fh
 C3AC  F9					stc
 C3AD  CD 15					int     15h
 C3AF  72 03 E9 01C8				jnc     int09Exit
 C3B4  3C E0					cmp     al, 0e0h
 C3B6  75 05					jne     short noE0
 C3B8  80 C9 02					or      cl, LastE0
 C3BB  EB EA					jmp     short SetFlags1
 C3BD				noE0:
 C3BD  3C E1					cmp     al, 0e1h
 C3BF  75 05					jne     short noE1
 C3C1  80 C9 01					or      cl, LastE1
 C3C4  EB E1					jmp     short SetFlags1
 C3C6				noE1:   
 C3C6  3C 53					cmp     al, 53h     ; is DEL?
 C3C8  75 18					jne     short noDEL
 C3CA  8A E2					mov     ah, dl
 C3CC  80 E4 0C					and     ah, CtrlDown or AltDown
 C3CF  80 FC 0C					cmp     ah, CtrlDown or AltDown
 C3D2  74 03 E9 010F				jne     NormalKey   ; is DEL, but no CTRL+ALt+DEL
 C3D7  C7 06 0072 1234				mov     word ptr ds:[72h], 1234h    ; warm boot flag
 C3DD  EA					db      0eah
 C3DE  0000 FFFF				dw      0, 0ffffh       ; reboot
 C3E2				noDEL:
 C3E2  F6 C1 02					test    cl, LastE0
 C3E5  75 24					jnz     short noRSUp    ; ignore fake shifts
 C3E7  3C 2A					cmp     al, 2ah         ; left shift
 C3E9  75 05					jne     short noLSDown
 C3EB  80 CA 02					or      dl, LShfDown
 C3EE  EB 63					jmp     short SetFlagsKey2
 C3F0				noLSDown:
 C3F0  3C AA					cmp     al, 2ah or 80h
 C3F2  75 05					jne     short noLSUp
 C3F4  80 E2 FD					and     dl, not LShfDown
 C3F7  EB 5A					jmp     short SetFlagsKey2
 C3F9				noLSUp:
 C3F9  3C 36					cmp     al, 36h         ; right shift
 C3FB  75 05					jne     short noRSDown
 C3FD  80 CA 01					or      dl, RShfDown
 C400  EB 51					jmp     short SetFlagsKey2
 C402				noRSDown:
 C402  3C B6					cmp     al, 36h or 80h
 C404  75 05					jne     short noRSUP
 C406  80 E2 FE					and     dl, not RShfDown
 C409  EB 48					jmp     short SetFlagsKey2
 C40B				noRSUp:
 C40B  3C 38					cmp     al, 38h         ; ALT
 C40D  75 13					jne     short noALTDown
 C40F  F6 C1 02					test    cl, LastE0
 C412  74 08					jz      short LALTDn
 C414  80 C9 08					or      cl, RAltDown
 C417  80 CA 08					or      dl, AltDown
 C41A  EB 37					jmp     short SetFlagsKey2
 C41C				LALTDn:
 C41C  81 CA 0208				or      dx, (LAltDown shl 8) or AltDown
 C420  EB 31					jmp     short SetFlagsKey2
 C422				noALTDown:
 C422  3C B8					cmp     al, 38h or 80h
 C424  75 1E					jne     short noALTUp
 C426  F6 C1 02					test    cl, LastE0
 C429  74 08					jz      short LALTUp
 C42B  80 E1 F7					and     cl, not RAltDown
 C42E  80 E2 F7					and     dl, not AltDown
 C431  EB 04					jmp     short ALTup
 C433				LALTUp:
 C433  81 E2 FDF7				and     dx, not ((LAltDown shl 8) or AltDown)
 C437				ALTUp:
 C437  33 C0					xor     ax, ax
 C439  86 06 0019				xchg    al, AltKpd
 C43D  84 C0					test    al, al
 C43F  74 12					jz      short SetFlagsKey2     
 C441  E9 0107					jmp     pushKey
 C444				noALTUp:
 C444  3C 1D					cmp     al, 1dh         ; CTL
 C446  75 13					jne     short noCTLDown
 C448  F6 C1 02					test    cl, lastE0
 C44B  74 08					jz      short LCTLDn
 C44D  80 C9 04					or      cl, RCtrDown
 C450  80 CA 04					or      dl, CtrlDown
 C453				SetFlagsKey2:        
 C453  EB 79					jmp     short SetFlagsKey1
 C455				LCTLDn:
 C455  81 CA 0104				or      dx, (LCtrDown shl 8) or CtrlDown
 C459  EB 73					jmp     short SetFlagsKey1
 C45B				noCTLDown:
 C45B  3C 9D					cmp     al, 1dh or 80h
 C45D  75 13					jne     short noCTLUp
 C45F  F6 C1 02					test    cl, LastE0
 C462  74 08					jz      short LCTLUp
 C464  80 E1 FB					and     cl, not RCtrDown
 C467  80 E2 FB					and     dl, not CtrlDown
 C46A  EB 62					jmp     short SetFlagsKey1
 C46C				LCTLUp:
 C46C  81 E2 FEFB				and     dx,  not ((LCtrDown shl 8) or CtrlDown)
 C470  EB 5C					jmp     short SetFlagsKey1
 C472				noCTLUp:
 C472  BB 3A40					mov     bx, 3a00h + CapsLock
 C475  E8 010C					call    KeyLock
 C478  73 54					jnc     short SetFlagsKey1
						
 C47A  BB 4610					mov     bx, 4600h + ScrLock
 C47D  52					push    dx          ; save ScrLock state bit (dl)
 C47E  E8 0103					call    KeyLock
 C481  5B					pop     bx          ; restore ScrLock state bit (bl)
 C482  72 21					jc      short noScrLock
 C484  F6 C2 04					test    dl, CtrlDown
 C487  74 45					jz      short SetFlagsKey1; no break, just ScollLock
 C489  8A D3					mov     dl, bl      ; restore ScrLock flag
 C48B  F6 C7 10					test    bh, ScrLockDown
 C48E  75 3E					jnz     short SetFlagsKey1 
 C490  C6 06 0071 80				mov     byte ptr CtrlBreak, 80h   ; CTRL+BREAK flag
 C495  A1 0080					mov     ax, Buffer
 C498  A3 001A					mov     HeadPtr, ax
 C49B  A3 001C					mov     TailPtr, ax
 C49E  CD 1B					int     1bh
 C4A0  33 C0					xor     ax, ax
 C4A2  E9 00A6					jmp     pushkey
 C4A5				noScrLock:        
 C4A5  F6 C1 02					test    cl, LastE0  ; INS
 C4A8  75 0A					jnz     short testINS
 C4AA  F6 C2 03					test    dl, RShfDown or LShfDown
 C4AD  75 05					jnz     short testINS
 C4AF  F6 C2 20					test    dl, NumLock
 C4B2  75 06					jnz     short NoIns      
 C4B4				testINS:
 C4B4  BB 5280					mov     bx, 5200h + Insert
 C4B7  E8 00CA					call    KeyLock  
 C4BA				noIns:
 C4BA  BB 4520					mov     bx, 4500h + NumLock
 C4BD  52					push    dx          ; save NumLock state bit (dl)
 C4BE  E8 00C3					call    KeyLock
 C4C1  5B					pop     bx          ; restore NumLock state bit (bl)
 C4C2  72 22					jc      short NormalKey   ; CTRL+NumLock = Pause
 C4C4  F6 C2 04					test    dl, CtrlDown
 C4C7  74 05					jz      short SetFlagsKey1
 C4C9  8A D3					mov     dl, bl      ; restore NumLock flag
 C4CB  80 CE 08					or      dh, Pause   ; set Pause bit
 C4CE				SetFlagsKey1:
 C4CE  E9 0085					jmp     SetFlagsKey
 C4D1				E0Key:
 C4D1  BF DD62 R				mov     di, offset E0KeyList
 C4D4  51					push    cx
 C4D5  B9 000C					mov     cx, E0KeyIndex - E0KeyList
 C4D8  FC					cld
 C4D9  0E					push    cs
 C4DA  07					pop     es
 C4DB  F2/ AE					repne   scasb
 C4DD  59					pop     cx
 C4DE  75 76					jne     short SetFlagsKey
 C4E0  26: 8A 45 0B				mov     al, es:[di + E0KeyIndex - E0KeyList - 1]
 C4E4  EB 14					jmp     short KeyDown
 C4E6				NormalKey:
 C4E6  A8 80					test    al, 80h
 C4E8  75 6C					jnz     short SetFlagsKey ; key up
 C4EA  F6 C1 02					test    cl, LastE0
 C4ED  75 E2					jnz     short E0Key
 C4EF  3C 59					cmp     al, 59h
 C4F1  1A E4					sbb     ah, ah
 C4F3  22 C4					and     al, ah
 C4F5  BB DD09 R				mov     bx, offset KeyIndex
 C4F8  2E: D7					xlat    cs:[bx]
 C4FA				KeyDown:
 C4FA  33 DB					xor     bx, bx 
 C4FC  F6 C2 03					test    dl, RShfDown or LShfDown
 C4FF  74 02					jz      short noShift
 C501  B3 02					mov     bl, 2
 C503				noShift:
 C503  3C 1A					cmp     al, 26
 C505  77 0A					ja      short noCaps
 C507  F6 C2 40					test    dl, CapsLock
 C50A  74 13					jz      short noNum
 C50C  80 F3 02					xor     bl, 2
 C50F  EB 0E					jmp     short noNum 
 C511				noCaps:
 C511  3C 25					cmp     al, 37
 C513  77 0A					ja      short noNum
 C515  F6 C2 20					test    dl, NumLock
 C518  75 02					jnz     short NumDown
 C51A  B3 02					mov     bl, 2
 C51C				NumDown:
 C51C  80 F3 02					xor     bl, 2
 C51F				noNum:        
 C51F  F6 C2 04					test    dl, CtrlDown
 C522  74 02					jz      short noCtrl
 C524  B3 04					mov     bl, 4
 C526				noCtrl:
 C526  F6 C2 08					test    dl, AltDown
 C529  74 02					jz      short noAlt
 C52B  B3 06					mov     bl, 6
 C52D				noAlt:
 C52D  98					cbw
 C52E  C1 E0 03					shl     ax, 3
 C531  03 D8					add     bx, ax
 C533  2E: 8B 87 DD7A R				mov     ax, cs:KeyCode[bx]
 C538  83 F8 0A					cmp     ax, 000ah
 C53B  77 0E					ja      short pushKey
 C53D  48					dec     ax
 C53E  78 16					js      short SetFlagsKey     ; ax was 0
 C540  8A 26 0019				mov     ah, AltKpd
 C544  D5 0A					aad
 C546  A2 0019					mov     AltKpd, al
 C549  EB 0B					jmp     short SetFlagsKey
 C54B				pushKey:                
 C54B  51					push    cx
 C54C  8B C8					mov     cx, ax
 C54E  B4 05					mov     ah, 5
 C550  CD 16					int     16h
 C552  59					pop     cx
 C553  80 E6 F7					and     dh, not Pause    ; clear Pause bit
 C556				SetFlagsKey:
 C556  80 E1 FC					and     cl, not (LastE0 or LastE1)    ; not prefix key code, clear all prefixes
 C559				SetFlags:
 C559  8A C2					mov     al, dl
 C55B  C0 E8 04					shr     al, 4
 C55E  32 C5					xor     al, ch
 C560  24 07					and     al, 7
 C562  74 10					jz      short SF1   ; no LEDs to update
 C564  F6 C5 58					test    ch, SetRepeat or AckReceived or LEDUpdate
 C567  75 0B					jnz     short SF1   ; can not update LEDS, so just write the flags and exit
 C569  0C 40					or      al, LEDUpdate
 C56B  32 E8					xor     ch, al      ; insert the LEDs in KbdFlags4
 C56D  B4 ED					mov     ah, 0edh    ; set LED
 C56F  B3 00					mov     bl, 0
 C571  E8 1238					call    sendps2byte
 C574				SF1:        
 C574  89 16 0017				mov     KbdFlags1, dx
 C578  89 0E 0096				mov     KbdFlags3, cx
						
 C57C				int09Exit:
 C57C  B0 20					mov     al, 20h
 C57E  E6 20					out     20h, al
 C580  07					pop     es
 C581  1F					pop     ds
 C582  61					popa
 C583  CF					iret
 C584				int09 endp

				ELSE    ; SCANCODE2
				ENDIF

 C584				KeyLock proc near   ; input: BH = expected scan code, al = scan code, BL = key lock flag. Returns CF=1 to continue, CF=0 to exit
 C584  32 F8					xor     bh, al
 C586  75 09					jnz     short s2
 C588  8A E6					mov     ah, dh
 C58A  0A F3					or      dh, bl      ; set flag
 C58C  32 E6					xor     ah, dh      ; get flag difference
 C58E  32 D4					xor     dl, ah      ; toggle only if key was not already down
 C590  C3					ret
 C591  80 FF 80			s2:     cmp     bh, 80h
 C594  F9					stc
 C595  75 02					jne     short exit
 C597  32 F3					xor     dh, bl      ; key up
 C599				exit:
 C599  C3					ret
 C59A				KeyLock endp


				; --------------------- INT 10h - Video ----------------
 = ds:[49h]			ActiveVideoMode     equ <ds:[49h]>  ; 1  byte
 = ds:[4ah]			ScreenWidth         equ <ds:[4ah]>  ; 2  Screen width in text columns
 = ds:[4ch]			RegenLength         equ <ds:[4ch]>  ; 2  Length (in bytes) of video area (regen size)
 = ds:[4eh]			PageOffset          equ <ds:[4eh]>  ; 2  Offset from video segment of active video memory page
 = ds:[50h]			CursorPos           equ <ds:[50h]>  ; 16 Cursor location (8 byte-pairs; low byte=col, hi byte=row)
 = ds:[60h]			CursorShape         equ <ds:[60h]>  ; 2  Cursor size/shape.  Low byte=end scan line; hi byte=start line.
 = ds:[62h]			ActivePage          equ <ds:[62h]>  ; 1  Current active video page number
 = ds:[63h]			PortAddress         equ <ds:[63h]>  ; 2  Port address for 6845 video controller chip; see CGA I/O Ports
 = ds:[65h]			CrtMode             equ <ds:[65h]>  ; 1  Current value of 6845 video ctrlr CRT_MODE (port 3x8H register)
 = ds:[66h]			CrtPalette          equ <ds:[66h]>  ; 1  Current value of 6845 video ctrlr CRT_PALETTE (port 3x9H reg)
 = ds:[84h]			ScreenRows          equ <ds:[84h]>  ; 1  EGA text rows-1  (maximum valid row value)
 = ds:[85h]			ScanLinesChar       equ <ds:[85h]>  ; 2  EGA bytes per character (scan-lines/char used in active mode)
 = ds:[87h]			EgaMiscInfo         equ <ds:[87h]>  ; 1  EGA flags; see EgaMiscInfoRec
 = ds:[88h]			EgaMiscInfo2        equ <ds:[88h]>  ; 1  EGA flags; see EgaMiscInfo2Rec
 = ds:[89h]			VgaFlags            equ <ds:[89h]>  ; 1  VGA flags; see VgaFlagsRec
 = ds:[8ah]			VgaFlags2           equ <ds:[8ah]>  ; 1  VGA flags2
 = ds:[69h]			PalOffset			equ <ds:[69h]>  ; 2  current palette offset (temporary during the video mode set)


 C59A				int10 proc near     
 C59A  FB					sti                     ; no interrupt reentrant
 C59B  FC					cld
 C59C  1E					push    ds
 C59D  56					push    si
 C59E  6A 40					push    40h
 C5A0  1F					pop     ds
 C5A1  80 FC 4F					cmp     ah, 4fh
 C5A4  74 16					je      short svga
 C5A6  80 FC 1C					cmp     ah, 1ch
 C5A9  77 0E					ja      short exit
 C5AB  8B F0					mov     si, ax
 C5AD  C1 EE 07					shr     si, 7
 C5B0  81 E6 01FE				and     si, 1feh
 C5B4  2E: FF 94 D00E R				call    cs:vidtbl[si]
 C5B9				exit:        
 C5B9  5E					pop     si
 C5BA  1F					pop     ds
 C5BB  CF					iret
 C5BC				svga:
 C5BC  3C 05					cmp     al, 5
 C5BE  74 77					je      short VESAMemControl
 C5C0  3C 01					cmp     al, 1
 C5C2  72 0D					jb      short VESAGetInfo
 C5C4  74 24					je      short VESAGetModeInfo
 C5C6  3C 03					cmp     al, 3
 C5C8  72 37					jb      short VESASetMode
 C5CA  74 4F					je      short VESAGetMode
 C5CC  B8 0100					mov     ax, 100h
 C5CF  EB E8					jmp     short exit

				; ---------------- VESA fn00
 C5D1				VESAGetInfo:
 C5D1  51					push    cx
 C5D2  57					push    di
 C5D3  BE C660 R				mov     si, offset VESAInfo
 C5D6  B9 000A					mov     cx, 10
 C5D9  F3/ 2E: A5				rep     movsw es:[di], cs:[si]
 C5DC  B1 76					mov     cl, 118     ; 236 bytes 0
 C5DE				VESASupportedClear:        
 C5DE  33 C0					xor     ax, ax
 C5E0  F3/ AB					rep     stosw
 C5E2  5F					pop     di
 C5E3  59					pop     cx     
 C5E4				VESASupported:
 C5E4  B4 00					mov     ah, 0       ; success    
 C5E6				VESASupportedErr:
 C5E6  B0 4F					mov     al, 4fh
 C5E8  EB CF					jmp     short exit

				; ---------------- VESA fn01
 C5EA				VESAGetModeInfo:
 C5EA  81 F9 0101				cmp     cx, 101h
 C5EE				VESAGetModeInfo1:        
 C5EE  B4 01					mov     ah, 1       ; error
 C5F0  75 F4					jne     short VESASupportedErr
 C5F2  51					push    cx
 C5F3  57					push    di
 C5F4  B9 0009					mov     cx, 9
 C5F7  BE C68B R				mov     si, offset VESAModeInfo
 C5FA  F3/ 2E: A5				rep     movsw es:[di], cs:[si]
 C5FD  B1 77					mov     cl, 119       
 C5FF  EB DD					jmp     short VESASupportedClear

				; ---------------- VESA fn02
 C601				VESASetMode:
 C601  6B C3 02					imul    ax, bx, 2
 C604  3D 0202					cmp     ax, 101h*2
 C607  75 0A					jne     short VESASetMode1      
 C609  8D 87 23FF				lea     ax, [bx+23ffh]
 C60D  86 E0					xchg    ah, al
 C60F  CD 10					int     10h
 C611  EB D1					jmp     short VESASupported   
 C613				VESASetMode1:
 C613  8A C3					mov     al, bl
 C615  B4 00					mov     ah, 0
 C617  CD 10					int     10h
 C619  EB C9					jmp     short VESASupported

				; ---------------- VESA fn03
 C61B				VESAGetMode:
 C61B  8A 3E 0087				mov     bh, EgaMiscInfo
 C61F  80 E7 80					and     bh, 80h
 C622  8A 1E 0049				mov     bl, ActiveVideoMode
 C626  80 FB 25					cmp     bl, 25h
 C629  74 06					je      short VESAGetMode1
 C62B  0A DF					or      bl, bh
 C62D  B7 00					mov     bh, 0
 C62F  EB B3					jmp     short VESASupported
 C631				VESAGetMode1:
 C631  81 C3 00DC				add     bx, 257-25h        
 C635  EB AD					jmp     short VESASupported

				; ---------------- VESA fn05
 C637				VESAMemControl:
				;        test    bx, not 101h                ; BX validation
				;        jnz     short VESAGetModeInfo1      ; error
 C637  0E					push    cs
 C638  68 C5E4 R				push    offset VESASupported
				;        call    VESAMemControlCB
				;        jmp     short VESASupported
 C63B				VESAMemControlCB:
 C63B  9C					pushf
 C63C  FA					cli
 C63D  50					push    ax
 C63E  52					push    dx
 C63F  8B C3					mov     ax, bx
 C641  83 E0 01					and     ax, 1
 C644  04 8A					add     al, 8ah
 C646  92					xchg    ax, dx
 C647  83 E0 07					and     ax, 7
 C64A  04 0A					add     al, 0ah
 C64C  84 FF					test    bh, bh
 C64E  75 05					jnz     getpageinfo
 C650  EF					out     dx, ax          
 C651  5A					pop     dx
 C652  58					pop     ax
 C653  9D					popf
 C654  CB					retf
 C655				getpageinfo:
 C655  ED					in      ax, dx
 C656  2C 0A					sub     al, 0ah
 C658  83 E0 07					and     ax, 7
 C65B  92					xchg    ax, dx
 C65C  58					pop     ax
 C65D  58					pop     ax                
 C65E  9D					popf
 C65F  CB					retf
				   
 C660 56 45 53 41		VESAInfo    db  'VESA'
 C664  0100 C674 R F000					dw  100h, VESAOEM, 0f000h, 2, 0, VESAModes, 0f000h, 8
       0002 0000 C687 R
       F000 0008
 C674 4E 69 63 6F 6C 61		VESAOEM     db  'Nicolae Dumitrache', 0
       65 20 44 75 6D 69
       74 72 61 63 68 65
       00
 C687 0101 FFFF			VESAModes   dw  101h, 0ffffh
 C68B				VESAModeInfo:
				;Bit(s)  Description - mode attributes 
				;0      mode supported by present hardware configuration
				;1      optional information available (must be =1 for VBE v1.2+)
				;2      BIOS output supported
				;3      set if color, clear if monochrome
				;4      set if graphics mode, clear if text mode
				;---VBE v2.0+ ---
				;5      mode is not VGA-compatible
				;6      bank-switched mode not supported
				;7      linear framebuffer mode supported
				;8      double-scan mode available (e.g. 320x200 and 320x240)
				;---VBE v3.0 ---
				;9      interlaced mode available
				;10     hardware supports triple buffering
				;11     hardware supports stereoscopic display
				;12     dual display start address support
				;13-15  reserved
 C68B  0099					dw  0000000010011001b       
				;Bit(s)  Description - window attributes
				;0      exists
				;1      readable
				;2      writable
				;3-7    reserved
 C68D  07 07					db  00000111b, 00000111b
 C68F  0040 0040 A000				dw  64, 64, 0a000h, 0b000h, VESAMemControlCB, 0f000h, 640
       B000 C63B R F000
       0280

 C69D 00			p3c0r10	db		0	; port 3c0h reg 10h mirror
				
 C69E				ModeTab:
				;           0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f     10    11    12    13    25
 C69E 2D 2D 5F 5F 2D 2D		crtc0   db 02dh, 02dh, 05fh, 05fh, 02dh, 02dh, 05fh, 05fh, 02dh, 02dh, 05fh, 05fh, 05fh, 02dh, 05fh, 05fh, 05fh, 05fh, 05fh, 05fh, 05fh ; horizontal total
       5F 5F 2D 2D 5F 5F
       5F 2D 5F 5F 5F 5F
       5F 5F 5F
 C6B3 27 27 4F 4F 27 27		crtc1   db  39,   39,   79,   79,   39,   39,   79,   79,   39,   39,   79,   79,   79,   39,   79,   79,   79,   79,   79,   79,   79  ; hde
       4F 4F 27 27 4F 4F
       4F 27 4F 4F 4F 4F
       4F 4F 4F
				;crtc2   db; hblank start
				;crtc3   db; hblank end
 C6C8 29 29 52 52 29 29		crtc4   db 029h, 029h, 052h, 052h, 029h, 029h, 052h, 052h, 029h, 029h, 052h, 052h, 052h, 029h, 052h, 052h, 052h, 052h, 052h, 052h, 052h ; hsync start
       52 52 29 29 52 52
       52 29 52 52 52 52
       52 52 52
 C6DD 0F 0F 1E 1E 0F 0F		crtc5   db 00fh, 00fh, 01eh, 01eh, 00fh, 00fh, 01eh, 01eh, 00fh, 00fh, 01eh, 01eh, 01eh, 00fh, 01eh, 01eh, 01eh, 01eh, 01eh, 01eh, 01eh ; hsync end
       1E 1E 0F 0F 1E 1E
       1E 0F 1E 1E 1E 1E
       1E 1E 1E
 C6F2 BF BF BF BF BF BF		crtc6   db 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 0bfh, 008h, 008h, 0bfh, 008h ; vtotal
       BF BF BF BF BF BF
       BF BF BF BF BF 08
       08 BF 08
 C707 1F 1F 1F 1F 1F 1F		crtc7   db 01fh, 01fh, 01fh, 01fh, 01fh, 01fh, 01fh, 01fh, 01fh, 01fh, 01fh, 01fh, 01fh, 01fh, 01fh, 01fh, 01fh, 03eh, 03eh, 01fh, 03eh ; overflow (vsync[9], vde[9], vtotal[9], lcr[8], vblank[8], vsync[8], vde[8], vtotal[8])
       1F 1F 1F 1F 1F 1F
       1F 1F 1F 1F 1F 3E
       3E 1F 3E
 C71C 4F 4F 4F 4F C0 C0		crtc9   db 04fh, 04fh, 04fh, 04fh, 0c0h, 0c0h, 0c0h, 04fh, 0c0h, 0c0h, 0c0h, 041h, 041h, 041h, 041h, 040h, 040h, 040h, 040h, 041h, 040h ; lcr[9], repln
       C0 4F C0 C0 C0 41
       41 41 41 40 40 40
       40 41 40
 C731 9C 9C 9C 9C 9C 9C		crtc10  db 09ch, 09ch, 09ch, 09ch, 09ch, 09ch, 09ch, 09ch, 09ch, 09ch, 09ch, 09ch, 09ch, 09ch, 09ch, 09ch, 09ch, 0e1h, 0e1h, 09ch, 0e1h ; vsync start
       9C 9C 9C 9C 9C 9C
       9C 9C 9C 9C 9C E1
       E1 9C E1
 C746 8F 8F 8F 8F 8F 8F		crtc12  db 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 08fh, 05dh, 05dh, 0dfh, 0dfh, 08fh, 0dfh ; vde
       8F 8F 8F 8F 8F 8F
       8F 8F 8F 5D 5D DF
       DF 8F DF
 C75B 14 14 28 28 14 14		crtc13  db 014h, 014h, 028h, 028h, 014h, 014h, 014h, 028h, 028h, 028h, 028h, 028h, 028h, 014h, 028h, 028h, 028h, 028h, 028h, 028h, 050h ; offset
       14 28 28 28 28 28
       28 14 28 28 28 28
       28 28 50
 C770 08 08 08 08 01 01		dac10   db 008h, 008h, 008h, 008h, 001h, 001h, 001h, 008h, 001h, 001h, 001h, 001h, 001h, 001h, 001h, 00bh, 001h, 00bh, 001h, 041h, 001h ; mode ctrl
       01 08 01 01 01 01
       01 01 01 0B 01 0B
       01 41 01
 C785 09 09 01 01 0B 0B		sc1     db 009h, 009h, 001h, 001h, 00bh, 00bh, 001h, 001h, 00bh, 00bh, 001h, 000h, 000h, 00bh, 001h, 001h, 001h, 001h, 001h, 001h, 001h ; clocking mode (half)
       01 01 0B 0B 01 00
       00 0B 01 01 01 01
       01 01 01
				
				; --------------- fn 00h, set video mode
 C79A				setmode:
 C79A  60					pusha
 C79B  06					push    es
 C79C  02 C0					add     al, al      ; CF = cls bit
 C79E  D0 16 0087				rcl     byte ptr EgaMiscInfo, 1
 C7A2  D0 0E 0087				ror     byte ptr EgaMiscInfo, 1

 C7A6  50					push	ax
 C7A7  BA 03D4					mov     dx,3d4h    ; CRTC
 C7AA  B8 0011					mov     ax,0011h   ; unset register protect
 C7AD  EF					out     dx,ax
 C7AE  B8 8317					mov     ax,8317h   ; mode control
 C7B1  EF					out     dx,ax
 C7B2  BA 03C4					mov		dx, 3c4h ; SC
 C7B5  B8 0F02					mov		ax, 0f02h
 C7B8  EF					out		dx, ax		; enable all write planes
 C7B9  B8 0C04					mov		ax, 0c04h
 C7BC  EF					out		dx, ax		; clear planar and odd/even mode
 C7BD  B2 CE					mov		dl, 0ceh	; GC
 C7BF  B8 0001					mov		ax, 0001h
 C7C2  EF					out		dx, ax		; disable set/reset
 C7C3  B0 03					mov		al, 03h
 C7C5  EF					out		dx, ax		; reset logical op and rotate count
 C7C6  B0 05					mov		al, 05h
 C7C8  EF					out		dx, ax		; set write mode to 00 (CPU access)
 C7C9  B8 FF07					mov		ax, 0ff07h
 C7CC  EF					out     dx, ax      ; set color don't care to 0Fh
 C7CD  40					inc     ax
 C7CE  EF					out		dx, ax		; set bitmask to CPU access
 C7CF  58					pop		ax

 C7D0  3C 0E					cmp     al, 7*2
 C7D2  74 04					je      setmode_text1
 C7D4  3C 06					cmp     al, 3*2
 C7D6  77 30					ja      short setmode1
 C7D8				setmode_text1:
 C7D8  50					push    ax
 C7D9  B0 B6					mov     al, 0b6h        ; reset sound generator
 C7DB  E6 43					out     43h, al
 C7DD  B0 00					mov     al, 0
 C7DF  E6 42					out     42h, al
 C7E1  E6 42					out     42h, al
 C7E3  58					pop     ax
 C7E4  B4 08					mov     ah, 08h   ; text mode, flash enabled
 C7E6  C7 06 004C 1000				mov     word ptr RegenLength, 1000h
 C7EC  3C 02					cmp     al, 2
 C7EE  77 06					ja      setmode_80ch
 C7F0  C7 06 004C 0800				mov     word ptr RegenLength, 800h
 C7F6				setmode_80ch:
 C7F6  BB B800					mov     bx, 0b800h  ; segment
 C7F9  B9 4000					mov     cx, 4000h   ; video len/2
 C7FC  BE 0720					mov     si, 0720h   ; clear value
 C7FF  C7 06 0069 DC39 R			mov		word ptr PalOffset, offset PalVGA
 C805  E9 00BA					jmp     setmode2
 C808				setmode1:
						; CGA modes
 C808  3C 14					cmp     al,0ah*2
 C80A  77 42					ja      setmode11
				
 C80C  50					push    ax
 C80D  BA 03D4					mov     dx, 3d4h    ; CRTC
 C810  3C 0C					cmp     al, 06h*2
 C812  77 04					ja      short setmode1_pcjr
 C814  B4 82					mov     ah, 82h
 C816  EB 02					jmp     short setmode1b
 C818				setmode1_pcjr:
 C818  B4 80					mov     ah, 80h
 C81A				setmode1b:
 C81A  B0 17					mov     al, 17h    ; mode control
 C81C  EF					out     dx, ax
 C81D  BA 03C4					mov     dx, 3c4h   ; SC
 C820  B8 0804					mov     ax, 0804h
 C823  EF					out     dx, ax     ; set odd/even mode
 C824  58					pop     ax
				
 C825  3C 0C					cmp     al,6*2
 C827  74 0E					je      setmode1a
 C829  3C 14					cmp     al,0ah*2
 C82B  74 0A					je      setmode1a
 C82D  50					push    ax         ; save AL
 C82E  B2 CE					mov     dl, 0ceh   ; GC
 C830  B8 3005					mov     ax, 3005h
 C833  EF					out     dx,ax      ; set shift-load
 C834  58					pop     ax         ; restore AL
 C835  B4 11					mov     ah, 11h    ; half -> 320x200x4(16)
 C837				setmode1a:
 C837  BB B800					mov     bx, 0b800h  ; segment
 C83A  B9 2000					mov     cx, 2000h   ; video len/2
 C83D  BE 0000					mov     si, 0000h   ; clear value
 C840  C7 06 004C 1000				mov     word ptr RegenLength, 1000h
 C846  C7 06 0069 DB69 R			mov     word ptr PalOffset, offset PalEGA
 C84C  EB 74					jmp     setmode2
 C84E				setmode11:
 C84E  3C 1A					cmp		al,	0dh*2
 C850  75 0E					jne		short setmode12
 C852  C7 06 004C 2000				mov     word ptr RegenLength, 2000h
 C858  C7 06 0069 DB69 R			mov		word ptr PalOffset, offset PalEGA
 C85E  EB 26					jmp		short setmode121
 C860				setmode12:
 C860  3C 1C					cmp		al, 0eh*2	; 640x200x16
 C862  75 0E					jne		short setmode122
 C864  C7 06 0069 DB69 R			mov		word ptr PalOffset, offset PalEGA
 C86A				setmode1221:
 C86A  C7 06 004C 4000				mov     word ptr RegenLength, 04000h
 C870  EB 14					jmp		short setmode121
 C872				setmode122:
 C872  C7 06 0069 DC39 R			mov		word ptr PalOffset, offset PalVGA
 C878  3C 20					cmp		al, 10h*2
 C87A  74 EE					je		short setmode1221	; 640x350x16
 C87C  3C 24					cmp		al, 12h*2
 C87E  75 15					jne		short setmode13
 C880  C7 06 004C A000				mov     word ptr RegenLength, 0a000h
 C886				setmode121:
 C886  50					push	ax
 C887  BA 03C4					mov		dx, 3c4h	; SC
 C88A  B8 FF02					mov		ax, 0ff02h
 C88D  EF					out		dx, ax		; set write all planes
 C88E  B8 0404					mov		ax, 0404h
 C891  EF					out		dx, ax		; set planar mode
 C892  58					pop		ax
 C893  EB 25					jmp		short setmode21
 C895				setmode13:    
 C895  3C 26					cmp     al, 13h*2
 C897  75 0E					jne     short setmode3
						; graphic mode, 320x200, 256 colors
 C899  C7 06 004C 0000				mov     word ptr RegenLength, 0000h
 C89F  C7 06 0069 DA99 R			mov		word ptr PalOffset, offset Pal256
 C8A5  EB 13					jmp     short setmode21
 C8A7				setmode3:
 C8A7  3C 4A					cmp     al, 25h*2
 C8A9  74 03 E9 0127				jne		setmodeexit
 C8AE  C7 06 004C 0000				mov     word ptr RegenLength, 0000h
 C8B4  C7 06 0069 DA99 R			mov		word ptr PalOffset, offset Pal256
 C8BA				setmode21:
 C8BA  BB A000					mov     bx, 0a000h  ; segment
 C8BD  B9 8000					mov     cx, 8000h   ; video len/2
 C8C0  33 F6					xor     si, si      ; clear value
 C8C2				setmode2:
 C8C2  D0 E8					shr     al, 1
 C8C4  A2 0049					mov     ActiveVideoMode, al
				
 C8C7  32 E4					xor     ah,ah
 C8C9  8B F8					mov     di,ax
 C8CB  83 FF 13					cmp     di,13h     ; video modes > 13h are mapped to 14h entry
 C8CE  76 03					jbe     setmode2a
 C8D0  BF 0014					mov     di,14h
 C8D3				setmode2a:
 C8D3  2E: 8A A5 C770 R				mov     ah, cs:dac10[di]
 C8D8  2E: 8A 85 C785 R				mov     al, cs:sc1[di]
 C8DD  50					push    ax
 C8DE  51					push    cx
 C8DF  BA 03D4					mov     dx, 3d4h   ; CRTC
 C8E2  2E: 8A A5 C69E R				mov     ah, cs:crtc0[di]
 C8E7  32 C0					xor     al, al
 C8E9  EF					out     dx, ax     ; htotal
 C8EA  2E: 8A A5 C6B3 R				mov     ah, cs:crtc1[di]
 C8EF  FE C0					inc     al
 C8F1  EF					out     dx, ax     ; hde
 C8F2  FE C4					inc     ah
 C8F4  32 C0					xor     al, al
 C8F6  86 C4					xchg    al, ah
 C8F8  A3 004A					mov     word ptr ScreenWidth, ax
 C8FB  B0 01					mov     al, 1
						;mov     ah, cs:crtc2[di]
 C8FD  FE C0					inc     al
						;out     dx, ax     ; hblank start
						;mov     ah, cs:crtc3[di]
 C8FF  FE C0					inc     al
						;out     dx, ax     ; hblank end
 C901  2E: 8A A5 C6C8 R				mov     ah, cs:crtc4[di]
 C906  FE C0					inc     al
 C908  EF					out     dx, ax     ; hsync start
 C909  2E: 8A A5 C6DD R				mov     ah, cs:crtc5[di]
 C90E  FE C0					inc     al
 C910  EF					out     dx, ax     ; hsync end
 C911  2E: 8A A5 C6F2 R				mov     ah, cs:crtc6[di]
 C916  FE C0					inc     al
 C918  EF					out     dx, ax     ; vtotal
 C919  2E: 8A A5 C707 R				mov     ah, cs:crtc7[di]
 C91E  FE C0					inc     al
 C920  EF					out     dx, ax     ; vtotal9, lcr8, vsync8, vde8, vtotal8
 C921  32 E4					xor     ah, ah
 C923  FE C0					inc     al
 C925  EF					out     dx, ax   ; clear preset row scan
 C926  2E: 8A A5 C71C R				mov     ah, cs:crtc9[di]
 C92B  FE C0					inc     al
 C92D  EF					out     dx, ax     ; set repln, lcr9, char height
 C92E  2E: 8A A5 C731 R				mov     ah, cs:crtc10[di]
 C933  B0 10					mov     al, 10h
 C935  EF					out     dx, ax     ; vsync start
 C936  2E: 8A A5 C746 R				mov     ah, cs:crtc12[di]
 C93B  B0 12					mov     al, 12h
 C93D  EF					out     dx, ax     ; vde
 C93E  B0 15					mov     al, 15h
 C940  EF					out     dx, ax     ; vblank
 C941  2E: 8A A5 C75B R				mov     ah, cs:crtc13[di]
 C946  B0 13					mov     al, 13h
 C948  EF					out     dx, ax     ; offset
 C949  1E					push    ds
 C94A  07					pop     es
 C94B  B8 FF18					mov     ax, 0ff18h  ; lcr7..0
 C94E  EF					out     dx, ax
 C94F  33 C0					xor     ax, ax
 C951  BF 0050					mov     di, offset CursorPos
 C954  B9 0008					mov     cx, 8
 C957  F3/ AB					rep     stosw           ; reset cursor position for all pages
 C959  B8 0500					mov     ax, 0500h
 C95C  CD 10					int     10h             ; set page0
 C95E  59					pop     cx
 C95F  F6 06 0087 80				test    byte ptr EgaMiscInfo, 80h
 C964  75 16					jnz     short setmode4    ; no clear video memory

 C966  8E C3					mov     es, bx
 C968				clearnext:
 C968  96					xchg    ax, si
 C969  33 FF					xor     di, di
 C96B  51					push	cx
 C96C  F3/ AB					rep     stosw        
 C96E  59					pop		cx
 C96F  80 FF A0					cmp		bh, 0a0h
 C972  75 08					jnz		short clearok
 C974  96					xchg	ax, si
 C975  40					inc		ax
 C976  CD 10					int		10h
 C978  3C 08					cmp		al, 8
 C97A  75 EC					jnz		short clearnext				
 C97C				clearok:

 C97C				setmode4:
 C97C  BA 03DA					mov     dx, 3dah
 C97F  EC					in      al, dx
 C980  58					pop     ax
 C981  50					push    ax
 C982  BA 03C0					mov     dx, 3c0h
 C985  B0 10					mov     al, 10h
 C987  EE					out     dx, al
 C988  8A C4					mov     al, ah      
 C98A  EE					out     dx, al      ; set video mode
 C98B  2E: A2 C69D R				mov     cs:p3c0r10, al
 C98F  B0 13					mov     al, 13h
 C991  EE					out     dx, al
 C992  B0 00					mov     al, 0
 C994  EE					out     dx, al      ; 0 pan
 C995  58					pop     ax
 C996  8A E0					mov     ah, al    ; set half dot clock
 C998  BA 03C4					mov     dx, 3c4h    ; SC
 C99B  B0 01					mov     al, 01h
 C99D  EF					out     dx, ax

 C99E  B8 1114					mov     ax, 1114h
 C9A1  CD 10					int     10h         ; set 8x16 ROM font
 C9A3  B8 1123					mov     ax, 1123h
 C9A6  CD 10					int     10h         ; set ROM 8x8 font for graphics mode
 C9A8  B4 01					mov     ah, 1
 C9AA  B9 0607					mov		cx, 607h	; scanlines 13 and 14
 C9AD  CD 10					int     10h         ; show cursor
 C9AF  F6 06 0089 08				test    byte ptr VgaFlags, 8  ; test default palette loading
 C9B4  75 1F					jnz     short setmodeexit     ; no default palette
 C9B6  B8 1012					mov     ax, 1012h
 C9B9  33 DB					xor     bx, bx
 C9BB  B9 0040					mov     cx, 40h    
 C9BE  8B 16 0069				mov     dx, PalOffset
 C9C2  0E					push    cs
 C9C3  07					pop     es
 C9C4  CD 10					int     10h             ; set default palette
 C9C6  B0 02					mov		al, 02h
 C9C8  81 C2 00C0				add		dx, 40h*3
 C9CC  CD 10					int		10h				; set default palette EGA registers
 C9CE  B0 13					mov		al, 13h
 C9D0  BB 0001					mov		bx, 0001h		; select page0
 C9D3  CD 10					int		10h
 C9D5				setmodeexit:
 C9D5  BA 03D4					mov     dx,3d4h
 C9D8  B8 8011					mov     ax,8011h   ; set register protect
 C9DB  EF					out     dx,ax
 C9DC  BA 03D9					mov     dx,3d9h    ; CGA color select
 C9DF  B0 30					mov     al,030h    ; palette 1, hi-intensity, bg color=0
 C9E1  A2 0066					mov     CrtPalette, al
 C9E4  EE					out     dx,al
				
 C9E5  07					pop     es
 C9E6  61					popa
 C9E7				nullproc:
 C9E7  C3					ret        

				; --------------- fn 01h, set cursor shape and visibility
 C9E8				cursor:     ; CH = start line (0-7), CH bit 5 = 1  -> cursor off
							; CL = end line (0-7)
 C9E8  50					push    ax
 C9E9  52					push    dx
 C9EA  89 0E 0060				mov		[CursorShape], cx
 C9EE  F6 06 0085 10				test	byte ptr [ScanLinesChar], 10h
 C9F3  74 04					jz		short cursor8
 C9F5  03 C9					add		cx, cx
 C9F7  FE C5					inc		ch
 C9F9				cursor8:
 C9F9  BA 03D4					mov     dx, 3d4h
 C9FC  B0 0A					mov     al, 0ah
 C9FE  8A E5					mov		ah, ch
 CA00  EF					out     dx, ax
 CA01  40					inc		ax
 CA02  8A E1					mov     ah, cl
 CA04  EF					out     dx, ax
 CA05  5A					pop     dx
 CA06  58					pop     ax
 CA07  C3					ret

				;---------------- fn 02h, set cursor pos
				;	AH = 02
				;	BH = page number (0 for graphics modes)
				;	DH = row
				;	DL = column
 CA08				curpos:
 CA08  50					push    ax
 CA09  53					push    bx
 CA0A  8A C7					mov     al, bh
 CA0C  C1 EB 07					shr     bx, 7
 CA0F  83 E3 0E					and     bx, 0eh
 CA12  89 57 50					mov     CursorPos[bx], dx
 CA15  80 3E 0049 03				cmp     byte ptr ActiveVideoMode, 3
 CA1A  77 02					ja      short curpos_ismode7
 CA1C  EB 07					jmp     short curpos1
 CA1E				curpos_ismode7:
 CA1E  80 3E 0049 07				cmp     byte ptr ActiveVideoMode, 7
 CA23  75 21					jne     curpos_exit
 CA25				curpos1:
 CA25  3A 06 0062				cmp     al, ActivePage
 CA29  75 1B					jne     short curpos_exit
 CA2B  52					push    dx
 CA2C  33 C0					xor     ax, ax
 CA2E  86 C6					xchg    al, dh
 CA30  8B 1E 004A				mov     bx, word ptr ScreenWidth
 CA34  F6 EB					imul    bl
 CA36  03 C2					add     ax, dx
 CA38  BA 03D4					mov     dx, 3d4h
 CA3B  50					push    ax
 CA3C  8A E0					mov 	ah, al
 CA3E  B0 0F					mov		al, 0fh
 CA40  EF					out		dx, ax
 CA41  58					pop		ax
 CA42  B0 0E					mov		al, 0eh
 CA44  EF					out 	dx, ax
 CA45  5A					pop     dx
 CA46				curpos_exit:
 CA46  5B					pop     bx
 CA47  58					pop     ax
 CA48  C3					ret

				;---------------- fn 03h, get cursor pos
				;	AH = 03
				;	BH = video page
				;	on return:
				;	CH = cursor starting scan line (low order 5 bits)
				;	CL = cursor ending scan line (low order 5 bits)
				;	DH = row
				;	DL = column
 CA49				getcurpos:
 CA49  53					push    bx
 CA4A  C1 EB 07					shr     bx, 7
 CA4D  83 E3 0E					and     bx, 0eh
 CA50  8B 57 50					mov     dx, CursorPos[bx]
 CA53  8B 0E 0060				mov     cx, CursorShape
 CA57  5B					pop     bx
 CA58  C3					ret

				;---------------- fn 04h, light pen
 CA59				lightpen:
 CA59  B4 00					mov     ah, 0   ; not triggered
 CA5B  C3					ret

				;---------------- fn 05h, set active video page
 CA5C				apage:
 CA5C  60					pusha
 CA5D  24 07					and     al, 7
 CA5F  8A F8					mov     bh, al
 CA61  A2 0062					mov     ActivePage, al
 CA64  A0 0049					mov     al, ActiveVideoMode
 CA67  3C 13					cmp     al, 13h
 CA69  73 19					jae		short apage1
 CA6B  3C 03					cmp     al, 3
 CA6D  77 25					ja		short apage2
 CA6F  B8 000A					mov     ax, 0ah
 CA72  E7 8A					out     8ah, ax
 CA74  40					inc     ax
 CA75  E7 8B					out     8bh, ax
 CA77  B4 03					mov     ah, 3
 CA79  CD 10					int     10h        ; get cursor pos
 CA7B  B4 02					mov     ah, 2
 CA7D  CD 10					int     10h        ; set cursor pos
 CA7F  B8 0400					mov		ax, 400h
 CA82  EB 13					jmp     short apage4
 CA84				apage1:	
 CA84  B8 000A					mov     ax, 0ah		; mode 13h and 25h
 CA87  02 C7					add     al, bh
 CA89  E7 8A					out     8ah, ax
 CA8B  40					inc     ax
 CA8C  3C 12					cmp     al, 12h
 CA8E  75 02					jne     short apage3
 CA90  B0 0A					mov     al, 0ah
 CA92				apage3: 
 CA92  E7 8B					out     8bh, ax
 CA94				apage2:
 CA94  A1 004C					mov	ax, RegenLength
 CA97				apage4:
 CA97  C1 EB 08					shr     bx, 8      ; page number
 CA9A  F7 E3					mul     bx
 CA9C  8B D8					mov     bx, ax     ; 1 means 4 bytes, or 2 characters
 CA9E  C1 E0 02					shl     ax, 2	   ; 1 means 1 byte   
 CAA1  A3 004E					mov     PageOffset, ax
 CAA4  BA 03D4					mov     dx, 3d4h
 CAA7  8A E3					mov		ah, bl
 CAA9  B0 0D					mov		al, 0dh
 CAAB  EF					out		dx, ax
 CAAC  8A E7					mov		ah, bh
 CAAE  48					dec		ax
 CAAF  EF					out		dx, ax
 CAB0  61					popa
 CAB1  C3					ret

				;---------------- fn 06h, scroll up / clr
				;	AH = 06
				;	AL = number of lines to scroll, previous lines are
				;	     blanked, if 0 or AL > screen size, window is blanked
				;	BH = attribute to be used on blank line
				;	CH = row of upper left corner of scroll window
				;	CL = column of upper left corner of scroll window
				;	DH = row of lower right corner of scroll window
				;	DL = column of lower right corner of scroll window
 CAB2				scrollup:
 CAB2  60					pusha
 CAB3  06					push    es
 CAB4  87 CA					xchg    cx, dx
 CAB6  2B CA					sub     cx, dx
 CAB8  41					inc     cx
 CAB9  E8 0047					call    scr_params
 CABC				scrollup6:        
 CABC  68 B800					push    0b800h          ; segment
 CABF  07					pop     es
 CAC0  02 D2					add     dl, dl
 CAC2  03 FF					add     di, di
 CAC4  03 3E 004E				add     di, PageOffset  ; di = top left corner address
 CAC8  91					xchg    ax, cx          ; ah = 0
 CAC9  84 DB					test    bl, bl
 CACB  74 13					jz      short scrollup3       ; clear
 CACD  2A E3					sub     ah, bl
 CACF  72 0F					jb      short scrollup3       ; clear
 CAD1  03 F7					add     si, di
 CAD3				scrollup4:        
 CAD3  8A C8					mov     cl, al
 CAD5  F3/ 26: A5				rep     movsw es:[si], es:[di]
 CAD8  03 F2					add     si, dx
 CADA  03 FA					add     di, dx
 CADC  FE CC					dec     ah              
 CADE  79 F3					jns     short scrollup4       ; ch = lines - 1
 CAE0				scrollup3:                      
 CAE0  02 E3					add     ah, bl          ; clear rectangle: DI=address, ah=lines, al=columns, bh=attribute
 CAE2  93					xchg    ax, bx
 CAE3  B0 20					mov     al, ' '
 CAE5				scrollup5:
 CAE5  8A CB					mov     cl, bl
 CAE7  F3/ AB					rep     stosw
 CAE9  03 FA					add     di, dx
 CAEB  FE CF					dec     bh
 CAED  79 F6					jns     short scrollup5       ; ch = lines - 1
 CAEF				scrollexit:
 CAEF  07					pop     es
 CAF0  61					popa
 CAF1  C3					ret

				;---------------- fn 07h, scroll dn / clr
				;	AH = 07
				;	AL = number of lines to scroll, previous lines are
				;	     blanked, if 0 or AL > screen size, window is blanked
				;	BH = attribute to be used on blank line
				;	CH = row of upper left corner of scroll window
				;	CL = column of upper left corner of scroll window
				;	DH = row of lower right corner of scroll window
				;	DL = column of lower right corner of scroll window
 CAF2				scrolldn:
 CAF2  FD					std
 CAF3  60					pusha
 CAF4  06					push    es
 CAF5  F7 D9					neg     cx
 CAF7  03 CA					add     cx, dx
 CAF9  41					inc     cx
 CAFA  E8 0006					call    scr_params
 CAFD  F7 DA					neg     dx
 CAFF  F7 DE					neg     si
 CB01  EB B9					jmp     short scrollup6

 CB03				scr_params:
 CB03  51					push    cx
 CB04  8A D8					mov     bl, al          ; lines
 CB06  8B 0E 004A				mov     cx, word ptr ScreenWidth
 CB0A  F6 E9					imul    cl
 CB0C  D1 E0					shl     ax, 1
 CB0E  8B F0					mov     si, ax
 CB10  33 C0					xor     ax, ax
 CB12  86 C6					xchg    al, dh
 CB14  F6 E9					imul    cl
 CB16  8B F8					mov     di, ax
 CB18  03 FA					add     di, dx
 CB1A  8A D1					mov     dl, cl
 CB1C  59					pop     cx
 CB1D  2A D1					sub     dl, cl
 CB1F  32 E4					xor     ah, ah
 CB21  8A C3					mov     al, bl
 CB23  C3					ret
				
				;---------------- fn 08h, read char/attr
				;	AH = 08
				;	BH = display page
				;	on return:
				;	AH = attribute of character (alpha modes only)
				;	AL = character at cursor position
 CB24				readchar:
 CB24  53					push    bx
 CB25  E8 0004					call    mode3chaddr
 CB28  8B 07					mov     ax, [bx]
 CB2A  5B					pop     bx
 CB2B  C3					ret

 CB2C				mode3chaddr:    ; returns current char address in mode3 in ds:bx. Input: bh=page, ds=40h 
 CB2C  50					push    ax
 CB2D  51					push    cx
 CB2E  81 E3 0700				and     bx, 700h
 CB32  8D 87 B800				lea     ax, [bx+0b800h]
 CB36  C1 EB 07					shr     bx, 7
 CB39  8B 5F 50					mov     bx, CursorPos[bx]
 CB3C  8B 0E 004A				mov     cx, word ptr ScreenWidth
 CB40  8E D8					mov     ds, ax
 CB42  33 C0					xor     ax, ax
 CB44  86 C7					xchg    al, bh
 CB46  F6 E9					imul    cl
 CB48  03 D8					add     bx, ax
 CB4A  03 DB					add     bx, bx
 CB4C  59					pop     cx
 CB4D  58					pop     ax
 CB4E  C3					ret

				;---------------- fn 09h, write char/attr
				;	AH = 09
				;	AL = ASCII character to write
				;	BH = display page  (or mode 13h, background pixel value)
				;	BL = character attribute (text) foreground color (graphics)
				;	CX = count of characters to write (CX >= 1)
 CB4F				writecharattr:
 CB4F  50					push    ax
 CB50  06					push    es
 CB51  53					push    bx
 CB52  51					push    cx
 CB53  8A E3					mov     ah, bl
 CB55  E8 FFD4					call    mode3chaddr
 CB58  1E					push    ds
 CB59  07					pop     es
 CB5A  87 FB					xchg    di, bx
 CB5C  F3/ AB					rep     stosw
 CB5E  87 FB					xchg    di, bx
 CB60  59					pop     cx
 CB61  5B					pop     bx
 CB62  07					pop     es
 CB63  58					pop     ax
 CB64  C3					ret

				;---------------- fn 0ah, write char
				;	AH = 0A
				;	AL = ASCII character to write
				;	BH = display page  (or mode 13h, background pixel value)
				;	BL = foreground color (graphics mode only)
				;	CX = count of characters to write (CX >= 1)
 CB65				writechar:
 CB65  E3 0E					jcxz    short writecharskip
 CB67  53					push    bx
 CB68  51					push    cx
 CB69  E8 FFC0					call    mode3chaddr
 CB6C				writechar3:        
 CB6C  88 07					mov     [bx], al
 CB6E  83 C3 02					add     bx, 2
 CB71  E2 F9					loop    short writechar3
 CB73  59					pop     cx
 CB74  5B					pop     bx
 CB75				writecharskip:        
 CB75  C3					ret

				;---------------- fn 0bh,  Set Color Palette (CGA)
				;	AH = 0B
				;	BH = palette color ID
				;	   = 0	to set background and border color
				;	   = 1	to select 4 color palette
				;	BL = color value (when BH = 0)
				;	   = palette value (when BH = 1)
 CB76				setcolorpalette:
 CB76  52					push    dx
 CB77  1E					push    ds
 CB78  6A 40					push    40h
 CB7A  1F					pop     ds
 CB7B  BA 03D9					mov     dx, 03d9h
 CB7E  A0 0066					mov     al, CrtPalette
 CB81  0A FF					or      bh, bh
 CB83  75 09					jnz     setcolorpalette_pal
 CB85  24 20					and     al, 020h ; clear brightness and color
 CB87  80 E3 1F					and     bl, 01fh
 CB8A  0A C3					or      al, bl
 CB8C  EB 07					jmp short setcolorpalette_out
 CB8E				setcolorpalette_pal:
 CB8E  24 1F					and     al, 01fh ; clear palette bit
 CB90  C0 E3 05					shl     bl, 5
 CB93  0A C3					or      al, bl
 CB95				setcolorpalette_out:
 CB95  EE					out     dx,al
 CB96  A2 0066					mov     CrtPalette, al
 CB99  1F					pop     ds
 CB9A  5A					pop     dx
 CB9B  C3					ret

				;---------------- fn 0ch, Write Graphics Pixel at Coordinate
				;	AH = 0C
				;	AL = color value (XOR'ED with current pixel if bit 7=1)
				;	BH = page number
				;	CX = column number (zero based)
				;	DX = row number (zero based)
 CB9C				writepixel: ; https://github.com/wbhart/CGAGraphics/blob/master/cga.asm
 CB9C  06					push    es
 CB9D  57					push    di
 CB9E  53					push    bx
 CB9F  51					push    cx
 CBA0  52					push    dx
				
 CBA1  50					push    ax
 CBA2  B8 B800					mov     ax, 0b800h
 CBA5  8E C0					mov     es, ax
 CBA7  8B C2					mov     ax, dx      ; row
 CBA9  33 FF					xor     di, di
 CBAB  D0 E8					shr     al, 1
 CBAD  83 DF 00					sbb     di, 0
 CBB0  81 E7 2000				and     di, 2000h
 CBB4  D1 E0					shl     ax, 1
 CBB6  D1 E0					shl     ax, 1
 CBB8  D1 E0					shl     ax, 1
 CBBA  D1 E0					shl     ax, 1
 CBBC  8B D8					mov     bx, ax
 CBBE  D1 E0					shl     ax, 1
 CBC0  D1 E0					shl     ax, 1
 CBC2  03 F8					add     di, ax
 CBC4  03 FB					add     di, bx
 CBC6  8B C1					mov     ax, cx      ; column
 CBC8  8A C8					mov     cl, al
 CBCA  D1 E8					shr     ax, 1
 CBCC  D1 E8					shr     ax, 1
 CBCE  03 F8					add     di, ax
 CBD0  FE C1					inc     cl
 CBD2  80 E1 03					and     cl, 3
 CBD5  D0 E1					shl     cl, 1
 CBD7  5A					pop     dx          ; color
 CBD8  D2 CA					ror     dl, cl
 CBDA  B0 FC					mov     al, 0fch
 CBDC  D2 C8					ror     al, cl
 CBDE  26: 22 05				and     al, es:[di]
 CBE1  0A C2					or      al, dl
 CBE3  AA					stosb
				
 CBE4  5A					pop     dx
 CBE5  59					pop     cx
 CBE6  5B					pop     bx
 CBE7  5F					pop     di
 CBE8  07					pop     es
 CBE9  C3					ret
				
				;---------------- fn 0dh, Read Graphics Pixel at Coordinate
				;	AH = 0D
				;	BH = page number
				;	CX = column number (zero based)
				;	DX = row number (zero based)
				;	on return:
				;	AL = color of pixel read
 CBEA				readpixel:
 CBEA  C3					ret
				
				;---------------- fn 0eh, write char as TTY
				;	AH = 0E
				;	AL = ASCII character to write
				;	BH = page number (text modes)
				;	BL = foreground pixel color (graphics modes)
 CBEB				writecharTTY:
 CBEB  50					push    ax
 CBEC  53					push    bx
 CBED  52					push    dx
 CBEE  8A 1E 0062				mov     bl, ActivePage
 CBF2  B7 00					mov     bh, 0
 CBF4  03 DB					add     bx, bx
 CBF6  8B 57 50					mov     dx, CursorPos[bx]
 CBF9  C1 E3 07					shl     bx, 7
 CBFC  B4 0A					mov     ah, 0ah
 CBFE  E8 0008					call    tty
 CC01  B4 02					mov     ah, 2       ; set cursor pos
 CC03  CD 10					int     10h
 CC05  5A					pop     dx
 CC06  5B					pop     bx
 CC07  58					pop     ax 
 CC08  C3					ret        

 CC09				tty:    ; dx=xy, bh=page, al=char, bl=attr, ah=0ah(no attr) or 09h(with attr)
 CC09  F7 06 0018 0008				test    word ptr KbdFlags2, Pause
 CC0F  75 F8					jnz     short tty
 CC11  51					push    cx
 CC12  3C 07					cmp     al, 7
 CC14  74 1A					je      short bell
 CC16  3C 08					cmp     al, 8
 CC18  74 18					je      short bs
 CC1A  3C 0A					cmp     al, 0ah
 CC1C  74 22					je      short cr
 CC1E  3C 0D					cmp     al, 0dh
 CC20  74 18					je      short lf
 CC22  B9 0001					mov     cx, 1
 CC25  CD 10					int     10h         ; write char at cursor
 CC27  42					inc     dx
 CC28  3A 16 004A				cmp     dl, ScreenWidth
 CC2C  73 10					jae     short crlf
 CC2E				tty1:
 CC2E  59					pop     cx
 CC2F  C3					ret
 CC30				bell:
				; TODO bell code        
 CC30  EB FC					jmp     short tty1
 CC32				bs:
 CC32  80 EA 01					sub     dl, 1
 CC35  80 D2 00					adc     dl, 0      
 CC38  EB F4					jmp     short tty1
 CC3A				lf:
 CC3A  B2 00					mov     dl, 0
 CC3C  EB F0					jmp     short tty1
 CC3E				crlf:
 CC3E  B2 00					mov     dl, 0        
 CC40				cr:        
 CC40  FE C6					inc     dh
 CC42  3A 36 0084				cmp     dh, ScreenRows
 CC46  76 E6					jbe     short tty1
 CC48  FE CE					dec     dh
				;        mov     ah, 8
				;        int     10h         ; read attribute at cursor pos
 CC4A  53					push    bx          ; save active page in bh
 CC4B  52					push    dx
				;        xchg    ax, bx
 CC4C  B7 07					mov     bh, 7       ; default attribute
 CC4E  B8 0601					mov     ax, 601h    
 CC51  8A 36 0084				mov     dh, ScreenRows
 CC55  8A 16 004A				mov     dl, ScreenWidth
 CC59  4A					dec     dx
 CC5A  33 C9					xor     cx, cx
 CC5C  CD 10					int     10h         ; scroll up
 CC5E  5A					pop     dx
 CC5F  5B					pop     bx          ; restore active page in bh         
 CC60  EB CC					jmp     short tty1
						
				;---------------- fn 0fh, read video mode
				;	AH = 0F
				;	on return:
				;	AH = number of screen columns
				;	AL = mode currently set (see VIDEO MODES)
				;	BH = current display page
 CC62				readmode:
 CC62  A0 0087					mov     al, EgaMiscInfo
 CC65  24 80					and     al, 80h
 CC67  0A 06 0049				or      al, ActiveVideoMode
 CC6B  8A 26 004A				mov     ah, ScreenWidth
 CC6F  8A 3E 0062				mov     bh, ActivePage
 CC73  C3					ret


				;---------------- fn 10h, palette
 CC74 CCBA R CCB9 R CCCA R	paltable    dw  setonereg, palexit, setallreg, setblink, palexit, palexit, palexit, readonereg, readoverscan, readallreg, palexit, palexit, palexit, palexit, palexit, palexit
       CCDE R CCB9 R CCB9 R
       CCB9 R CD0A R CD36 R
       CD1F R CCB9 R CCB9 R
       CCB9 R CCB9 R CCB9 R
       CCB9 R
 CC94  CD39 R CCB9 R CD4F R				dw  setoneDAC, palexit, setblockDAC, paging, palexit, readoneDAC, palexit, readblockDAC, setPELmask, getPELmask, getpaging, grayscale
       CD60 R CCB9 R CD90 R
       CCB9 R CDA8 R CDB9 R
       CDC2 R CDCB R CDE1 R

 CCAC				pal:
 CCAC  3C 1B					cmp     al, 1bh
 CCAE  77 09					ja      short palexit
 CCB0  8B F0					mov     si, ax
 CCB2  03 F6					add     si, si
 CCB4  2E: FF 94 AC74 R				call    cs:paltable[si-2000h]
 CCB9				palexit:
 CCB9  C3					ret

 CCBA				setonereg:
 CCBA  60					pusha
 CCBB  BA 03DA					mov		dx, 3dah
 CCBE  EC					in		al, dx
 CCBF  BA 03C0					mov		dx, 3c0h
 CCC2  8A C3					mov		al, bl
 CCC4  EE					out		dx, al
 CCC5  8A C7					mov		al, bh
 CCC7  EE					out		dx, al
 CCC8  61					popa
 CCC9				setonereg1:        
 CCC9  C3					ret        

 CCCA				setallreg:
 CCCA  60					pusha
 CCCB  B0 00					mov     al, 0
 CCCD  8B F2					mov     si, dx
 CCCF  B3 0F					mov     bl, 15
 CCD1				setallreg1:        
 CCD1  26: 8A 7C 0F				mov     bh, es:[si+15]
 CCD5  CD 10					int     10h
 CCD7  4E					dec     si
 CCD8  FE CB					dec     bl
 CCDA  79 F5					jns     short setallreg1
 CCDC  61					popa
 CCDD  C3					ret

 CCDE				setblink:
 CCDE  60					pusha
 CCDF  BA 03DA					mov		dx, 3dah
 CCE2  EC					in		al, dx
 CCE3  BA 03C0					mov     dx, 3c0h
 CCE6  B0 10					mov     al, 10h
 CCE8  EE					out     dx, al
 CCE9  2E: A0 C69D R				mov		al, cs:p3c0r10      
 CCED  C0 E3 03					shl     bl, 3
 CCF0  32 C3					xor		al, bl
 CCF2  24 F7					and		al, not 8
 CCF4  32 C3					xor		al, bl
 CCF6  EE					out     dx, al          ; set blink flag
 CCF7  2E: A2 C69D R				mov		cs:p3c0r10, al
 CCFB  C0 E0 02					shl     al, 2
 CCFE  32 06 0089				xor     al, VgaFlags
 CD02  24 20					and     al, 20h
 CD04  30 06 0089				xor     VgaFlags, al
 CD08				setblink1:
 CD08  61					popa
 CD09  C3					ret

 CD0A				readonereg:
 CD0A  52					push	dx
 CD0B  50					push	ax
 CD0C  BA 03DA					mov		dx, 3dah
 CD0F  EC					in		al, dx
 CD10  BA 03C0					mov		dx, 3c0h
 CD13  8A C3					mov		al, bl
 CD15  EE					out		dx, al
 CD16  42					inc		dx
 CD17  EC					in		al, dx
 CD18  4A					dec		dx
 CD19  EE					out		dx, al
 CD1A  8A F8					mov		bh, al
 CD1C  58					pop		ax
 CD1D  5A					pop		dx
 CD1E  C3					ret

 CD1F				readallreg:
 CD1F  60					pusha
 CD20  8B FA					mov     di, dx
 CD22  B3 00					mov     bl, 0
 CD24				readllreg1:
 CD24  B0 07					mov     al, 7
 CD26  CD 10					int     10h
 CD28  8A C7					mov     al, bh
 CD2A  AA					stosb
 CD2B  43					inc     bx
 CD2C  80 FB 10					cmp     bl, 16
 CD2F  75 F3					jne     short readllreg1
 CD31  B0 00					mov     al, 0   ; overscan color
 CD33  AA					stosb
 CD34  61					popa
 CD35  C3					ret

 CD36				readoverscan:
 CD36  B7 00					mov     bh, 0
 CD38  C3					ret

 CD39				setoneDAC:
 CD39  50					push    ax
 CD3A  52					push    dx
 CD3B  92					xchg    ax, dx
 CD3C  8A C3					mov     al, bl
 CD3E  BA 03C8					mov     dx, 3c8h
 CD41  EE					out     dx, al
 CD42  42					inc     dx
 CD43  8A C4					mov     al, ah
 CD45  EE					out     dx, al
 CD46  8A C5					mov     al, ch
 CD48  EE					out     dx, al
 CD49  8A C1					mov     al, cl
 CD4B  EE					out     dx, al
 CD4C  5A					pop     dx
 CD4D  58					pop     ax
 CD4E  C3					ret

 CD4F				setblockDAC:
 CD4F  60					pusha
 CD50  8B F2					mov     si, dx
 CD52  BA 03C8					mov     dx, 3c8h
 CD55  93					xchg    ax, bx
 CD56  EE					out     dx, al
 CD57  42					inc     dx
 CD58  6B C9 03					imul    cx, 3
 CD5B  F3/ 26: 6E				rep     outsb dx, es:[si]
 CD5E  61					popa
 CD5F  C3					ret

 CD60				paging:
 CD60  60					pusha
 CD61  BA 03DA					mov		dx, 3dah
 CD64  EC					in		al, dx
 CD65  BA 03C0					mov		dx, 3c0h
 CD68  84 DB					test    bl, bl
 CD6A  2E: A0 C69D R				mov		al, cs:p3c0r10
 CD6E  75 11					jnz     short paging1
 CD70  02 C0					add		al, al
 CD72  D0 CF					ror		bh, 1
 CD74  D0 D8					rcr		al, 1
 CD76  2E: A2 C69D R				mov		cs:p3c0r10, al
 CD7A  50					push	ax
 CD7B  B0 10					mov		al, 10h
 CD7D  EE					out		dx, al
 CD7E  58					pop		ax
 CD7F  EB 0C					jmp     short paging2
 CD81				paging1:
 CD81  02 C0					add		al, al
 CD83  72 03					jc		paging3
 CD85  C0 E7 02					shl		bh, 2
 CD88				paging3:
 CD88  B0 14					mov		al, 14h
 CD8A  EE					out		dx, al
 CD8B  8A C7					mov		al, bh
 CD8D				paging2:        
 CD8D  EE					out		dx, al
 CD8E  61					popa
 CD8F  C3					ret

 CD90				readoneDAC:
 CD90  50					push    ax
 CD91  52					push    dx
 CD92  8A C3					mov     al, bl
 CD94  BA 03C7					mov     dx, 3c7h
 CD97  EE					out     dx, al
 CD98  42					inc     dx
 CD99  42					inc     dx
 CD9A  EC					in      al, dx
 CD9B  8A E0					mov     ah, al
 CD9D  EC					in      al, dx
 CD9E  8A E8					mov     ch, al
 CDA0  EC					in      al, dx
 CDA1  8A C8					mov     cl, al
 CDA3  5A					pop     dx
 CDA4  8A F4					mov     dh, ah
 CDA6  58					pop     ax             
 CDA7  C3					ret

 CDA8				readblockDAC:
 CDA8  60					pusha
 CDA9  8B FA					mov     di, dx
 CDAB  BA 03C7					mov     dx, 3c7h
 CDAE  93					xchg    ax, bx
 CDAF  EE					out     dx, al
 CDB0  42					inc     dx
 CDB1  42					inc     dx
 CDB2  6B C9 03					imul    cx, 3
 CDB5  F3/ 6C					rep     insb                
 CDB7  61					popa
 CDB8  C3					ret

 CDB9				setPELmask:
 CDB9  52					push    dx
 CDBA  93					xchg    ax, bx
 CDBB  BA 03C6					mov     dx, 3c6h
 CDBE  EE					out     dx, al
 CDBF  93					xchg    ax, bx
 CDC0  5A					pop     dx
 CDC1  C3					ret

 CDC2				getPELmask:
 CDC2  52					push    dx
 CDC3  93					xchg    ax, bx
 CDC4  BA 03C6					mov     dx, 3c6h
 CDC7  EC					in      al, dx
 CDC8  93					xchg    ax, bx
 CDC9  5A					pop     dx
 CDCA  C3					ret

 CDCB				getpaging:
 CDCB  B3 14					mov		bl, 14h
 CDCD  E8 FF3A					call	readonereg	; returns BH
 CDD0  2E: 8A 1E C69D R				mov		bl, cs:p3c0r10
 CDD5  80 E7 0F					and		bh, 0fh
 CDD8  C0 EB 07					shr		bl, 7
 CDDB  75 03					jnz		short getpaging1
 CDDD  C0 EF 02					shr		bh, 2
 CDE0				getpaging1:
 CDE0  C3					ret

 CDE1				grayscale:
 CDE1  E3 2B					jcxz    short grayscale2
 CDE3  60					pusha
 CDE4  8A F9					mov     bh, cl
 CDE6				grayscale1:        
 CDE6  B0 15					mov     al, 15h
 CDE8  CD 10					int     10h
 CDEA  C1 EA 08					shr     dx, 8
 CDED  6B F2 4D					imul    si, dx, 77
 CDF0  8A D5					mov     dl, ch
 CDF2  69 D2 0097				imul    dx, 151
 CDF6  B5 00					mov     ch, 0
 CDF8  6B C9 1C					imul    cx, 28
 CDFB  03 D6					add     dx, si
 CDFD  03 D1					add     dx, cx
 CDFF  8A EE					mov     ch, dh
 CE01  8A CE					mov     cl, dh
 CE03  B0 10					mov     al, 10h
 CE05  CD 10					int     10h
 CE07  FE C3					inc     bl
 CE09  FE CF					dec     bh
 CE0B  75 D9					jne     short grayscale1        
 CE0D  61					popa
 CE0E				grayscale2:        
 CE0E  C3					ret


				;---------------- fn 11h, character generator
 CE0F				loadUDF:    ; CX=chars, DX=first char, BH=bytes/char, ES:BP=font
 CE0F  60					pusha
 CE10  92					xchg    ax, dx
 CE11  87 CB					xchg    cx, bx
 CE13  C1 E9 10					shr     cx, 16 ; 8 when fonts are installed
 CE16  BA 03CB					mov     dx, 03cbh
 CE19  8B F5					mov     si, bp
 CE1B				loadUDF1:
 CE1B  EF					out     dx, ax
 CE1C  51					push    cx
 CE1D  F3/ 26: 6E		        rep     outsb dx, es:[si]
 CE20  59					pop     cx
 CE21  40					inc     ax
 CE22  4B					dec     bx
 CE23  75 F6					jnz     short loadUDF1
 CE25  61					popa
 CE26  A8 10					test    al, 10h
 CE28  74 31					jz      short loadUDFexit
 CE2A  6A 40					push    40h
 CE2C  1F					pop     ds
 CE2D  50					push    ax
 CE2E  B8 0190					mov     ax, 400 ; screen lines in text mode
 CE31  F6 F7					div     bh
 CE33  48					dec     ax
 CE34  A2 0084					mov     ScreenRows, al
 CE37  88 3E 0085				mov     byte ptr ScanLinesChar, bh
 CE3B  2E: A0 C69D R				mov		al, cs:p3c0r10		; set/reset half bit
 CE3F  32 C7					xor		al, bh		
 CE41  0C 10					or		al, 10h
 CE43  32 C7					xor		al, bh
 CE45  A8 01					test	al, 1
 CE47  75 11					jnz		short loadUDFexit1	; not in text mode
 CE49  50					push	ax
 CE4A  BA 03DA					mov		dx, 3dah
 CE4D  EC					in		al, dx
 CE4E  BA 03C0					mov		dx, 3c0h
 CE51  B0 10					mov		al, 10h
 CE53  EE					out		dx, al
 CE54  58					pop		ax
 CE55  EE					out		dx, al
 CE56  2E: A2 C69D R				mov		cs:p3c0r10, al
 CE5A				loadUDFexit1:
 CE5A  58					pop     ax 
 CE5B				loadUDFexit:        
 CE5B  C3					ret

 CE5C				chargen:
 CE5C  A8 EF					test    al, not 10h     ; test for 00h and 10h  ; UDF
 CE5E  74 AF					jz      short loadUDF
 CE60  A8 EE					test    al, not 11h     ; test for 01h and 11h  ; 8x14
 CE62  74 26					jz      short loadROMfont16
 CE64  A8 ED					test    al, not 12h     ; test for 02h and 12h  ; 8x8
 CE66  74 17					jz      short loadROMfont8
 CE68  A8 EB					test    al, not 14h     ; test for 04h and 14h  ; 8x16
 CE6A  74 1E					jz      short loadROMfont16
 CE6C  3C 20					cmp     al, 20h
 CE6E  72 EB					jb      loadUDFexit
 CE70  74 30					je      short set1f
 CE72  3C 21					cmp     al, 21h
 CE74  74 37					je      short setgrUDF
 CE76  3C 24					cmp     al, 24h
 CE78  76 60					jbe     short setROMgrFont
 CE7A  3C 30					cmp     al, 30h
 CE7C  74 7A					je      short getfontinfo
 CE7E  C3					ret

 CE7F				loadROMFont8:
 CE7F  60					pusha
 CE80  BB 0800					mov     bx, 0800h       ; 8x8 chars, block 0
 CE83  2E: 8B 2E CF29 R				mov     bp, cs:fontinfo[2]
 CE88  EB 09					jmp     short loadROMFont161
					 
 CE8A				loadROMFont16:
 CE8A  60					pusha
 CE8B  BB 1000					mov     bx, 1000h       ; 8x16 chars, block 0
 CE8E  2E: 8B 2E CF2F R				mov     bp, cs:fontinfo[8]
 CE93				loadROMFont161:
 CE93  B9 0100					mov     cx, 100h        ; all chars
 CE96  33 D2					xor     dx, dx
 CE98  06					push    es
 CE99  0E					push    cs
 CE9A  07					pop     es
 CE9B  24 10					and     al, 10h
 CE9D  CD 10					int     10h             ; loadUDF
 CE9F  07					pop     es
 CEA0  61					popa
 CEA1  C3					ret

 CEA2				set1f:
 CEA2  33 F6					xor     si, si
 CEA4  8E DE					mov     ds, si
 CEA6  89 6C 7C					mov     [si+1fh*4], bp
 CEA9  8C 44 7E					mov     [si+1fh*4+2], es
 CEAC  C3					ret
						
 CEAD				setgrUDF:
 CEAD  60					pusha
 CEAE  E3 AB					jcxz    short loadUDFexit
 CEB0  1E					push    ds
 CEB1  33 F6					xor     si, si
 CEB3  8E DE					mov     ds, si
 CEB5  89 AC 010C				mov     [si+43h*4], bp
 CEB9  8C 84 010E				mov     [si+43h*4+2], es
 CEBD  1F					pop     ds
 CEBE  B8 00C8					mov     ax, 200
 CEC1  80 3E 0049 13				cmp     byte ptr ActiveVideoMode, 13h
 CEC6  72 10					jb      short setgrUDFexit
 CEC8  74 03					je      short setgrUDF1
 CECA  B8 01E0					mov     ax, 480         ; mode 25h, 480 lines
 CECD				setgrUDF1:
 CECD  89 0E 0085				mov     ScanLinesChar, cx
 CED1  99					cwd
 CED2  F7 F1					div     cx
 CED4  48					dec     ax
 CED5  A2 0084					mov     ScreenRows, al
 CED8				setgrUDFexit:
 CED8  61					popa
 CED9  C3					ret

 CEDA				setROMgrFont:       
 CEDA  60					pusha
 CEDB  06					push    es
 CEDC  B9 0008					mov     cx, 8
 CEDF  0E					push    cs
 CEE0  07					pop     es
 CEE1  BD B800 R				mov     bp, font8x8
 CEE4  3C 23					cmp     al, 23h
 CEE6  74 03					je      short setROMgrFont1
 CEE8  BD A800 R				mov     bp, offset font8x16
 CEEB				setROMgrFont1:        
 CEEB  B0 21					mov     al, 21h
 CEED  CD 10					int     10h     ; set graphic UDF
 CEEF  48					dec     ax
 CEF0  BD BC00 R				mov     bp, font8x8 + 128*8
 CEF3  CD 10					int     10h     ; set INT 1fh
 CEF5  07					pop     es
 CEF6  61					popa
 CEF7  C3					ret
						
 CEF8				getfontinfo:
 CEF8  8B 0E 0085				mov     cx, ScanLinesChar
 CEFC  8A 16 0084				mov     dl, ScreenRows
 CF00  80 FF 01					cmp     bh, 1
 CF03  77 0E					ja      short getfontinfo1
 CF05  6A 00					push    0
 CF07  1F					pop     ds
 CF08  C4 2E 007C				les     bp, ds:[1fh*4] 
 CF0C  72 18					jb      short getfontinfoexit
 CF0E  C4 2E 010C				les     bp, ds:[43h*4]
 CF12  C3					ret
 CF13				getfontinfo1:
 CF13  80 FF 07					cmp     bh, 7
 CF16  77 0E					ja      short getfontinfoexit
 CF18  8B F3					mov     si, bx
 CF1A  C1 EE 08					shr     si, 8
 CF1D  03 F6					add     si, si
 CF1F  2E: 8B AC CF23 R				mov     bp, cs:fontinfo[si-4]
 CF24  0E					push    cs
 CF25  07					pop     es                    
 CF26				getfontinfoexit:
 CF26  C3					ret

 CF27 9A00 R B800 R BC00 R	fontinfo    dw  font8x14, font8x8, font8x8+128*8, font8x14, font8x16, font8x16
       9A00 R A800 R A800 R

				;---------------- fn 12h, special functions
 CF33				special:
 CF33  80 FB 10					cmp     bl, 10h
 CF36  75 0B					jne     short special1
 CF38  8A 0E 0088				mov     cl, EgaMiscInfo2    ; cl = switch settings
 CF3C  83 E1 0F					and     cx, 15              ; ch <- 0 (feature bits)
 CF3F  BB 0003					mov     bx, 3               ; bh <- 0 (color mode), bl = video memory size
 CF42  C3					ret
 CF43				special1:
 CF43  80 FB 31					cmp     bl, 31h
 CF46  75 0F					jne     short special2
 CF48  F6 D8					neg     al
 CF4A  32 06 0089				xor     al, VgaFlags
 CF4E  24 08					and     al, 8       ; transfer palette loading bit to VgaFlags
 CF50  30 06 0089				xor     VgaFlags, al
 CF54  B0 12					mov     al, 12h     ; supported function
 CF56  C3					ret
 CF57				special2:
 CF57  B0 00					mov     al, 0       ; unsupported function
 CF59  C3					ret


				;---------------- fn 13h, write string
 CF5A				writestr:
 CF5A  E3 31					jcxz    short wstrexit
 CF5C  60					pusha
 CF5D  8B F3					mov     si, bx
 CF5F  C1 EE 08					shr     si, 8
 CF62  03 F6					add     si, si
 CF64  FF 74 50					push    CursorPos[si]
 CF67  B4 09					mov     ah, 9       ; write tty char/attribute
 CF69				wstr1:        
 CF69  50					push    ax
 CF6A  A8 02					test    al, 2
 CF6C  26: 8A 46 00				mov     al, es:[bp]
 CF70  74 05					jz      short noattr
 CF72  45					inc     bp
 CF73  26: 8A 5E 00				mov     bl, es:[bp]
 CF77				noattr:
 CF77  45					inc     bp
 CF78  89 54 50					mov     CursorPos[si], dx
 CF7B  E8 FC8B					call    tty
 CF7E  58					pop     ax
 CF7F  E2 E8					loop    short wstr1
 CF81  8F 44 50					pop     CursorPos[si]
 CF84  A8 01					test    al, 1
 CF86  74 04					jz      short wstr2             
 CF88  B4 02					mov     ah, 2       ; set cursor pos
 CF8A  CD 10					int     10h                
 CF8C				wstr2:        
 CF8C  61					popa
 CF8D				wstrexit:        
 CF8D  C3					ret

				;---------------- fn 1ah, get/set display combination code
 CF8E				getdcc:
 CF8E  3C 01					cmp     al, 1
 CF90  77 0C					ja      short getdccexit
 CF92  8A C4					mov     al, ah
 CF94  74 03					je      short setdcc
 CF96  BB 0008					mov     bx, 08h
 CF99				dccval  label word        
 CF99				setdcc:
 CF99  2E: 89 1E CF97 R				mov     cs:[dccval-2], bx
 CF9E				getdccexit:        
 CF9E  C3					ret        

				;---------------- fn 1bh, query status
 CF9F				querystatus:
 CF9F  60					pusha
 CFA0  B8 CFFE R				mov     ax, offset staticfunctable
 CFA3  AB					stosw
 CFA4  8C C8					mov     ax, cs
 CFA6  AB					stosw
 CFA7  BE 0049					mov     si, offset ActiveVideoMode
 CFAA  80 3C 12					cmp     byte ptr [si], 12h
 CFAD  B9 0021					mov     cx, 33          ; info copied from BDA        
 CFB0  F3/ A4					rep     movsb
 CFB2  B8 0008					mov     ax, 8
 CFB5  AB					stosw                   ; display info (one VGA analog color monitor)
 CFB6  BB 0208					mov     bx, 208h        ; 400 scan lines, 8 pages
 CFB9  B0 10					mov     al, 10h         ; 16 colors         
 CFBB  72 14					jb      short querystatus1	; mode03h
 CFBD  BB 0302					mov		bx, 302h	; 480 scan lines, 2 pageS
 CFC0  74 0F					je		short querystatus1	; mode12h 
 CFC2  B7 00					mov     bh, 0           ; scan lines code (0=200, 1=350, 2=400, 3=480)
 CFC4  B8 0100					mov     ax, 100h        ; 256 colors
 CFC7  80 3E 0049 13				cmp     byte ptr ActiveVideoMode, 13h
 CFCC  74 0D					je      short querystatus3     ; mode13h
 CFCE  BB 0301					mov     bx, 301h        ; 480 scan lines, 1 page
 CFD1				querystatus1:
 CFD1  80 3E 0049 0D				cmp		byte ptr ActiveVideoMode, 0dh
 CFD6  75 03					jne		short querystatus3
 CFD8  BB 0008					mov		bx, 0008h	; 200 scan lines, 8 pages
 CFDB				querystatus3:
 CFDB  AB					stosw
 CFDC  93					xchg    ax, bx
 CFDD  AB					stosw
 CFDE  33 C0					xor     ax, ax
 CFE0  AB					stosw                   ; font block info (45)
 CFE1  A0 0089					mov     al, VgaFlags
 CFE4  24 2F					and     al, 00101111b
 CFE6  AB					stosw        
 CFE7  AB					stosw
 CFE8  A0 0087					mov     al, EgaMiscInfo
 CFEB  C0 E8 04					shr     al, 4
 CFEE  24 07					and     al, 7           ; video memory size
 CFF0  AB					stosw
 CFF1  B0 02					mov     al, 2
 CFF3  AA					stosb                   ; color display attached
 CFF4  B1 06					mov     cl, 6
 CFF6  33 C0					xor     ax, ax
 CFF8  F3/ AB					rep     stosw           ; 12 reserved bytes
 CFFA  61					popa
 CFFB  8A C4					mov     al, ah          ; supported function
 CFFD  C3					ret

 CFFE 0C			staticfunctable db  00001100b   ; video modes 2h, 3h supported
 CFFF  60							db  01100000b	; video mode 0dh, 0eh supported
 D000  0D							db  00001101b   ; video modes 10h, 12h, 13h supported
 D001  00							db  00000000b
 D002  20							db  00100000b   ; video mode 25h supported
 D003  00 00							db  0, 0
 D005  04							db  00000100b   ; 400 scanline supported
 D006  01							db  1           ; font blocks available in text mode
 D007  01							db  1           ; max active font blocks available in text mode

				;Bit(s)  Description
				;0      all modes on all displays function supported
				;1      gray summing function supported
				;2      character font loading function supported
				;3      default palette loading enable/disable supported
				;4      cursor emulation function supported
				;5      EGA palette present
				;6      color palette present
				;7      color-register paging function supported
				;8      light pen supported (see AH=04h)
				;9      save/restore state function 1Ch supported
				;10     intensity/blinking function supported (see AX=1003h)
				;11     Display Combination Code supported (see #00039)
				;12-15  unused (0)
 D008  EF					db  11101111b   ; miscellaneous function support flags 
 D009  0C					db  00001100b   ; miscellaneous function support flags
								 
 D00A  00 00					db  0, 0        ; reserved
 D00C  00					db  0           ; save pointer function flags
 D00D  00					db  0           ; reserved  

					   
 D00E C79A R C9E8 R CA08 R	vidtbl  dw  setmode, cursor, curpos, getcurpos, lightpen, apage, scrollup, scrolldn, readchar, writecharattr
       CA49 R CA59 R CA5C R
       CAB2 R CAF2 R CB24 R
       CB4F R
 D022  CB65 R CB76 R CB9C R			dw  writechar, setcolorpalette, writepixel, readpixel, writecharTTY, readmode
       CBEA R CBEB R CC62 R
 D02E  CCAC R CE5C R CF33 R			dw  pal, chargen, special, writestr, nullproc, nullproc, nullproc, nullproc, nullproc, nullproc, getdcc, querystatus, nullproc
       CF5A R C9E7 R C9E7 R
       C9E7 R C9E7 R C9E7 R
       C9E7 R CF8E R CF9F R
       C9E7 R
 D048				int10 endp

				; --------------------- INT 11h - Equipment ----------------
 = ds:[10h]			EquipmentWord       equ     <ds:[10h]>

 D048				int11   proc near
 D048  1E					push    ds
 D049  6A 40					push    40h
 D04B  1F					pop     ds
 D04C  A1 0010					mov     ax, EquipmentWord
 D04F  1F					pop     ds
 D050  CF					iret
 D051				int11   endp

				; --------------------- INT 12h - Memory size ----------------
 = ds:[13h]			MemorySize       equ     <ds:[13h]>

 D051				int12   proc near
 D051  1E					push    ds
 D052  6A 40					push    40h
 D054  1F					pop     ds
 D055  A1 0013					mov     ax, MemorySize
 D058  1F					pop     ds
 D059  CF					iret        
 D05A				int12   endp

				; --------------------- INT 13h - Disk services ----------------
 = ds:[74h]			HDLastError       equ     <ds:[74h]>
 = ds:[92h]			HDOpStarted       equ     <ds:[92h]>    ; bit 3: in INT13h (all other bits must be 0)
 = ds:[94h]			HDSize            equ     <ds:[94h]>

 D05A				int13   proc near
 D05A  1E					push    ds
 D05B  55					push    bp
 D05C  6A 40					push    40h
 D05E  1F					pop     ds
 D05F  80 36 0092 08				xor     byte ptr HDOpStarted, 8
 D064  74 13					jz      short inINT13
 D066  FB					sti                     
 D067  FC					cld
 D068  80 FC 1A					cmp     ah, 1ah
 D06B  76 10					jbe     short Disk1
 D06D  80 EC 26					sub     ah, 41h-1bh     ; extensions
 D070  80 FC 22					cmp     ah, 22h
 D073  76 08					jbe     short Disk1
 D075  B4 01					mov     ah, 1           ; bad command error
 D077  EB 14					jmp     short exit
 D079				inINT13:        
 D079  B4 AA					mov     ah, 0aah        ; drive not ready
 D07B  EB 14					jmp     short exit2
 D07D				Disk1:
 D07D  8B E8					mov     bp, ax
 D07F  C1 ED 07					shr     bp, 7
 D082  81 E5 01FE				and     bp, 1feh
 D086  1E					push    ds
 D087  2E: FF 96 D0A5 R				call    cs:disktbl[bp]
 D08C  1F					pop     ds
 D08D				exit:        
 D08D  88 26 0074				mov     HDLastError, ah
 D091				exit2:
 D091  80 36 0092 08				xor     byte ptr HDOpStarted, 8
 D096  F6 DC					neg     ah              ; CF <- (AH != 0)
 D098				exit1:
 D098  8B EC					mov     bp, sp
 D09A  D0 5E 08					rcr     byte ptr [bp+8], 1
 D09D  D0 46 08					rol     byte ptr [bp+8], 1  ; insert error CF on stack
 D0A0  F6 DC					neg     ah
 D0A2  5D					pop     bp
 D0A3  1F					pop     ds
 D0A4  CF					iret

 D0A5 D119 R D11C R D12B R	disktbl dw      DiskReset, DiskGetStatus, DiskRead, DiskWrite, DiskVerify, DiskFormat, DiskFormat, DiskFormat, DiskGetParams, DiskInit, DiskRead, DiskWrite, DiskSeek, DiskRst, DiskReadSectBuffer, DiskWriteSectBuffer
       D126 R D121 R D175 R
       D175 R D175 R D184 R
       D175 R D12B R D126 R
       D175 R D175 R D244 R
       D244 R
 D0C5  D175 R D175 R D175 R			dw      DiskReady, DiskRecalibrate, DiskDiag, DiskDiag, DiskDiag, DiskGetType, DiskChanged, DiskSetDASDType, DiskSetMediaType, DiskPark, DiskFormat,  DiskExtInstCheck, DiskExtRead, DiskExtWrite, DiskExtVerify, DiskExtLock
       D175 R D175 R D0EB R
       D119 R D244 R D244 R
       D119 R D175 R D10B R
       D1C5 R D1C0 R D1BB R
       D244 R
 D0E5  D244 R D175 R D1F7 R			dw      DiskExtEject, DiskExtSeek, DiskExtGetParams

 D0EB				DiskGetType:
 D0EB  80 FA 80					cmp     dl, 80h
 D0EE  75 29					jne     short DiskReset ; ah=0, drive not present
 D0F0  8B 0E 0094				mov     cx, HDSize      
 D0F4  8B D1					mov     dx, cx
 D0F6  85 C9					test    cx, cx
 D0F8  74 1F					jz      short DiskReset ; ah=0, drive not present
 D0FA  B4 FD					mov     ah, -3      ; HD present
 D0FC  C1 E9 06					shr     cx, 6
 D0FF  C1 E2 0A					shl     dx, 10      ; CX:DX = HDSize * 1024
 D102				DiskGetTypeexit:        
 D102  1F					pop     ds          ; discard ret address
 D103  1F					pop     ds          ; discard DS
 D104  80 36 0092 08				xor     byte ptr HDOpStarted, 8     ; CF <- 0 
 D109  EB 8D					jmp     short   exit1        

 D10B				DiskExtInstCheck:
 D10B  86 DF					xchg    bl, bh
 D10D  B4 FF					mov     ah, -1
 D10F  B9 0001					mov     cx, 1       ; extended disk access functions (AH=42h-44h,47h,48h) supported
 D112  80 FA 80					cmp     dl, 80h
 D115  75 6A					jne     short notready
 D117  EB E9					jmp     short DiskGetTypeexit

 D119				DiskReset:
 D119				DiskChanged:
 D119				DiskPark:
 D119  B4 00					mov     ah, 0       ; success
 D11B  C3					ret

 D11C				DiskGetStatus:
 D11C  8A 26 0074				mov     ah, HDLastError
 D120  C3					ret
					  
 D121				DiskVerify:
 D121  BD D8D4 R				mov     bp, sdverify
 D124  EB 08					jmp     short   DiskRead1
 D126				DiskWrite:
 D126  BD D954 R				mov     bp, sdwrite
 D129  EB 03					jmp     short   DiskRead1
 D12B				DiskRead:
 D12B  BD D8D9 R				mov     bp, sdread
 D12E				DiskRead1:        
 D12E  84 C0					test    al, al
 D130  74 E7					jz      short DiskReset
 D132  80 FA 80					cmp     dl, 80h
 D135  75 4A					jne     short notready
 D137  B4 04					mov     ah, 4
 D139  F6 C1 3F					test    cl, 3fh
 D13C  74 18					jz      short DiskReadend   ; bad sector 0
 D13E  60					pusha
 D13F  B4 00					mov     ah, 0
 D141  50					push    ax
 D142  E8 0012					call    HCStoLBA
 D145  59					pop     cx
 D146  51					push    cx        
 D147  FF D5					call    bp              ; DX:AX sector, ES:BX buffer, CX=sectors, returns AX=read sectors
 D149  59					pop     cx
 D14A  2B C8					sub     cx, ax
 D14C  F7 D9					neg     cx              ; CF=1 if cx != 0
 D14E  C0 D4 03					rcl     ah, 3           ; AH = 4*CF (sector not found / read error)
 D151  8E D8					mov     ds, ax
 D153  61					popa
 D154  8C D8					mov     ax, ds
 D156				DiskReadend:
 D156  C3					ret

 D157				HCStoLBA:       ; CX = {cyl[7:0], cyl[9:8], sect[5:0]}, DH = head. Returns DX:AX LBA
 D157  8A C5					mov     al, ch
 D159  8A E1					mov     ah, cl
 D15B  C0 EC 06					shr     ah, 6
 D15E  C1 EA 08					shr     dx, 8
 D161  6B D2 3F					imul    dx, 63
 D164  83 E1 3F					and     cx, 3fh
 D167  03 CA					add     cx, dx
 D169  49					dec     cx
 D16A  BA 3EC1					mov     dx, 255*63
 D16D  F7 E2					mul     dx
 D16F  03 C1					add     ax, cx
 D171  83 D2 00					adc     dx, 0
 D174  C3					ret       
				;    unsigned int s = cs & 0x3f;
				;    unsigned int c = ((cs & 0xc0) << 2) | (cs >> 8);
				;    return (c*255l + h)*63l + s - 1l;

 D175				DiskFormat:
 D175				DiskInit:
 D175				DiskSeek:
 D175				DiskRst:
 D175				DiskReady:
 D175				DiskRecalibrate:
 D175				DiskDiag:
 D175				DiskExtSeek:
 D175  83 3E 0094 00				cmp     word ptr HDSize, 0
 D17A  74 05					je      short notready
 D17C  80 FA 80					cmp     dl, 80h
 D17F  74 98					je      short DiskReset
 D181				notready:        
 D181  B4 AA					mov     ah, 0aah        ; disk not ready
 D183  C3					ret

 D184				DiskGetParams:
 D184  80 FA 80					cmp     dl, 80h
 D187  B4 07					mov     ah, 7
 D189  75 CB					jne     short DiskReadend   ; ret
 D18B  B3 00					mov     bl, 0   ; ???
 D18D  A1 0094					mov     ax, HDSize
 D190  8B D0					mov     dx, ax
 D192  C1 E0 0A					shl     ax, 10
 D195  C1 EA 06					shr     dx, 6
 D198  83 E8 1E					sub     ax, 30
 D19B  83 DA 00					sbb     dx, 0
 D19E  B9 3EC1					mov     cx, 63*255
 D1A1  F7 F1					div     cx
 D1A3  48					dec     ax
 D1A4  3D 03FE					cmp     ax, 3feh
 D1A7  76 03					jbe     dgpok
 D1A9  B8 03FE					mov     ax, 3feh
 D1AC				dgpok:        
 D1AC  86 C4					xchg    al, ah
 D1AE  C0 E0 06					shl     al, 6
 D1B1  0C 3F					or      al, 3fh
 D1B3  8B C8					mov     cx, ax
 D1B5  BA FE01					mov     dx, 0fe01h
 D1B8  33 C0					xor     ax, ax
 D1BA  C3					ret        

 D1BB				DiskExtVerify:
 D1BB  BD D8D4 R				mov     bp, sdverify
 D1BE  EB 08					jmp     short DiskExtRead1
 D1C0				DiskExtWrite:
 D1C0  BD D954 R				mov     bp, sdwrite
 D1C3  EB 03					jmp     short DiskExtRead1
 D1C5				DiskExtRead:
 D1C5  BD D8D9 R				mov     bp, sdread
 D1C8				DiskExtRead1:
 D1C8  80 FA 80					cmp     dl, 80h
 D1CB  75 B4					jne     short notready
 D1CD  06					push    es
 D1CE  50					push    ax
 D1CF  60					pusha
 D1D0  8B DC					mov     bx, sp
 D1D2  36: 8E 5F 1A				mov     ds, ss:[bx+26]
 D1D6  8B 4C 02					mov     cx, [si+2]
 D1D9  C4 5C 04					les     bx, [si+4]
 D1DC  8B 44 08					mov     ax, [si+8]
 D1DF  8B 54 0A					mov     dx, [si+10]
 D1E2  1E					push    ds
 D1E3  56					push    si
 D1E4  FF D5					call    bp
 D1E6  5E					pop     si
 D1E7  1F					pop     ds
 D1E8  2B 44 02					sub     ax, [si+2]
 D1EB  01 44 02					add     [si+2], ax
 D1EE  61					popa
 D1EF  58					pop     ax
 D1F0  1A E4					sbb     ah, ah
 D1F2  80 E4 04					and     ah, 4
 D1F5  07					pop     es
 D1F6  C3					ret

 D1F7				DiskExtGetParams:
 D1F7  80 FA 80					cmp     dl, 80h
 D1FA  75 85					jne     short notready
 D1FC  50					push    ax
 D1FD  A1 0094					mov     ax, HDSize   
 D200  8B EC					mov     bp, sp
 D202  8E 5E 08					mov     ds, [bp+8]
 D205  33 ED					xor     bp, bp
 D207  C7 04 001A				mov     word ptr [si], 1ah      ; size
 D20B  C7 44 02 000B				mov     word ptr [si+2], 0bh    ; flags
 D210  C7 44 04 03FF				mov     word ptr [si+4], 1023   ; cylinders
 D215  89 6C 06					mov     word ptr [si+6], bp
 D218  C7 44 08 00FF				mov     word ptr [si+8], 255    ; heads
 D21D  89 6C 0A					mov     word ptr [si+10], bp
 D220  C7 44 0C 003F				mov     word ptr [si+12], 63     ; sectors/track
 D225  89 6C 0E					mov     word ptr [si+14], bp
 D228  89 44 10					mov     word ptr [si+16], ax
 D22B  C1 64 10 0A				shl     word ptr [si+16], 10
 D22F  C1 E8 06					shr     ax, 6
 D232  89 44 12					mov     word ptr [si+18], ax
 D235  89 6C 14					mov     word ptr [si+20], bp
 D238  89 6C 16					mov     word ptr [si+22], bp
 D23B  C7 44 18 0200				mov     word ptr [si+24], 512   ; bytes/sector
 D240  58					pop     ax
 D241  B4 00					mov     ah, 0
 D243  C3					ret 

 D244				DiskReadSectBuffer:
 D244				DiskWriteSectBuffer:
 D244				DiskSetDASDType:
 D244				DiskSetMediaType:
 D244				DiskExtLock:
 D244				DiskExtEject:
 D244  B4 01					mov     ah, 1       ; unsupported fn
 D246  C3					ret

 D247				int13   endp


				OFFDX MACRO n
					IF n LE -3 OR n GE 3
						add		dx, n
					ENDIF
					IF n EQ -2
						dec		dx
					ENDIF 
					IF n EQ -1 or n EQ -2
						dec		dx
					ENDIF
					IF n EQ 1 or n EQ 2
						inc		dx
					ENDIF 
					IF n eq 2
						inc		dx
					ENDIF
				ENDM
				; --------------------- INT 14h - Serial port I/O ----------------
 = 0000				ComPort		equ		0
 = 0000				THR			equ		0	; Transmit holding buffer
 = 0000				RBR			equ		0	; Receive buffer
 = 0000				DLL			equ		0	; divisor latch low byte (DLAB = 1)
 = 0001				DLH			equ		1	; divisor latch high byte	(DLAB = 1)
 = 0001				IER			equ		1	; Interrupt enable register
 = 0003				LCR			equ		3	; line control register (DLAB, BrkEnable, PPP, S, LL)
 = 0005				LSR			equ		5	; line status register
 = 0006				MSR			equ		6	; Modem status register

				; AH=function number, AL=char sent or received, DX=zero based COM index. Preserve all registers except AX
 D247				int14 proc near
 D247  1E					push	ds
 D248  52					push	dx
 D249  56					push	si
 D24A  6A 40					push	40h
 D24C  1F					pop		ds
 D24D  8B F2					mov		si, dx
 D24F  03 F6					add		si, si
 D251  8B 14					mov		dx, ComPort[si]
						OFFDX	LCR
 D253  83 C2 03		     1			add		dx, LCR
 D256  8B F0					mov		si, ax
 D258  EC					in		al, dx
 D259  24 7F					and		al, 7fh		; clear DLAB bit
 D25B  EE					out		dx, al
						OFFDX	LSR-LCR
 D25C  42		     1			inc		dx
 D25D  42		     1			inc		dx
 D25E  8B C6					mov		ax, si
 D260  C1 EE 08					shr		si, 8
 D263  74 0D					jz		short SetCharFormat
 D265  4E					dec		si
 D266  74 43					jz		short STransmit
 D268  4E					dec		si
 D269  74 51					jz		short SReceive
 D26B  4E					dec		si
 D26C  74 33					jz		short GetPortStatus
				;		dec		si
				;		jz		short SetCharFormatExt
 D26E				SExit:
 D26E  5E					pop		si
 D26F  5A					pop		dx
 D270  1F					pop		ds
 D271  CF					iret

				; ----- Set COM char format --------
				; AL = BBBPPSLL (BB=000..111 for baud 110,150,300,600,1200,2400,4800,9600)
				; returns LSR in AH and MSR in AL
 D272				SetCharFormat:		; DX = LSR
 D272  52					push	dx
 D273  51					push	cx
 D274  8A C8					mov		cl, al
 D276  8A E8					mov		ch, al
						OFFDX	LCR-LSR
 D278  4A		     1			dec		dx
 D279  4A		     1			dec		dx
 D27A  EC					in		al, dx
 D27B  0C 80					or		al, 80h		; set DLAB=1
 D27D  EE					out		dx, al
 D27E  C0 E9 05					shr		cl, 5
 D281  B8 0417					mov		ax, 417h
 D284  74 05					jz		short Baud110
 D286  B8 0300					mov		ax, 300h
 D289  D3 E8					shr		ax, cl
 D28B				Baud110:
						OFFDX	DLL-LCR
 D28B  83 C2 FD		     1			add		dx, DLL-LCR
 D28E  EE					out		dx, al		; set baud low
						OFFDX	DLH-DLL
 D28F  42		     1			inc		dx
 D290  8A C4					mov		al, ah
 D292  EE					out		dx, al		; set baud high
						OFFDX	LCR-DLH
 D293  42		     1			inc		dx
 D294  42		     1			inc		dx
 D295  8A C5					mov		al, ch
 D297  24 1F					and		al, 1fh
 D299  EE					out		dx, al		; set format, DLAB=0

						OFFDX	IER-LCR
 D29A  4A		     1			dec		dx
 D29B  4A		     1			dec		dx
 D29C  32 C0					xor		al, al
 D29E  EE					out		dx, al		; disable all interrupts
 D29F  59					pop		cx
 D2A0  5A					pop		dx

				; ----- get COM port status --------
 D2A1				GetPortStatus:			; DX = LSR
						OFFDX	MSR-LSR
 D2A1  42		     1			inc		dx
 D2A2  EC					in		al, dx		; read modem status
						OFFDX	LSR-MSR
 D2A3  4A		     1			dec		dx
 D2A4				GetPortStatus1:
 D2A4  8A E0					mov		ah, al
 D2A6  EC					in		al, dx		; read line (port) status
 D2A7  86 E0					xchg	ah, al
 D2A9  EB C3					jmp		short SExit
						
				; ----- Transmit char to COM port --------
				; Waits for THRE(bit5 in LSR) and then sends AL. returns LSR in AH
 D2AB				STransmit:			; DX = LSR
 D2AB  52					push	dx
 D2AC  8A E0					mov		ah, al
 D2AE				STr1:
 D2AE  EC					in		al, dx
 D2AF  A8 20					test	al, 20h
 D2B1  74 FB					jz		short STr1
						OFFDX	THR-LSR
 D2B3  83 C2 FB		     1			add		dx, THR-LSR
 D2B6  8A C4					mov		al, ah
 D2B8  EE					out		dx, al
 D2B9				STr2:
 D2B9  5A					pop		dx
 D2BA  EB E8					jmp		short GetPortStatus1

				; ----- receive char from COM port --------
				; Waits for RDA(bit0 in  LSR) and returns the received char in AL, and the LSR in AH
 D2BC				SReceive:			; DX = LSR
 D2BC  52					push	dx
 D2BD				SReceive1:
 D2BD  EC					in		al, dx
 D2BE  A8 01					test	al, 1
 D2C0  74 FB					jz		short SReceive1
						OFFDX	RBR-LSR
 D2C2  83 C2 FB		     1			add		dx, RBR-LSR
 D2C5  EC					in		al, dx
 D2C6  EB F1					jmp		short Str2


				; ----- Set COM char format extended --------
				;SetCharFormatExt:
 D2C8				int14 endp

				; --------------------- INT 15h - Extended services ----------------
 = ds:[98h]			UFPtr           equ     <ds:[98h]>
 = ds:[9ch]			WaitCount       equ     <ds:[9ch]>
 = ds:[0a0h]			UWaitFlag       equ     <ds:[0a0h]>
 = ds:[0a1h]			HandlerPtr      equ     <ds:[0a1h]> ; 4 bytes
 = ds:[0a5h]			DataBuffer      equ     <ds:[0a5h]> ; 3 bytes
 = ds:[067h]			DataCounter     equ     <ds:[067h]> ; 1 byte
 = ds:[068h]			PacketSize      equ     <ds:[068h]> ; 1 byte, 0->3bytes, 1->4bytes
 = 7B60				FreeXMSKb       equ     RAMSize*64 - 640 - 512 - 32	;total - DOS - VGA - BIOS

				; ------------ MovExt
 D2C8				IncSeg: ; DX = segment port address
 D2C8  75 25					jnz     short SetSegExit
 D2CA  ED					in      ax, dx
 D2CB  25 01FF					and     ax, RAMSize - 1
 D2CE  40					inc     ax
 D2CF  83 F8 12					cmp     ax, 12h
 D2D2  75 02					jne     short IncSeg1
 D2D4  33 C0					xor     ax, ax
 D2D6				IncSeg1:
 D2D6  83 F8 0C					cmp     ax, 0ch
 D2D9  75 0B					jne     short SetSeg2
 D2DB				SetSeg: ; DX = segment port address, ax = logical segment (0..RAMSize-1)    
 D2DB  25 01FF					and     ax, RAMSize - 1
 D2DE  83 F8 0C					cmp     ax, 0ch
 D2E1  72 0B					jb      short SetSeg1
 D2E3  83 C0 06					add     ax, 6
 D2E6				SetSeg2:        
 D2E6  3D 0200					cmp     ax, RAMSize
 D2E9  72 03					jb      short SetSeg1
 D2EB  2D 01F4					sub     ax, RAMSize - 0ch
 D2EE				SetSeg1:
 D2EE  EF					out     dx, ax          
 D2EF				SetSegExit:              
 D2EF  C3					ret

 = 0001				MovSeg  equ     01h
 D2F0 0000			savess  dw      0
 D2F2 D2F6 R 0000		savesp  dw      MovExt, 0 ; tmp stack
				; Log(idx) to Phy(val) segment map (RAMSize segs): 0,1,2,3,4,5,6,7,8,9,a,b,12h,13h,...,RAMSize-2,RAMSize-1,c,d,e,f,10h,11h, then wrap to 0,1,2,...
 D2F6				MovExt:
 D2F6  06					push    es
 D2F7  1E					push    ds
 D2F8  60					pusha
 D2F9  FA					cli
 D2FA  2E: 8C 16 D2F0 R				mov     cs:savess, ss
 D2FF  0E					push    cs
 D300  17					pop     ss
 D301  2E: 87 26 D2F2 R				xchg    sp, cs:savesp
 D306  BA 0082					mov     dx, 80h + MovSeg + 1
 D309  E3 6C					jcxz    short MovExt_exit
 D30B  06					push    es
 D30C  1F					pop     ds
 D30D  FC					cld
 D30E  8A 44 1C					mov     al, [si+1ch]
 D311  8A 64 1F					mov     ah, [si+1fh]
 D314  8A 5C 14					mov     bl, [si+14h]
 D317  8A 7C 17					mov     bh, [si+17h]
 D31A  8B 7C 1A					mov     di, [si+1ah]
 D31D  8B 74 12					mov     si, [si+12h]
 D320  E8 FFB8					call    SetSeg      ; 02000h = destination, DX=82h
 D323  4A					dec     dx
 D324  93					xchg    ax, bx
 D325  E8 FFB3					call    SetSeg      ; 01000h = source, DX=81h
 D328  68 1000					push    MovSeg shl 12 
 D32B  1F					pop     ds
 D32C  68 2000					push    (MovSeg + 1) shl 12
 D32F  07					pop     es
 D330  33 DB					xor     bx, bx
 D332  03 C9					add     cx, cx
 D334  13 DB					adc     bx, bx      ; BX:CX = bytes to transfer
				; move from 01000h:si to 02000h:di, 2*cx bytes
 D336				MovExtLoop:
 D336  42					inc     dx          ; 82h
 D337  8B C6					mov     ax, si
 D339  3B C7					cmp     ax, di
 D33B  77 02					ja      short MovExt1
 D33D  8B C7					mov     ax, di
 D33F				MovExt1:
 D33F  F7 D8					neg     ax
 D341  83 D3 FF					adc     bx, -1
 D344  2B C8					sub     cx, ax
 D346  83 DB 00					sbb     bx, 0
 D349  91					xchg    ax, cx      ; cx = bytes to move, bx:ax = bytes left for the next transfer
 D34A  79 05					jns     short MovExt2   ; ax <= bx:cx     
 D34C  03 C8					add     cx, ax
 D34E  33 C0					xor     ax, ax
 D350  43					inc     bx
 D351				MovExt2:
 D351  A4					movsb               ; if CX = 0 transfer 10000h bytes
 D352  49					dec     cx
 D353  74 0F					jz      short MovExt_next
 D355  F7 C6 0001				test    si, 1       ; read align
 D359  74 02					jz      short raligned
 D35B  A4					movsb
 D35C  49					dec     cx
 D35D				raligned:
 D35D  D1 E9					shr     cx, 1
 D35F  F3/ A5					rep     movsw
 D361  73 01					jnc     short MovExt_next
 D363  A4					movsb
 D364				MovExt_next:
 D364  8B C8					mov     cx, ax
 D366  0B C3					or      ax, bx
 D368  74 0D					jz      short MovExt_exit  ; finalized
 D36A  85 FF					test    di, di
 D36C  E8 FF59					call    incseg      ; does nothing if ZF == 0, dx = 8bh
 D36F  4A					dec     dx          ; 81h
 D370  85 F6					test    si, si      
 D372  E8 FF53					call    incseg      ; dx = 81h
 D375  EB BF					jmp     short MovExtLoop
 D377				MovExt_exit:
 D377  B8 0002					mov     ax, MovSeg + 1
 D37A  EF					out     dx, ax      ; 82h
 D37B  48					dec     ax
 D37C  4A					dec     dx
 D37D  EF					out     dx, ax      ; 81h
 D37E  2E: 8E 16 D2F0 R				mov     ss, cs:savess
 D383  2E: 87 26 D2F2 R				xchg    sp, cs:savesp
 D388  61					popa
 D389  1F					pop     ds
 D38A  07					pop     es
 D38B  32 E4					xor     ah, ah
 D38D  EB 38					jmp     short exit_ax
 D38F				MovExtProxy:
 D38F  E9 FF64					jmp     MovExt        

 D392				int15:
 D392  80 FC 4F					cmp     ah, 4fh
 D395  74 34					je      short exit_iret
 D397  86 C4					xchg    al, ah
 D399  3C 80					cmp     al, 80h
 D39B  72 27					jb      short exit15; CF=1  for <80h
 D39D  3C 83					cmp     al, 83h
 D39F  72 22					jb      short done  ; no error for 80, 81, 82
 D3A1  74 29					je      short SetEventWait; 83
 D3A3  3C 86					cmp     al, 86h
 D3A5  72 1D					jb      short exit15; CF=1 for 84, 85
 D3A7  74 58					je      short Wait1 ; 86
 D3A9  3C 88					cmp     al, 88h
 D3AB  72 E2					jb      short MovExtProxy ; 87
 D3AD  74 6B					je      short ExtSize     ; 88
 D3AF  3C 90					cmp     al, 90h
 D3B1  72 11					jb      short  exit15; CF=1 for 89..8f
 D3B3  3C 92					cmp     al, 92h
 D3B5  72 0C					jb      short done  ; no error for 90, 91
 D3B7  3C C0					cmp     al, 0c0h
 D3B9  72 09					jb      short exit15; CF=1 for 92..bf
 D3BB  74 62					je      short GetConfig   ; c0
 D3BD  3C C2					cmp     al, 0c2h
 D3BF  72 03					jb      short exit15; CF=1 for c1
 D3C1  74 65					je      short Mouse ; c2
 D3C3				done:
 D3C3  F5					cmc                 ; CF=1 for >c2
 D3C4				exit15:
 D3C4  B8 8600					mov     ax, 8600h
 D3C7				exit_ax:        
 D3C7  FB					sti
 D3C8  CA 0002					retf    2           ; discard flags (need to keep CF)
 D3CB				exit_iret:
 D3CB  CF					iret        

				; ------------ SetEventWait
 D3CC				SetEventWait:
 D3CC  1E					push    ds
 D3CD  6A 40					push    40h
 D3CF  1F					pop     ds
 D3D0  80 F4 01					xor     ah, 1
 D3D3  74 21					jz      short cancel
 D3D5  84 26 00A0				test    ah, byte ptr UWaitFlag ; ah=1
 D3D9  75 22					jnz     short busy  ; CF=0
 D3DB  B8 03E7					mov     ax, 1000-1  ; 1ms
 D3DE  E7 70					out     70h, ax     ; restart RTC timer
 D3E0  89 1E 0098				mov     UFPtr[0], bx
 D3E4  8C 06 009A				mov     UFPtr[2], es
 D3E8  03 C2					add     ax, dx
 D3EA  83 D1 00					adc     cx, 0
 D3ED  A3 009C					mov     WaitCount[0], ax
 D3F0  89 0E 009E				mov     WaitCount[2], cx
 D3F4  B4 01					mov     ah, 1       ; wait in progress
 D3F6				cancel:
 D3F6  88 26 00A0				mov     byte ptr UWaitFlag, ah   
 D3FA  CD 70					int     70h
 D3FC  F9					stc                 ; no error
 D3FD				busy:   
 D3FD  F5					cmc                 ; eror        
 D3FE				nowait:
 D3FE  1F					pop     ds
 D3FF  EB C3					jmp     short exit15

				; ------------ Wait
 D401				Wait1:
 D401  06					push    es
 D402  53					push    bx
 D403  B8 8300					mov     ax, 8300h
 D406  6A 4A					push    4ah
 D408  07					pop     es
 D409  33 DB					xor     bx, bx      ; user wait flag address=0040:00a0
 D40B  CD 15					int     15h         ; returns with IF = 1
 D40D  72 07					jc      short wbusy
 D40F				wloop:        
 D40F  F4					hlt   
 D410  26: F6 07 80				test    byte ptr es:[bx], 80h
 D414  74 F9					jz      short wloop
 D416				wbusy:        
 D416  5B					pop     bx
 D417  07					pop     es
 D418  EB AA					jmp     short exit15
						

				; ------------ ExtSize
 D41A				ExtSize:
 D41A  B8 7B60					mov     ax, FreeXMSKb
 D41D  EB A8					jmp     short exit_ax
						
				; ------------ GetConfig
 D41F				GetConfig:
 D41F  33 C0					xor     ax, ax
 D421  0E					push    cs
 D422  07					pop     es
 D423  BB D542 R				mov     bx, offset SysParams
 D426  EB 9F					jmp     short exit_ax
						
				; ------------ Mouse 
 D428				Mouse:
 D428  1E					push    ds
 D429  52					push    dx
 D42A  6A 40					push    40h
 D42C  1F					pop     ds
 D42D  F6 06 0010 04				test    byte ptr EquipmentWord, 4 ; ps2 mouse equipement word
 D432  75 15					jnz     short mouse_present
 D434				if_err:
 D434  B8 03A7					mov     ax, 03a7h   ; interface error (no mouse present)
 D437  E6 64					out     64h, al     ; disable mouse
 D439				errexit:        
 D439  F9					stc                 ; error
 D43A				exitok:        
 D43A  9C					pushf               ; save CF
 D43B  50					push    ax
 D43C  E8 00D6					call    enablemouseinterrupt
 D43F  58					pop     ax

 D440  E8 03B9					call    enableKbIfPresent
 D443  9D					popf
 D444  5A					pop     dx
 D445  1F					pop     ds
 D446  E9 FF7E					jmp     exit_ax
 D449				mouse_present:
 D449  8A C4					mov     al, ah                                  
 D44B  B4 01					mov     ah, 1       ; invalid function
 D44D  3C 07					cmp     al, 7
 D44F  77 E8					ja      short errexit
 D451  50					push    ax

 D452  E8 00D3					call    disablemouseinterrupt

 D455  FB					sti                 ; allow interrupts for a short time, to flush possible pending KB/mouse requests
 D456  B0 AD					mov     al, 0adh
 D458  E6 64					out     64h, al     ; disable kb interface
 D45A  58					pop     ax
 D45B  3C 01					cmp     al, 1
 D45D  FA					cli                 ; from now on we are working with ints disabled, as the following code is highly non re-entrant
 D45E  72 1C					jb      short en_dis
 D460  74 33					je      short reset
 D462  3C 03					cmp     al, 3
 D464  72 40					jb      short sampling
 D466  74 5D					je      short resolution
 D468  3C 05					cmp     al, 5
 D46A  72 63					jb      short gettype
 D46C  74 27					je      short reset
 D46E  3C 06					cmp     al, 6
 D470  74 75					je      short extend

				; ------------- set handler
 D472  89 1E 00A1				mov     HandlerPtr[0], bx
 D476  8C 06 00A3				mov     HandlerPtr[2], es
 D47A  EB 15					jmp     short exit_success1        

				; ------------- enable/disable
 D47C				en_dis:
 D47C  B8 02F5					mov     ax, 02f5h   ; ah = invalid input
 D47F  2A C7					sub     al, bh
 D481  38 E7					cmp     bh, ah
 D483  73 B4					jnc     short errexit
 D485  8A E0					mov     ah, al
 D487  E8 0361					call    sendcmd     ; enable/disable data reporting (CF = 1)
 D48A				if_err1:        
 D48A  72 A8					jc      short if_err
 D48C				exit_success:
 D48C  C6 06 0067 00				mov     byte ptr DataCounter, 0
 D491				exit_success1:
 D491  32 E4					xor     ah, ah      ; success
 D493  EB A5					jmp     short exitok

				; ------------- reset
 D495				reset:
 D495  B4 F6					mov     ah, 0f6h    ; set defaults
 D497  F9					stc                 ; mouse command
 D498  E8 0350					call    sendcmd     
 D49B  72 97					jc      short if_err
 D49D  BB 00AA					mov     bx, 00aah
 D4A0  88 3E 0068				mov     byte ptr PacketSize, bh ; 3bytes packet
 D4A4  EB E6					jmp     short exit_success

				; ------------- sampling
 D4A6				sampling:
 D4A6  80 FF 06					cmp     bh, 6
 D4A9				badparam:
 D4A9  B4 02					mov     ah, 2       ; invalid input
 D4AB  77 8C					ja      short errexit
 D4AD  C1 EB 08					shr     bx, 8
 D4B0  2E: 8A A7 D53B R				mov     ah, cs:sample_tbl[bx]
 D4B5  50					push    ax
 D4B6  B4 F3					mov     ah, 0f3h    ; st sample rate
 D4B8				send2c:
 D4B8  F9					stc
 D4B9  E8 032F					call    sendcmd              
 D4BC  58					pop     ax
 D4BD  72 CB					jc      short if_err1
 D4BF				send1c:
 D4BF  F9					stc
 D4C0  E8 0328					call    sendcmd
 D4C3  EB C5					jmp     short if_err1

				; ------------- resolution
 D4C5				resolution:
 D4C5  80 FF 03					cmp     bh, 3
 D4C8  77 DF					ja      short badparam
 D4CA  53					push    bx
 D4CB  B4 E8					mov     ah, 0e8h    ; set resolution
 D4CD  EB E9					jmp     short send2c

				; ------------- gettype
 D4CF				gettype:
 D4CF  B4 F2					mov     ah, 0f2h
 D4D1  F9					stc
 D4D2  E8 0316					call    sendcmd
 D4D5  72 B3					jc      short if_err1
 D4D7  E8 02F7					call    getps2byte
 D4DA  72 AE					jc      short if_err1
 D4DC  8A F8					mov     bh, al
 D4DE  F6 D8					neg     al          ; CF=1 if al != 0
 D4E0  12 C7					adc     al, bh
 D4E2  A2 0068					mov     byte ptr PacketSize, al ; 3 or 4 bytes packet
 D4E5  EB A5					jmp     short exit_success
						
				; ------------- extended commands
 D4E7				extend:
 D4E7  84 FF					test    bh, bh
 D4E9  75 1F					jnz     short setscaling
 D4EB  B4 E9					mov     ah, 0e9h    ; status request
 D4ED  F9					stc
 D4EE  E8 02FA					call    sendcmd
 D4F1  72 97					jc      short if_err1
 D4F3  E8 02DB					call    getps2byte
 D4F6  72 92					jc      short if_err1
 D4F8  8A D8					mov     bl, al
 D4FA  E8 02D4					call    getps2byte
 D4FD  72 8B					jc      short if_err1
 D4FF  8A C8					mov     cl, al
 D501  E8 02CD					call    getps2byte
 D504  72 84					jc      short if_err1
 D506  5A					pop     dx  
 D507  50					push    ax          ; replace dx on stack
 D508  EB 82					jmp     short exit_success
 D50A				setscaling:    
 D50A  80 FF 02					cmp     bh, 2
 D50D  77 9A					ja      short badparam
 D50F  B4 E5					mov     ah, 0e5h    ; set scaling 1:1 or 2:1
 D511  02 E7					add     ah, bh
 D513  EB AA					jmp     short send1c

 D515				enablemouseinterrupt:
 D515  B0 20					mov     al, 20h
 D517  E6 64					out     064h, al
 D519  E4 60					in      al, 060h    ; read 8042 config byte
 D51B  0C 02					or      al, 02h     ; set enable mouse interrupt
 D51D  8A E0					mov     ah, al
 D51F  B0 60					mov     al, 60h
 D521  E6 64					out     064h, al
 D523  8A C4					mov     al, ah
 D525  E6 60					out     060h, al    ; send 8042 config byte
 D527  C3					ret
 D528				disablemouseinterrupt:
 D528  B0 20					mov     al, 20h
 D52A  E6 64					out     064h, al
 D52C  E4 60					in      al, 060h    ; read 8042 config byte
 D52E  24 FD					and     al, 0fdh     ; set disable mouse interrupt
 D530  8A E0					mov     ah, al
 D532  B0 60					mov     al, 60h
 D534  E6 64					out     064h, al
 D536  8A C4					mov     al, ah
 D538  E6 60					out     060h, al    ; send 8042 config byte
 D53A  C3					ret

 D53B 0A 14 28 3C 50 64		sample_tbl  db  10, 20, 40, 60, 80, 100, 200
       C8
 D542 08 00 FC 00 00		SysParams   db  8, 0, 0fch, 0, 0
				;--------------------------------------------------------------------------
				; Feature byte 1
				; b7: 1=DMA channel 3 used by hard disk
				; b6: 1=2 interrupt controllers present
				; b5: 1=RTC present
				; b4: 1=BIOS calls int 15h/4Fh every key
				; b3: 1=wait for extern event supported (Int 15h/41h)
				; b2: 1=extended BIOS data area used
				; b1: 0=AT or ESDI bus, 1=MicroChannel
				; b0: 1=Dual bus (MicroChannel + ISA)
				;--------------------------------------------------------------------------
 D547  10						db      10h
				;--------------------------------------------------------------------------
				; Feature byte 2
				; b7: 1=32-bit DMA supported
				; b6: 1=int16h, function 9 supported
				; b5: 1=int15h/C6h (get POS data) supported
				; b4: 1=int15h/C7h (get mem map info) supported
				; b3: 1=int15h/C8h (en/dis CPU) supported
				; b2: 1=non-8042 kb controller
				; b1: 1=data streaming supported
				; b0: reserved
				;--------------------------------------------------------------------------
 D548  44						db      44h
				;--------------------------------------------------------------------------
				; Feature byte 3
				; b7: not used
				; b6: reserved
				; b5: reserved
				; b4: POST supports ROM-to-RAM enable/disable
				; b3: SCSI on system board
				; b2: info panel installed
				; b1: Initial Machine Load (IML) system - BIOS on disk
				; b0: SCSI supported in IML
				;--------------------------------------------------------------------------
 D549  00						db      0
				;--------------------------------------------------------------------------
				; Feature byte 4
				; b7: IBM private
				; b6: EEPROM present
				; b5-3: ABIOS presence (011 = not supported)
				; b2: private
				; b1: memory split above 16Mb supported
				; b0: POSTEXT directly supported by POST
				;--------------------------------------------------------------------------
 D54A  00						db      0
				;--------------------------------------------------------------------------
				; Feature byte 5 (IBM)
				; b1: enhanced mouse
				; b0: flash EPROM
				;--------------------------------------------------------------------------
 D54B  00						db      0                                                


				; --------------------- INT 16h - keyboard interface ----------------
				;       AH      Description
				;       --      ------------------------------------------------
				;       00h     Get a key from the keyboard, return code in AX.
				;       01h     Test for available key, ZF=1 if none, ZF=0 and
				;               AX contains next key code if key available.
				;       02h     Get shift status. Returns shift key status in AL.
				;       03h     Set Autorepeat rate. BH=0,1,2,3 (delay time in quarter seconds), BL=0..1Fh for 30 char/sec to 2 char/sec repeat rate.
				;       05h     Store scan code (in CX) in the type ahead buffer.
				;       10h     Get a key (same as 00h in this implementation).
				;       11h     Test for key (same as 01h).
				;       12h     Get extended key status. Returns status in AX.

 = ds:[19h]			AltKpd          equ     <ds:[19h]>
 = ds:[1ah]			HeadPtr         equ     <ds:[1ah]>
 = ds:[1ch]			TailPtr         equ     <ds:[1ch]>
 = ds:[80h]			Buffer          equ     <ds:[80h]>;1eh
 = ds:[82h]			EndBuf          equ     <ds:[82h]>;3eh

 D54C				int16 proc near
 D54C  1E					push    ds
 D54D  56					push    si
 D54E  6A 40					push    40h
 D550  1F					pop     ds
 D551  86 C4					xchg    al, ah          ;shorter opcodes for al than ah
 D553  48					dec     ax
 D554  A8 EF					test    al, 0EFh        ;Check for 01h and 11h
 D556  74 3E					jz      short TestKey   ;TestKey does not need cld
 D558  40					inc     ax
 D559  FC					cld
 D55A  A8 EF					test    al, 0EFh        ;Check for 0h and 10h
 D55C  74 1C					jz      short GetKey
 D55E  3C 03					cmp     al, 3           ;Check for 02h and 03h
 D560  72 78					jb      short GetStatus
 D562  74 7B					je      short SetAutoRpt   
 D564  3C 05					cmp     al, 5           ;Check for StoreKey function.
 D566  74 3D					je      short StoreKey
 D568  3C 09					cmp     al, 9           ;Get KB functionality
 D56A  74 08					je      short kbfunc     
 D56C  3C 12					cmp     al, 12h         ;Extended status call
 D56E  74 56					je      short ExtStatus
 D570  3C 92					cmp     al, 92h         ;stupid keyb.com 
 D572  75 02					jne     short Exit
 D574				kbfunc:
 D574  B0 24					mov     al, 24h         ;AL=20h (fn 10h, 12h supported, set typematic supported)        
 D576				Exit:        
 D576  5E					pop     si
 D577  1F					pop     ds
 D578  CF					iret                    ; unknown function, Restores flags.

 D579				GetKey1:                        ; wait for interrupt
 D579  F4					hlt
 D57A				GetKey: ; ----------- fn 00h, 10h
 D57A  B4 11					mov     ah, 11h
 D57C  CD 16					int     16h             ;See if key is available (IF becomes 1 after this int)
 D57E  74 F9					jz      short GetKey1   ;Wait for keystroke.
 D580  FA					cli                     ;Critical region! Ints off.
 D581  8B 36 001A				mov     si, HeadPtr     ;Ptr to next character.
 D585  AD					lodsw                   ;Get the character, Bump up HeadPtr
 D586  3B 36 0082				cmp     si, EndBuf
 D58A  72 04					jb      short noWrap
 D58C  8B 36 0080				mov     si, Buffer
 D590				noWrap:             
 D590  89 36 001A				mov     HeadPtr, si
 D594  EB E0					jmp     short Exit

 D596				TestKey: ; ---------- fn 01h
 D596  8B 36 001A				mov     si, HeadPtr
 D59A  3B 36 001C				cmp     si, TailPtr     ;ZF=1, if empty buffer
 D59E  AD					lodsw                   ;BIOS returns avail keycode.
 D59F  FB					sti                     ;Ints back on.
 D5A0  5E					pop     si
 D5A1  1F					pop     ds
 D5A2  CA 0002					retf    2               ;Pop flags (ZF is important!)

 D5A5				StoreKey: ; ---------- fn 05h - Inserts the value in CX into the type ahead buffer.  
 D5A5  8B 36 001C				mov     si, TailPtr     ;Address where we can put next key code.
 D5A9  89 0C					mov     [si], cx        ;Store the key code away
 D5AB  46					inc     si
 D5AC  46					inc     si              ;Move on to next entry in buf
 D5AD  3B 36 0082				cmp     si, EndBuf
 D5B1  72 04					jb      short NoWrap1
 D5B3  8B 36 0080				mov     si, Buffer
 D5B7				 NoWrap1:
 D5B7  B0 01					mov     al, 1           ;no room
 D5B9  3B 36 001A				cmp     si, HeadPtr     ;Data overrun?
 D5BD  74 B7					je      short Exit      ;if so, ignore key entry.
 D5BF  89 36 001C				mov     TailPtr, si
 D5C3  48					dec     ax              ;al=0
 D5C4  EB B0					jmp     short Exit       

 D5C6				ExtStatus: ; ------- fn 12h - Retrieve the extended keyboard status and return it in AH, and the standard keyboard status in AL.    
 D5C6  A0 0018					mov     al, KbdFlags2
 D5C9  24 77					and     al, 01110111b   ;Clear final sysreq field, and final right alt bit.
 D5CB  A8 04					test    al, 100b        ;Test cur sysreq bit.
 D5CD  74 02					jz      short NoSysReq  ;Skip if it's zero.
 D5CF  2C 84					sub     al, 10000100b   ;Set final sysreq bit, clear final right ctl bit.
 D5D1				NoSysReq:
 D5D1  8A 26 0096				mov     ah, KbdFlags3
 D5D5  80 E4 0C					and     ah, 1100b       ;Grab rt alt/ctrl bits.
 D5D8  0A E0					or      ah, al          ;Merge into AH.

 D5DA				GetStatus: ; --------- fn 02h     
 D5DA  A0 0017					mov     al, KbdFlags1   ;Just return Std Status.
 D5DD				Exit1:
 D5DD  EB 97					jmp     short Exit

 D5DF				SetAutoRpt: ; ------ fn 03h
 D5DF  80 FC 05					cmp     ah, 5
 D5E2  75 92					jne     short Exit
 D5E4  52					push    dx
 D5E5  C0 E7 05					shl     bh, 5
 D5E8  80 E3 1F					and     bl, 1fh
 D5EB  0A DF					or      bl, bh
 D5ED  80 E3 7F					and     bl, 7fh
 D5F0  B4 00					mov     ah, 0           ; wait LED update progress to finalize
 D5F2  E8 0028					call    WaitFlag        ; leaves with IF=0
 D5F5  72 23					jc      short timeout
 D5F7  80 0E 0097 08				or      byte ptr KbdFlags4, SetRepeat    ; set auto repeat in progress
 D5FC  B4 F3					mov     ah, 0f3h        ; set typematic rate and delay
 D5FE  53					push    bx
 D5FF  32 DB					xor     bl, bl          ; send to kb
 D601  E8 01A8					call    sendps2byte
 D604  5B					pop     bx
 D605  72 0E					jc      short timeout1  ; send timeout
 D607  B4 18					mov     ah, SetRepeat or AckReceived ; test if ACK received
 D609  E8 0011					call    WaitFlag
 D60C  72 07					jc      short timeout1
 D60E  8A E3					mov     ah, bl
 D610  32 DB					xor     bl, bl          ; send to kb
 D612  E8 0197					call    sendps2byte     ; send data
 D615				timeout1:
 D615  80 26 0097 F7				and     byte ptr KbdFlags4, not SetRepeat   
 D61A				timeout:
 D61A  5A					pop     dx
 D61B  EB C0					jmp     short Exit1


 D61D				WaitFlag:   ; ah = desired KbdFlags4 & (AckReceived | LEDUpdate | SetRepeat)
 D61D  BA 03DA					mov     dx, 3dah
 D620  B7 C8					mov     bh, 8*25    ; wait for max 25 * VGA frame time
 D622				wf_loop:
 D622  FA					cli
 D623  A0 0097					mov     al, KbdFlags4
 D626  24 58					and     al, AckReceived or LEDUpdate or SetRepeat
 D628  38 E0					cmp     al, ah
 D62A  74 0A					je      short wf_ok ; flag ok, CF=0
 D62C  FB					sti
 D62D  EC					in      al, dx      ; get vblank
 D62E  32 C7					xor     al, bh
 D630  24 08					and     al, 8h
 D632  2A F8					sub     bh, al
 D634  73 EC					jnc     short wf_loop     ; IBF - buffer full, no timeout
 D636				wf_ok:
 D636  C3					ret
 D637				int16 endp

				; --------------------- INT 18h - BIOS Basic ------------------
 D637				int18 proc near
 D637  0E					push    cs
 D638  07					pop     es
 D639  BE D66C R				mov     si, offset booterrmsg
 D63C  E8 01E3					call    prts

				;-------------- RS232 bootstrap
 D63F  B0 B4					mov     al, 0b4h
 D641  E6 43					out     43h, al
 D643  B8 F000					mov     ax, 0f000h
 D646  E6 42					out     42h, al
 D648  E6 42					out     42h, al      ; 18Hz PIT CH2
 D64A  E7 01					out		1, ax		; disable auto flush on vblank (bit0)
 D64C  8E D8					mov		ds,ax
 D64E  8E C0					mov		es,ax

 D650  BE 0100					mov		si,100h
 D653  E8 012A					call	srecb
 D656  FA					cli
 D657  8A FC					mov		bh,ah
 D659  E8 0124					call	srecb
 D65C  8A DC					mov		bl,ah
 D65E				sloop:	
 D65E  E8 011F					call	srecb
 D661  88 24					mov		[si],ah
 D663  46					inc		si
 D664  4B					dec		bx
 D665  75 F7					jnz		short sloop
 D667  EA					db		0eah
 D668  0100 F000				dw		100h,0f000h

 D66C 4E 6F 20 62 6F 6F		booterrmsg db   'No boot device available, waiting on RS232 (115200bps, f000:100) ...', 13, 10, 0
       74 20 64 65 76 69
       63 65 20 61 76 61
       69 6C 61 62 6C 65
       2C 20 77 61 69 74
       69 6E 67 20 6F 6E
       20 52 53 32 33 32
       20 28 31 31 35 32
       30 30 62 70 73 2C
       20 66 30 30 30 3A
       31 30 30 29 20 2E
       2E 2E 0D 0A 00
 D6B3				int18 endp

				; --------------------- INT 19h - OS Bootstrap loader ------------------
 D6B3				int19 proc near
 D6B3  B8 0201					mov     ax, 201h
 D6B6  B9 0001					mov     cx, 1
 D6B9  BA 0080					mov     dx, 80h
 D6BC  6A 00					push    0
 D6BE  07					pop     es
 D6BF  BB 7C00					mov     bx, 7c00h
 D6C2  CD 13					int     13h
 D6C4  72 05					jc      int19err
 D6C6  EA					db      0eah
 D6C7  7C00 0000				dw      7c00h, 0     ; jmp far 0000h:7c00h
 D6CB				int19err:
 D6CB  CD 18					int     18h
 D6CD				int19 endp


				; --------------------- INT 1ah - Get System Time ------------------
 D6CD				int1a proc near
 D6CD  1E					push    ds
 D6CE  6A 40					push    40h
 D6D0  1F					pop     ds
 D6D1  80 FC 01					cmp     ah, 1
 D6D4  77 12					ja      clockexit
 D6D6  74 16					je      setclock
 D6D8  8B 16 006C				mov     dx, ds:[6ch]    ; read clock
 D6DC  8B 0E 006E				mov     cx, ds:[6eh]
 D6E0  A0 0070					mov     al, ds:[70h]
 D6E3				clockexit1:
 D6E3  C6 06 0070 00				mov     byte ptr ds:[70h], 0
 D6E8				clockexit:
 D6E8  F5					cmc     ; CF = 1 on error
 D6E9  1F					pop     ds
 D6EA  FB					sti
 D6EB  CA 0002					retf    2

 D6EE				setclock:
 D6EE  89 16 006C				mov     ds:[6ch], dx
 D6F2  89 0E 006E				mov     ds:[6eh], cx
 D6F6  F9					stc
 D6F7  EB EA					jmp     short clockexit1    
 D6F9				int1a endp


				; --------------------- INT 70h - RTC ------------------
 D6F9				int70 proc near
 D6F9  1E					push    ds
 D6FA  6A 40					push    40h
 D6FC  1F					pop     ds
 D6FD  F6 06 00A0 01				test    byte ptr UWaitFlag, 1    ; is wait in progress?
 D702  74 1B					jz      short exit1
 D704  81 2E 009C 03E8				sub     word ptr WaitCount[0], 1000
 D70A  83 1E 009E 00				sbb     word ptr WaitCount[2], 0
 D70F  73 14					jnc     short exit
 D711  C6 06 00A0 00				mov     byte ptr UWaitFlag, 0
 D716  53					push    bx
 D717  C5 1E 0098				lds     bx, UFPtr
 D71B  80 0F 80					or      byte ptr [bx], 80h
 D71E  5B					pop     bx
 D71F				exit1:
 D71F  50					push	ax
 D720  33 C0					xor		ax, ax
 D722  E7 70					out		70h, ax	; stop RTC
 D724  58					pop		ax
 D725				exit: 
 D725  50					push    ax
 D726  B0 20					mov     al, 20h
 D728  E6 A0					out     0a0h, al
 D72A  B0 20					mov     al, 20h
 D72C  E6 20					out     20h, al
 D72E  58					pop     ax
 D72F  1F					pop     ds
 D730  CF					iret
 D731				int70 endp

						
				; --------------------- INT 74h - mouse ------------------
 D731				int74 proc near
 D731  FC					cld
 D732  60					pusha
 D733  1E					push    ds
 D734  6A 40					push    40h
 D736  1F					pop     ds
 D737  B4 00					mov     ah, 0
 D739  E4 60					in      al, 60h
 D73B  8B D8					mov     bx, ax
 D73D  FE 06 0067				inc     byte ptr DataCounter
 D741  A0 0067					mov     al, DataCounter
 D744  8B F0					mov     si, ax
 D746  2C 03					sub     al, 3
 D748  77 0C					ja      short docall
 D74A  88 9C 00A4				mov     DataBuffer[si-1], bl
 D74E  3A 06 0068				cmp     al, PacketSize
 D752  75 21					jne     short nocall
 D754  B3 00					mov     bl, 0
 D756				docall:
 D756  88 3E 0067				mov     byte ptr DataCounter, bh    ; BH=0
 D75A  BE 00A3					mov     si, offset DataBuffer-2
 D75D  AD					lodsw
 D75E  0B 44 FC					or      ax, [si-4]
 D761  74 12					jz      short nocall
 D763  FB					sti
 D764  06					push    es
 D765  B4 00					mov     ah, 0
 D767  AC					lodsb
 D768  50					push    ax
 D769  AC					lodsb
 D76A  50					push    ax
 D76B  AC					lodsb
 D76C  50					push    ax
 D76D  53					push    bx
 D76E  FF 5C F9					call    far ptr [si-7]
 D771  83 C4 08					add     sp, 8
 D774  07					pop     es
 D775				nocall:        
 D775  B0 20					mov     al, 20h
 D777  E6 A0					out     0a0h, al
 D779  B0 20					mov     al, 20h
 D77B  E6 20					out     20h, al

 D77D  1F					pop     ds
 D77E  61					popa
 D77F  CF					iret
 D780				int74 endp


				; ----------------  serial receive byte 115200 bps --------------
 D780  B4 80			srecb:  mov     ah, 80h
 D782  BA 03DA					mov     dx, 3dah
 D785  B9 FA52					mov     cx, -5aeh ; (half start bit)
 D788  EC			srstb:  in      al, dx
 D789  C0 E8 02					shr     al, 2
 D78C  72 FA					jc      short srstb
 D78E  E4 42					in      al, 42h ; lo counter
 D790  02 E8					add     ch, al
 D792  E4 42					in      al, 42h ; hi counter, ignore
 D794				l1:
 D794  E8 0008					call    dlybit
 D797  EC					in      al, dx
 D798  C0 E8 02					shr     al, 2
 D79B  D0 DC					rcr     ah, 1
 D79D  73 F5					jnc     short l1
 D79F				dlybit:
 D79F  81 E9 0A5B				sub     cx, 0a5bh  ;  (full bit)
 D7A3				dly1:
 D7A3  E4 42					in      al, 42h
 D7A5  38 E8					cmp     al, ch
 D7A7  E4 42					in      al, 42h
 D7A9  75 F8					jnz     short dly1
 D7AB  C3					ret

				; -------------------- KB/Mouse access ----------------
 D7AC				sendps2byte proc near   ; ah=data, bl!=0 for mouse, 0 for kb. returns cf=1 if timeout (al = 8)
				; changes BH, AL
 D7AC  52					push    dx
 D7AD  BA 03DA					mov     dx, 3dah
 D7B0  B7 28					mov     bh, 8*5
 D7B2				sps2b2:
 D7B2  E4 64					in      al, 64h
 D7B4  A8 02					test    al, 2
 D7B6  74 0B					jz      short sps2b1; buffer empty
 D7B8  EC					in      al, dx      ; get vblank
 D7B9  32 C7					xor     al, bh
 D7BB  24 08					and     al, 8h
 D7BD  2A F8					sub     bh, al
 D7BF  73 F1					jnc     short sps2b2; IBF - buffer full, no timeout
 D7C1  EB 0C					jmp     short exit  ; timeout, CF=1
 D7C3				sps2b1:
 D7C3  84 DB					test    bl, bl      ; CF=0
 D7C5  74 04					jz      short sps2_kb
 D7C7  B0 D4					mov     al, 0d4h    ; next mouse
 D7C9  E6 64					out     64h, al
 D7CB				sps2_kb:
 D7CB  8A C4					mov     al, ah
 D7CD  E6 60					out     60h, al     ; send byte
 D7CF				exit:        
 D7CF  5A					pop     dx
 D7D0  C3					ret
 D7D1				sendps2byte endp

 D7D1				getps2byte proc near    ; returns al=data, zf=0 for mouse, 1 for kb, cf=1 if timeout (al=8)
				; changes BH, DX, AL
 D7D1  BA 03DA					mov     dx, 3dah
 D7D4  B7 28					mov     bh, 8*5
 D7D6				gps2b2:
 D7D6  E4 64					in      al, 64h
 D7D8  A8 01					test    al, 1
 D7DA  75 0A					jnz     short gps2b1     ; OBF (buffer full), continue
 D7DC  EC					in      al, dx     ; get vblank
 D7DD  32 C7					xor     al, bh
 D7DF  24 08					and     al, 8
 D7E1  2A F8					sub     bh, al
 D7E3  73 F1					jnc     short gps2b2     ; buffer empty, no timeout
 D7E5  C3					ret                ; timeout, CF=1
 D7E6				gps2b1:
 D7E6  A8 20					test    al, 20h    ; CF=0, ZF <- !MOBF
 D7E8  E4 60					in      al, 60h    ; read byte (if IF=1, this data may be invalid)
 D7EA  C3					ret
 D7EB				getps2byte endp

 D7EB				sendcmd proc near     ; ah = command, CF=1 for mouse, CF=0 for kb. returns CF=1 on error
 D7EB  1A DB					sbb     bl, bl      ; bl <- CF
 D7ED  E8 FFBC					call    sendps2byte 
 D7F0  72 09					jc      short exit
 D7F2				retry:        
 D7F2  E8 FFDC					call    getps2byte
 D7F5  72 04					jc      short exit        
 D7F7  3C FA					cmp     al, 0fah    ; ack (returns CF=1 on error, when al=8)
 D7F9  75 F7					jne     short retry
 D7FB				exit:
 D7FB  C3					ret
 D7FC				sendcmd endp

 D7FC				enableKbIfPresent proc near ; input DS = 40h
				; modify AL, flags
 D7FC  F6 06 0096 10				test    byte ptr KbdFlags3, 10h
 D801  74 04					jz      short noenablekb
 D803  B0 AE					mov     al, 0aeh
 D805  E6 64					out     64h, al     ; enable kb interface
 D807				noenablekb:        
 D807  C3					ret
 D808				enableKbIfPresent endp

				; ----------------------- default interrupt handler ---------------
 D808				defint  proc near
 D808  CF					iret
 D809				defint  endp             

				; ------------------------------- misc --------------------------
 D809				dispAX: 
 D809  52					push    dx
 D80A  33 D2					xor     dx, dx
 D80C  2E: F7 36 D820 R				div     word ptr cs:ten
 D811  85 C0					test    ax, ax
 D813  74 03					jz      dispAX1
 D815  E8 FFF1					call    dispAX
 D818				dispAX1:
 D818  92					xchg    ax, dx
 D819  05 0E30					add     ax, 0e00h + '0'
 D81C  CD 10					int     10h
 D81E  5A					pop     dx
 D81F  C3					ret        
 D820 000A			ten     dw      10

 D822				prts:   ; es:si = string
 D822  B4 0E					mov     ah, 0eh    
 D824  26: AC					lodsb   es:[si]
 D826  0A C0					or      al, al
 D828  74 04					jz      short prtse
 D82A  CD 10					int     10h
 D82C  EB F4					jmp     short prts
 D82E				prtse:
 D82E  C3					ret



				;---------------------  read/write byte ----------------------
 D82F  B0 FF			sdrb:   mov al,0ffh
 D831				sdsb:               ; in AL=byte, DX = 03dah, out AX=result
 D831  EE					out     dx, al
 D832  03 C0					add     ax, ax
 D834  EE					out     dx, al
 D835  03 C0					add     ax, ax
 D837  EE					out     dx, al
 D838  03 C0					add     ax, ax
 D83A  EE					out     dx, al
 D83B  03 C0					add     ax, ax
 D83D  EE					out     dx, al
 D83E  03 C0					add     ax, ax
 D840  EE					out     dx, al
 D841  03 C0					add     ax, ax
 D843  EE					out     dx, al
 D844  03 C0					add     ax, ax
 D846  EE					out     dx, al
 D847  ED					in      ax, dx
 D848  C3					ret

				;---------------------  write block ----------------------
 D849				sdwblk proc near              ; in SI=data ptr, DX=03dah, CX=size
 D849  D1 E9					shr     cx, 1
 D84B				sdwblk1:
 D84B  AC					lodsb
 D84C  EE					out     dx, al
 D84D  03 C0					add     ax, ax
 D84F  EE					out     dx, al
 D850  03 C0					add     ax, ax
 D852  EE					out     dx, al
 D853  03 C0					add     ax, ax
 D855  EE					out     dx, al
 D856  03 C0					add     ax, ax
 D858  EE					out     dx, al
 D859  03 C0					add     ax, ax
 D85B  EE					out     dx, al
 D85C  03 C0					add     ax, ax
 D85E  EE					out     dx, al
 D85F  03 C0					add     ax, ax
 D861  EE					out     dx, al
 D862  AC					lodsb
 D863  EE					out     dx, al
 D864  03 C0					add     ax, ax
 D866  EE					out     dx, al
 D867  03 C0					add     ax, ax
 D869  EE					out     dx, al
 D86A  03 C0					add     ax, ax
 D86C  EE					out     dx, al
 D86D  03 C0					add     ax, ax
 D86F  EE					out     dx, al
 D870  03 C0					add     ax, ax
 D872  EE					out     dx, al
 D873  03 C0					add     ax, ax
 D875  EE					out     dx, al
 D876  03 C0					add     ax, ax
 D878  EE					out     dx, al
 D879  E2 D0					loop    short sdwblk1
 D87B  C3					ret
 D87C				sdwblk endp

				;---------------------  read block ----------------------
 D87C				sdrblk proc near              ; in DI=data ptr, DX=03dah, CX=size. Returns CF = 0
 D87C  B0 FF					mov     al, 0ffh
 D87E  EE					out     dx, al
 D87F  D1 E9					shr     cx, 1         ; CF = 0
 D881  EE					out     dx, al
 D882  EB 05					jmp     short sdrblk2 
 D884				sdrblk1:
 D884  EE					out     dx, al
 D885  88 25					mov     [di], ah
 D887  EE					out     dx, al
 D888  47					inc     di
 D889				sdrblk2:
 D889  EE					out     dx, al
 D88A  90					nop
 D88B  EE					out     dx, al
 D88C  90					nop
 D88D  EE					out     dx, al
 D88E  90					nop
 D88F  EE					out     dx, al
 D890  90					nop
 D891  EE					out     dx, al
 D892  90					nop
 D893  EE					out     dx, al
 D894  ED					in      ax, dx
 D895  EE					out     dx, al
 D896  88 25					mov     [di], ah
 D898  EE					out     dx, al
 D899  47					inc     di
 D89A  EE					out     dx, al
 D89B  90					nop
 D89C  EE					out     dx, al
 D89D  90					nop
 D89E  EE					out     dx, al
 D89F  90					nop
 D8A0  EE					out     dx, al
 D8A1  90					nop
 D8A2  EE					out     dx, al
 D8A3  90					nop
 D8A4  EE					out     dx, al
 D8A5  ED					in      ax, dx
 D8A6  E2 DC					loop    short sdrblk1
 D8A8  88 25					mov     [di], ah
 D8AA  47					inc     di
 D8AB  C3					ret
 D8AC				sdrblk endp

				;---------------------  verify block ----------------------
 D8AC				sdvblk:              ; in DI=data ptr, DX=03dah, CX=size. Returns CF=1 on error
 D8AC  53					push    bx
 D8AD  32 DB					xor     bl, bl
 D8AF				sdvblk1:
 D8AF  E8 FF7D					call    sdrb
 D8B2  2A 25					sub     ah, [di]
 D8B4  0A DC					or      bl, ah
 D8B6  47					inc     di
 D8B7  E2 F6					loop    short sdvblk1
 D8B9  F6 DB					neg     bl  ; CF=1 if BL != 0
 D8BB  5B					pop     bx
 D8BC  C3					ret

				;---------------------  write command ----------------------
 D8BD				sdcmd8T:
 D8BD  E8 FF6F					call    sdrb
 D8C0				sdcmd:              ; in SI=6 bytes cmd buffer, DX=03dah, out AH = 0ffh on error
 D8C0  B9 0006					mov     cx, 6
 D8C3  E8 FF83					call    sdwblk
 D8C6				sdresp:
 D8C6  33 F6					xor     si, si
 D8C8				sdresp1:
 D8C8  E8 FF64					call    sdrb
 D8CB  46					inc     si
 D8CC  74 05					jz      short sdcmd1
 D8CE  80 FC FF					cmp     ah, 0ffh
 D8D1  74 F5					je      short sdresp1
 D8D3  C3			sdcmd1: ret         

				;---------------------  read ----------------------
 D8D4				sdverify:
 D8D4  68 D8AC R				push    sdvblk
 D8D7  EB 03					jmp     short sdread1
 D8D9				sdread:   ; DX:AX sector, ES:BX buffer, CX=sectors. returns AX=read sectors
 D8D9  68 D87C R				push    sdrblk   ; push proc address (read or verify) on stack
 D8DC				sdread1:        
 D8DC  50					push    ax
 D8DD  8A C2					mov     al, dl
 D8DF  50					push    ax
 D8E0  B2 51					mov     dl, 51h  ; CMD17
 D8E2  83 F9 01					cmp     cx, 1
 D8E5  74 01					je      short sdr1s
 D8E7  42					inc     dx      ; CMD18 - multiple sectors
 D8E8				sdr1s:
 D8E8  52					push    dx
 D8E9  8B F4					mov     si, sp 

 D8EB  BA 03DA					mov     dx, 3dah
 D8EE  B4 01					mov     ah, 1
 D8F0  EF					out     dx, ax       ; CS on
 D8F1  8B FB					mov     di, bx
 D8F3  8B D9					mov     bx, cx
 D8F5  8B E9					mov     bp, cx       ; save sectors number
 D8F7  16					push    ss
 D8F8  1F					pop     ds
 D8F9  C6 44 05 FF			mov	byte ptr [si+5], 0ffh ; checksum
 D8FD  E8 FFC0					call    sdcmd
 D900  83 C4 06					add     sp, 6
 D903  0A E4					or      ah, ah
 D905  75 41					jnz     short sdr11   ; error
 D907  06					push    es
 D908  1F					pop     ds
 D909				sdrms:
 D909  8B C7					mov     ax, di
 D90B  C1 E8 04					shr     ax, 4
 D90E  8C DE					mov     si, ds
 D910  03 C6					add     ax, si
 D912  8E D8					mov     ds, ax
 D914  83 E7 0F					and     di, 15
 D917  E8 FFAC					call    sdresp     ; wait for 0feh token
 D91A  80 FC FE					cmp     ah, 0feh
 D91D  75 29					jne     short sdr11; read token error 
 D91F  B5 02					mov     ch, 2      ; 512 byte sector
 D921  5E					pop     si
 D922  FF D6					call    si         ; sdrblk or sdvblk
 D924  56					push    si
 D925  9C					pushf
 D926  E8 FF06					call    sdrb       ; ignore CRC
 D929  E8 FF03					call    sdrb       ; ignore CRC
 D92C  9D					popf
 D92D  72 03					jc      short sdr3 ; verify error   
 D92F  4B					dec     bx
 D930  75 D7					jnz     short sdrms; multiple sectors
 D932				sdr3:        
 D932  83 FD 01					cmp     bp, 1
 D935  74 11					je      short sdr11; single sector
 D937  BE DA81 R				mov     si, offset SD_CMD12 ; stop transfer
 D93A  0E					push    cs
 D93B  1F					pop     ds
 D93C  E8 FF81					call    sdcmd
 D93F				sdr2:
 D93F  D0 EC					shr     ah, 1
 D941  73 05					jnc     short sdr11
 D943  E8 FEE9					call    sdrb
 D946  EB F7					jmp     short sdr2
 D948				sdr11:
 D948  58					pop     ax         ; remove proc address from stack
 D949				sdr1:       
 D949  33 C0					xor     ax, ax
 D94B  EF					out     dx, ax
 D94C  E8 FEE0					call    sdrb       ; 8T
 D94F  8B C5					mov     ax, bp
 D951  2B C3					sub     ax, bx
 D953  C3					ret     

				;---------------------  write ----------------------
 D954				sdwrite:   ; DX:AX sector, ES:BX buffer, CX=sectors, returns AX=wrote sectors
 D954  50					push    ax
 D955  8A C2					mov     al, dl
 D957  50					push    ax
 D958  B2 58					mov     dl, 58h  ; CMD24
 D95A  83 F9 01					cmp     cx, 1
 D95D  74 01					je      short sdw1s
 D95F  42					inc     dx      ; CMD25 - multiple sectors
 D960				sdw1s:
 D960  52					push    dx
 D961  8B F4					mov     si, sp 

 D963  BA 03DA					mov     dx, 3dah
 D966  B4 01					mov     ah, 1
 D968  EF					out     dx, ax       ; CS on
 D969  8B E9					mov     bp, cx       ; save sectors number
 D96B  16					push    ss
 D96C  1F					pop     ds
 D96D  C6 44 05 FF			mov	byte ptr [si+5], 0ffh ; checksum
 D971  E8 FF4C					call    sdcmd
 D974  83 C4 06					add     sp, 6
 D977  8B F3					mov     si, bx
 D979  8B DD					mov     bx, bp
 D97B  0A E4					or      ah, ah
 D97D  75 CA					jnz     short sdr1   ; error
 D97F  06					push    es
 D980  1F					pop     ds
 D981				sdwms:
 D981  8B C6					mov     ax, si
 D983  C1 E8 04					shr     ax, 4
 D986  8C DF					mov     di, ds
 D988  03 C7					add     ax, di
 D98A  8E D8					mov     ds, ax
 D98C  83 E6 0F					and     si, 15
 D98F  B0 FE					mov     al, 0feh      ; start token
 D991  83 FD 01					cmp     bp, 1
 D994  74 02					je      short sdw1s1
 D996  B0 FC					mov     al, 0fch   ; multiple sectors
 D998				sdw1s1:        
 D998  E8 FE96					call    sdsb     
 D99B  B5 02					mov     ch, 2      ; 512 byte sector
 D99D  E8 FEA9					call    sdwblk
 D9A0  E8 FE8C					call    sdrb       ; ignore CRC
 D9A3  E8 FE89					call    sdrb       ; ignore CRC
 D9A6  E8 FE86					call    sdrb       ; read response byte xxx00101
 D9A9  80 E4 0E					and     ah, 0eh
 D9AC  80 FC 04					cmp     ah, 4
 D9AF  75 98					jne     short sdr1 ; write error
 D9B1				sdwwait:
 D9B1  E8 FE7B					call    sdrb
 D9B4  D0 EC					shr     ah, 1
 D9B6  73 F9					jnc     short sdwwait     ; wait write completion
 D9B8  4B					dec     bx
 D9B9  75 C6					jnz     short sdwms       ; multiple sectors

 D9BB  83 FD 01					cmp     bp, 1
 D9BE  74 89					je      short sdr1
 D9C0  B0 FD					mov     al, 0fdh     ; multiple end transfer
 D9C2  E8 FE6C					call    sdsb 
 D9C5  E8 FE67					call	sdrb     
 D9C8				sdwwait1:
 D9C8  E8 FE64					call    sdrb
 D9CB  D0 EC					shr     ah, 1
 D9CD  73 F9					jnc     short sdwwait1     ; wait write completion
 D9CF  E9 FF77					jmp     sdr1
						
				;---------------------  init SD ----------------------
 D9D2				sdinit  proc near       ; returns AX = num kilosectors
 D9D2  1E					push    ds
 D9D3  51					push    cx
 D9D4  52					push    dx
 D9D5  56					push    si
 D9D6  57					push    di
 D9D7  BA 03DA					mov     dx, 3dah
 D9DA  B9 000A					mov     cx, 10
 D9DD				sdinit1:                   ; send 80T
 D9DD  E8 FE4F					call    sdrb
 D9E0  E2 FB					loop    short sdinit1

 D9E2  B4 01					mov     ah, 1
 D9E4  EF					out     dx, ax       ; select SD

 D9E5  BE DA6F R				mov     si, offset SD_CMD0
 D9E8  0E					push    cs
 D9E9  1F					pop     ds
 D9EA  E8 FED3					call    sdcmd
 D9ED  FE CC					dec     ah
 D9EF  75 70					jnz     short sdexit ; error
						
 D9F1  BE DA75 R				mov     si, offset SD_CMD8
 D9F4  E8 FEC6					call    sdcmd8T
 D9F7  FE CC					dec     ah
 D9F9  75 66					jnz     short sdexit ; error
 D9FB  B1 04					mov     cl, 4
 D9FD  2B E1					sub     sp, cx
 D9FF  8B FC					mov     di, sp
 DA01  16					push    ss
 DA02  1F					pop     ds
 DA03  E8 FE76					call    sdrblk
 DA06  58					pop     ax
 DA07  58					pop     ax
 DA08  80 FC AA					cmp     ah, 0aah
 DA0B  75 54					jne     short sdexit ; CMD8 error
 DA0D				repinit:        
 DA0D  BE DA8D R				mov     si, offset SD_CMD55
 DA10  0E					push    cs
 DA11  1F					pop     ds
 DA12  E8 FEA8					call    sdcmd8T
 DA15  E8 FE17					call    sdrb
 DA18  BE DA87 R				mov     si, offset SD_CMD41
 DA1B  E8 FEA2					call    sdcmd
 DA1E  FE CC					dec     ah
 DA20  74 EB					jz      short repinit
						
 DA22  BE DA93 R				mov     si, offset SD_CMD58
 DA25  E8 FE95					call    sdcmd8T
 DA28  B1 04					mov     cl, 4
 DA2A  2B E1					sub     sp, cx
 DA2C  8B FC					mov     di, sp
 DA2E  16					push    ss
 DA2F  1F					pop     ds
 DA30  E8 FE49					call    sdrblk
 DA33  58					pop     ax
 DA34  A8 40					test    al, 40h     ; test OCR bit 30 (CCS)
 DA36  58					pop     ax
 DA37  74 28					jz      short sdexit; no SDHC

 DA39  BE DA7B R				mov     si, offset SD_CMD9 ; get size info
 DA3C  0E					push    cs
 DA3D  1F					pop     ds
 DA3E  E8 FE7C					call    sdcmd8T
 DA41  0A E4					or      ah, ah
 DA43  75 1C					jnz     short sdexit
 DA45  E8 FE7E					call    sdresp     ; wait for 0feh token
 DA48  80 FC FE					cmp     ah, 0feh
 DA4B  75 14					jne     short sdexit
 DA4D  B1 12					mov     cl, 18       ; 16bytes + 2bytes CRC
 DA4F  2B E1					sub     sp, cx
 DA51  8B FC					mov     di, sp
 DA53  16					push    ss
 DA54  1F					pop     ds
 DA55  E8 FE24					call    sdrblk
 DA58  8B 4D F6					mov     cx, [di-10]
 DA5B  C1 C1 08					rol     cx, 8
 DA5E  41					inc     cx
 DA5F  8B E7					mov     sp, di
 DA61				sdexit: 
 DA61  33 C0					xor     ax, ax       ; raise CS
 DA63  EF					out     dx, ax
 DA64  E8 FDC8					call    sdrb
 DA67  5F					pop     di
 DA68  5E					pop     si
 DA69  5A					pop     dx
 DA6A  8B C1					mov     ax, cx       
 DA6C  59					pop     cx
 DA6D  1F					pop     ds
 DA6E  C3					ret
 DA6F				sdinit endp
					
 DA6F 40 00 00 00 00 95		SD_CMD0     db  40h, 0, 0, 0, 0, 95h
 DA75 48 00 00 01 AA 87		SD_CMD8     db  48h, 0, 0, 1, 0aah, 087h
 DA7B 49 00 00 00 00 FF		SD_CMD9     db  49h, 0, 0, 0, 0, 0ffh
 DA81 4C 00 00 00 00 FF		SD_CMD12    db  4ch, 0, 0, 0, 0, 0ffh
 DA87 69 40 00 00 00 FF		SD_CMD41    db  69h, 40h, 0, 0, 0, 0ffh
 DA8D 77 00 00 00 00 FF		SD_CMD55    db  77h, 0, 0, 0, 0, 0ffh
 DA93 7A 00 00 00 00 FF		SD_CMD58    db  7ah, 0, 0, 0, 0, 0ffh


 DA99				Pal256:
 DA99  00 00 00 00 00 2A			db  00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,15h,00h, 2ah,2ah,2ah 
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 15 00 2A 2A 2A
 DAB1  15 15 15 15 15 3F			db  15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh 
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 DAC9  00 00 00 05 05 05			db  00h,00h,00h, 05h,05h,05h, 08h,08h,08h, 0bh,0bh,0bh, 0eh,0eh,0eh, 11h,11h,11h, 14h,14h,14h, 18h,18h,18h 
       08 08 08 0B 0B 0B
       0E 0E 0E 11 11 11
       14 14 14 18 18 18
 DAE1  1C 1C 1C 20 20 20			db  1ch,1ch,1ch, 20h,20h,20h, 24h,24h,24h, 28h,28h,28h, 2dh,2dh,2dh, 32h,32h,32h, 38h,38h,38h, 3fh,3fh,3fh 
       24 24 24 28 28 28
       2D 2D 2D 32 32 32
       38 38 38 3F 3F 3F
 DAF9  00 00 3F 10 00 3F			db  00h,00h,3fh, 10h,00h,3fh, 1fh,00h,3fh, 2fh,00h,3fh, 3fh,00h,3fh, 3fh,00h,2fh, 3fh,00h,1fh, 3fh,00h,10h 
       1F 00 3F 2F 00 3F
       3F 00 3F 3F 00 2F
       3F 00 1F 3F 00 10
 DB11  3F 00 00 3F 10 00			db  3fh,00h,00h, 3fh,10h,00h, 3fh,1fh,00h, 3fh,2fh,00h, 3fh,3fh,00h, 2fh,3fh,00h, 1fh,3fh,00h, 10h,3fh,00h 
       3F 1F 00 3F 2F 00
       3F 3F 00 2F 3F 00
       1F 3F 00 10 3F 00
 DB29  00 3F 00 00 3F 10			db  00h,3fh,00h, 00h,3fh,10h, 00h,3fh,1fh, 00h,3fh,2fh, 00h,3fh,3fh, 00h,2fh,3fh, 00h,1fh,3fh, 00h,10h,3fh 
       00 3F 1F 00 3F 2F
       00 3F 3F 00 2F 3F
       00 1F 3F 00 10 3F
 DB41  1F 1F 3F 27 1F 3F			db  1fh,1fh,3fh, 27h,1fh,3fh, 2fh,1fh,3fh, 37h,1fh,3fh, 3fh,1fh,3fh, 3fh,1fh,37h, 3fh,1fh,2fh, 3fh,1fh,27h
       2F 1F 3F 37 1F 3F
       3F 1F 3F 3F 1F 37
       3F 1F 2F 3F 1F 27
 DB59  00 01 02 03 04 05			db	00h, 01h, 02h, 03h, 04h, 05h, 06h, 07h, 08h, 09h, 0ah, 0bh, 0ch, 0dh, 0eh, 0fh	; EGA palette registers
       06 07 08 09 0A 0B
       0C 0D 0E 0F

				;		db  3fh,1fh,1fh, 3fh,27h,1fh, 3fh,2fh,1fh, 3fh,37h,1fh, 3fh,3fh,1fh, 37h,3fh,1fh, 2fh,3fh,1fh, 27h,3fh,1fh 
				;		db  1fh,3fh,1fh, 1fh,3fh,27h, 1fh,3fh,2fh, 1fh,3fh,37h, 1fh,3fh,3fh, 1fh,37h,3fh, 1fh,2fh,3fh, 1fh,27h,3fh 
				;		db  2dh,2dh,3fh, 31h,2dh,3fh, 36h,2dh,3fh, 3ah,2dh,3fh, 3fh,2dh,3fh, 3fh,2dh,3ah, 3fh,2dh,36h, 3fh,2dh,31h 
				;		db  3fh,2dh,2dh, 3fh,31h,2dh, 3fh,36h,2dh, 3fh,3ah,2dh, 3fh,3fh,2dh, 3ah,3fh,2dh, 36h,3fh,2dh, 31h,3fh,2dh 
				;		db  2dh,3fh,2dh, 2dh,3fh,31h, 2dh,3fh,36h, 2dh,3fh,3ah, 2dh,3fh,3fh, 2dh,3ah,3fh, 2dh,36h,3fh, 2dh,31h,3fh 
				;		db  00h,00h,1ch, 07h,00h,1ch, 0eh,00h,1ch, 15h,00h,1ch, 1ch,00h,1ch, 1ch,00h,15h, 1ch,00h,0eh, 1ch,00h,07h 
				;		db  1ch,00h,00h, 1ch,07h,00h, 1ch,0eh,00h, 1ch,15h,00h, 1ch,1ch,00h, 15h,1ch,00h, 0eh,1ch,00h, 07h,1ch,00h 
				;		db  00h,1ch,00h, 00h,1ch,07h, 00h,1ch,0eh, 00h,1ch,15h, 00h,1ch,1ch, 00h,15h,1ch, 00h,0eh,1ch, 00h,07h,1ch 

				;		db  0eh,0eh,1ch, 11h,0eh,1ch, 15h,0eh,1ch, 18h,0eh,1ch, 1ch,0eh,1ch, 1ch,0eh,18h, 1ch,0eh,15h, 1ch,0eh,11h 
				;		db  1ch,0eh,0eh, 1ch,11h,0eh, 1ch,15h,0eh, 1ch,18h,0eh, 1ch,1ch,0eh, 18h,1ch,0eh, 15h,1ch,0eh, 11h,1ch,0eh 
				;		db  0eh,1ch,0eh, 0eh,1ch,11h, 0eh,1ch,15h, 0eh,1ch,18h, 0eh,1ch,1ch, 0eh,18h,1ch, 0eh,15h,1ch, 0eh,11h,1ch 
				;		db  14h,14h,1ch, 16h,14h,1ch, 18h,14h,1ch, 1ah,14h,1ch, 1ch,14h,1ch, 1ch,14h,1ah, 1ch,14h,18h, 1ch,14h,16h 
				;		db  1ch,14h,14h, 1ch,16h,14h, 1ch,18h,14h, 1ch,1ah,14h, 1ch,1ch,14h, 1ah,1ch,14h, 18h,1ch,14h, 16h,1ch,14h 
				;		db  14h,1ch,14h, 14h,1ch,16h, 14h,1ch,18h, 14h,1ch,1ah, 14h,1ch,1ch, 14h,1ah,1ch, 14h,18h,1ch, 14h,16h,1ch 
				;		db  00h,00h,10h, 04h,00h,10h, 08h,00h,10h, 0ch,00h,10h, 10h,00h,10h, 10h,00h,0ch, 10h,00h,08h, 10h,00h,04h 
				;		db  10h,00h,00h, 10h,04h,00h, 10h,08h,00h, 10h,0ch,00h, 10h,10h,00h, 0ch,10h,00h, 08h,10h,00h, 04h,10h,00h 

				;		db  00h,10h,00h, 00h,10h,04h, 00h,10h,08h, 00h,10h,0ch, 00h,10h,10h, 00h,0ch,10h, 00h,08h,10h, 00h,04h,10h 
				;		db  08h,08h,10h, 0ah,08h,10h, 0ch,08h,10h, 0eh,08h,10h, 10h,08h,10h, 10h,08h,0eh, 10h,08h,0ch, 10h,08h,0ah 
				;		db  10h,08h,08h, 10h,0ah,08h, 10h,0ch,08h, 10h,0eh,08h, 10h,10h,08h, 0eh,10h,08h, 0ch,10h,08h, 0ah,10h,08h 
				;		db  08h,10h,08h, 08h,10h,0ah, 08h,10h,0ch, 08h,10h,0eh, 08h,10h,10h, 08h,0eh,10h, 08h,0ch,10h, 08h,0ah,10h 
				;		db  0bh,0bh,10h, 0ch,0bh,10h, 0dh,0bh,10h, 0fh,0bh,10h, 10h,0bh,10h, 10h,0bh,0fh, 10h,0bh,0dh, 10h,0bh,0ch 
				;		db  10h,0bh,0bh, 10h,0ch,0bh, 10h,0dh,0bh, 10h,0fh,0bh, 10h,10h,0bh, 0fh,10h,0bh, 0dh,10h,0bh, 0ch,10h,0bh 
				;		db  0bh,10h,0bh, 0bh,10h,0ch, 0bh,10h,0dh, 0bh,10h,0fh, 0bh,10h,10h, 0bh,0fh,10h, 0bh,0dh,10h, 0bh,0ch,10h 
				;		db  00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h

 DB69				PalEGA:
 DB69  00 00 00 00 00 2A			db	00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,15h,00h, 2ah,2ah,2ah
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 15 00 2A 2A 2A
 DB81  00 00 00 00 00 2A			db	00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,15h,00h, 2ah,2ah,2ah
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 15 00 2A 2A 2A
 DB99  15 15 15 15 15 3F			db	15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 DBB1  15 15 15 15 15 3F			db	15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 DBC9  00 00 00 00 00 2A			db	00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,15h,00h, 2ah,2ah,2ah
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 15 00 2A 2A 2A
 DBE1  00 00 00 00 00 2A			db	00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,15h,00h, 2ah,2ah,2ah
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 15 00 2A 2A 2A
 DBF9  15 15 15 15 15 3F			db	15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 DC11  15 15 15 15 15 3F			db	15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 DC29  00 01 02 03 04 05			db	00h, 01h, 02h, 03h, 04h, 05h, 06h, 07h, 10h, 11h, 12h, 13h, 14h, 15h, 16h, 17h	; EGA palette registers
       06 07 10 11 12 13
       14 15 16 17

 DC39				PalVGA:
 DC39  00 00 00 00 00 2A			db	00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,2ah,00h, 2ah,2ah,2ah
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 2A 00 2A 2A 2A
 DC51  00 00 15 00 00 3F			db	00h,00h,15h, 00h,00h,3fh, 00h,2ah,15h, 00h,2ah,3fh, 2ah,00h,15h, 2ah,00h,3fh, 2ah,2ah,15h, 2ah,2ah,3fh
       00 2A 15 00 2A 3F
       2A 00 15 2A 00 3F
       2A 2A 15 2A 2A 3F
 DC69  00 15 00 00 15 2A			db	00h,15h,00h, 00h,15h,2ah, 00h,3fh,00h, 00h,3fh,2ah, 2ah,15h,00h, 2ah,15h,2ah, 2ah,3fh,00h, 2ah,3fh,2ah
       00 3F 00 00 3F 2A
       2A 15 00 2A 15 2A
       2A 3F 00 2A 3F 2A
 DC81  00 15 15 00 15 3F			db	00h,15h,15h, 00h,15h,3fh, 00h,3fh,15h, 00h,3fh,3fh, 2ah,15h,15h, 2ah,15h,3fh, 2ah,3fh,15h, 2ah,3fh,3fh
       00 3F 15 00 3F 3F
       2A 15 15 2A 15 3F
       2A 3F 15 2A 3F 3F
 DC99  15 00 00 15 00 2A			db	15h,00h,00h, 15h,00h,2ah, 15h,2ah,00h, 15h,2ah,2ah, 3fh,00h,00h, 3fh,00h,2ah, 3fh,2ah,00h, 3fh,2ah,2ah
       15 2A 00 15 2A 2A
       3F 00 00 3F 00 2A
       3F 2A 00 3F 2A 2A
 DCB1  15 00 15 15 00 3F			db	15h,00h,15h, 15h,00h,3fh, 15h,2ah,15h, 15h,2ah,3fh, 3fh,00h,15h, 3fh,00h,3fh, 3fh,2ah,15h, 3fh,2ah,3fh
       15 2A 15 15 2A 3F
       3F 00 15 3F 00 3F
       3F 2A 15 3F 2A 3F
 DCC9  15 15 00 15 15 2A			db	15h,15h,00h, 15h,15h,2ah, 15h,3fh,00h, 15h,3fh,2ah, 3fh,15h,00h, 3fh,15h,2ah, 3fh,3fh,00h, 3fh,3fh,2ah
       15 3F 00 15 3F 2A
       3F 15 00 3F 15 2A
       3F 3F 00 3F 3F 2A
 DCE1  15 15 15 15 15 3F			db	15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 DCF9  00 01 02 03 04 05			db	00h, 01h, 02h, 03h, 04h, 05h, 14h, 07h, 38h, 39h, 3ah, 3bh, 3ch, 3dh, 3eh, 3fh	; EGA palette registers
       14 07 38 39 3A 3B
       3C 3D 3E 3F

				IFDEF SCANCODE1 ; use SCANCODE1
 DD09				KeyIndex:
 DD09  00 52 31 32 34 33			db	0, 82, 49, 50, 52, 51, 54, 55    ;0-7
       36 37
 DD11  38 39 3C 3B 41 44			db 56, 57, 60, 59, 65, 68, 72, 47    ;8-f
       48 2F
 DD19  01 05 09 0D 0C 12			db	1,  5,  9, 13, 12, 18, 21, 23    ;10-17
       15 17
 DD21  18 1A 43 46 45 00			db 24, 26, 67, 70, 69,  0,  4,  3    ;18-1f
       04 03
 DD29  08 0B 11 10 14 16			db	8, 11, 17, 16, 20, 22, 25, 64    ;20-27
       19 40
 DD31  42 30 00 47 02 07			db 66, 48,  0, 71,  2,  7,  6, 10    ;28-2f
       06 0A
 DD39  0F 0E 13 3A 3D 3E			db 15, 14, 19, 58, 61, 62,  0, 87    ;30-37
       00 57
 DD41  00 35 00 28 29 27			db	0, 53,  0, 40, 41, 39, 46, 38    ;38-3f
       2E 26
 DD49  2D 5A 2C 4F 2B 00			db 45, 90, 44, 79, 43,  0, 89, 29    ;40-47
       59 1D
 DD51  22 24 56 1C 25 21			db 34, 36, 86, 28, 37, 33, 84, 27    ;48-4f
       54 1B
 DD59  20 23 1E 1F 00 00			db 32, 35, 30, 31,  0,  0,	0, 83    ;50-57  
       00 53
 DD61  2A					db 42
 DD62				E0KeyList:
 DD62  35 1C 4F 4B 47 52		db	35h, 1ch, 4fh, 4bh, 47h, 52h, 53h, 50h, 4dh, 48h, 51h, 49h 
       53 50 4D 48 51 49

				ELSE    ; use SCANCODE2
				ENDIF

 DD6E				E0KeyIndex:
 DD6E  3F 45 49 4A 4B 4C		db	63,  69,  73,  74,  75,  76,  77,  78,  80,  81,  85,  88
       4D 4E 50 51 55 58

 DD7A				KeyCode:	  
				; Keys affected by CapsLock
				;		norm   shft   ctrl   alt
 DD7A  0000 0000 0000				dw	0000h, 0000h, 0000h, 0000h ;17 - <0>
       0000
 DD82  1071 1051 1011				dw	1071h, 1051h, 1011h, 1000h ;15 - Q, (E0)PrevTrack <1>
       1000
 DD8A  2C7A 2C5A 2C1A				dw	2c7ah, 2c5ah, 2c1ah, 2c00h ;1a - Z <2>
       2C00
 DD92  1F73 1F53 1F13				dw	1f73h, 1f53h, 1f13h, 1f00h ;1b - S <3>
       1F00
 DD9A  1E61 1E41 1E01				dw	1e61h, 1e41h, 1e01h, 1e00h ;1c - A <4>
       1E00
 DDA2  1177 1157 1117				dw	1177h, 1157h, 1117h, 1100h ;1d - W <5>
       1100
 DDAA  2E63 2E43 2E03				dw	2e63h, 2e43h, 2e03h, 2e00h ;21 - C, (E0)Volume Down <6>
       2E00
 DDB2  2D78 2D58 2D18				dw	2d78h, 2d58h, 2d18h, 2d00h ;22 - X <7>
       2D00
 DDBA  2064 2044 2004				dw	2064h, 2044h, 2004h, 2000h ;23 - D, (E0)Mute <8>
       2000
 DDC2  1265 1245 1205				dw	1265h, 1245h, 1205h, 1200h ;24 - E <9>
       1200
 DDCA  2F76 2F56 2F16				dw	2f76h, 2f56h, 2f16h, 2f00h ;2a - V <10>
       2F00
 DDD2  2166 2146 2106				dw	2166h, 2146h, 2106h, 2100h ;2b - F, (E0)Calculator <11>
       2100
 DDDA  1474 1454 1414				dw	1474h, 1454h, 1414h, 1400h ;2c - T <12>
       1400
 DDE2  1372 1352 1312				dw	1372h, 1352h, 1312h, 1300h ;2d - R <13>
       1300
 DDEA  316E 314E 310E				dw	316eh, 314eh, 310eh, 3100h ;31 - N <14>
       3100
 DDF2  3062 3042 3002				dw	3062h, 3042h, 3002h, 3000h ;32 - B, (E0)Volume Up <15>
       3000
 DDFA  2368 2348 2308				dw	2368h, 2348h, 2308h, 2300h ;33 - H <16>
       2300
 DE02  2267 2247 2207				dw	2267h, 2247h, 2207h, 2200h ;34 - G, (E0)Play/Pause <17>
       2200
 DE0A  1579 1559 1519				dw	1579h, 1559h, 1519h, 1500h ;35 - Y <18>
       1500
 DE12  326D 324D 320D				dw	326dh, 324dh, 320dh, 3200h ;3a - M, (E0)WWW Home <19>
       3200
 DE1A  246A 244A 240A				dw	246ah, 244ah, 240ah, 2400h ;3b - J, (E0)Stop <20>
       2400
 DE22  1675 1655 1615				dw	1675h, 1655h, 1615h, 1600h ;3c - U <21>
       1600
 DE2A  256B 254B 250B				dw	256bh, 254bh, 250bh, 2500h ;42 - K <22>
       2500
 DE32  1769 1749 1709				dw	1769h, 1749h, 1709h, 1700h ;43 - I <23>
       1700
 DE3A  186F 184F 180F				dw	186fh, 184fh, 180fh, 1800h ;44 - O <24>
       1800
 DE42  266C 264C 260C				dw	266ch, 264ch, 260ch, 2600h ;4b - L <25>
       2600
 DE4A  1970 1950 1910				dw	1970h, 1950h, 1910h, 1900h ;4d - P, (E0)Next Track <26>
       1900
				; keys affected by NumLock	
 DE52  4F00 4F31 7500				dw	4f00h, 4f31h, 7500h, 0002h ;69 - KP1 <27>
       0002
 DE5A  4B00 4B34 7300				dw	4b00h, 4b34h, 7300h, 0005h ;6b - KP4 <28>
       0005
 DE62  4700 4737 7700				dw	4700h, 4737h, 7700h, 0008h ;6c - KP7 <29>
       0008
 DE6A  5200 5230 9200				dw	5200h, 5230h, 9200h, 0001h ;70 - KP0 <30>
       0001
 DE72  5300 532E 9300				dw	5300h, 532eh, 9300h, 0000h ;71 - KP. <31>
       0000
 DE7A  5000 5032 9100				dw	5000h, 5032h, 9100h, 0003h ;72 - KP2 <32>
       0003
 DE82  4D00 4D36 7400				dw	4d00h, 4d36h, 7400h, 0007h ;74 - KP6 <33>
       0007
 DE8A  4800 4838 8D00				dw	4800h, 4838h, 8d00h, 0009h ;75 - KP8 <34>
       0009
 DE92  5100 5133 7600				dw	5100h, 5133h, 7600h, 0004h ;7a - KP3 <35>
       0004
 DE9A  4900 4939 8400				dw	4900h, 4939h, 8400h, 000ah ;7d - KP9 <36>
       000A
 DEA2  4C00 4C35 8F00				dw	4c00h, 4c35h, 8f00h, 0006h ;73 - KP5 --- on VMWare, it does not send 4c00 <37>
       0006
				; keys unaffected by CapsLock or N
 DEAA  3F00 5800 6200				dw	3f00h, 5800h, 6200h, 6c00h ;03 - F5 <38>
       6C00
 DEB2  3D00 5600 6000				dw	3d00h, 5600h, 6000h, 6a00h ;04 - F3 <39>
       6A00
 DEBA  3B00 5400 5E00				dw	3b00h, 5400h, 5e00h, 6800h ;05 - F1 <40>
       6800
 DEC2  3C00 5500 5F00				dw	3c00h, 5500h, 5f00h, 6900h ;06 - F2 <41>
       6900
 DECA  8600 8800 8A00				dw	8600h, 8800h, 8a00h, 8c00h ;07 - F12 <42>	
       8C00
 DED2  4400 5D00 6700				dw	4400h, 5d00h, 6700h, 7100h ;09 - F10 <43>
       7100
 DEDA  4200 5B00 6500				dw	4200h, 5b00h, 6500h, 6f00h ;0a - F8 <44>
       6F00
 DEE2  4000 5900 6300				dw	4000h, 5900h, 6300h, 6d00h ;0b - F6 <45>
       6D00
 DEEA  3E00 5700 6100				dw	3e00h, 5700h, 6100h, 6b00h ;0c - F4 <46>
       6B00
 DEF2  0F09 0F00 9400				dw	0f09h, 0f00h, 9400h, 0000h ;0d - TAB <47>	
       0000
 DEFA  2960 297E 0000				dw	2960h, 297eh, 0000h, 2900h ;0e - ` ~ <48>	
       2900
 DF02  0231 0221 0000				dw	0231h, 0221h, 0000h, 7800h ;16 - 1 ! <49>	
       7800
 DF0A  0332 0340 0300				dw	0332h, 0340h, 0300h, 7900h ;1e - 2 @ <50>	
       7900
 DF12  0534 0524 0000				dw	0534h, 0524h, 0000h, 7b00h ;25 - 4 $ <51>
       7B00
 DF1A  0433 0423 0000				dw	0433h, 0423h, 0000h, 7a00h ;26 - 3 # <52>
       7A00
 DF22  3920 3920 3920				dw	3920h, 3920h, 3920h, 3920h ;29 - SPC <53>	
       3920
 DF2A  0635 0625 0000				dw	0635h, 0625h, 0000h, 7c00h ;2e - 5 % <54>
       7C00
 DF32  0736 075E 071E				dw	0736h, 075eh, 071eh, 7d00h ;36 - 6 ^ <55>
       7D00
 DF3A  0837 0826 0000				dw	0837h, 0826h, 0000h, 7e00h ;3d - 7 & <56>
       7E00
 DF42  0938 092A 0000				dw	0938h, 092ah, 0000h, 7f00h ;3e - 8 * <57>
       7F00
 DF4A  332C 333C 0000				dw	332ch, 333ch, 0000h, 3300h ;41 - , < <58>
       3300
 DF52  0B30 0B29 0000				dw	0b30h, 0b29h, 0000h, 8100h ;45 - 0 ) <59>
       8100
 DF5A  0A39 0A28 0000				dw	0a39h, 0a28h, 0000h, 8000h ;46 - 9 ( <60>
       8000
 DF62  342E 343E 0000				dw	342eh, 343eh, 0000h, 3400h ;49 - . > <61>
       3400
 DF6A  352F 353F 0000				dw	352fh, 353fh, 0000h, 3500h ;4a - / ? <62>
       3500
 DF72  E02F E02F 9500				dw	0e02fh, 0e02fh, 9500h, 0a400h ;4a - (e0)KP/ <63>
       A400
 DF7A  273B 273A 0000				dw	273bh, 273ah, 0000h, 2700h ;4c - ; : <64>
       2700
 DF82  0C2D 0C5F 0C1F				dw	0c2dh, 0c5fh, 0c1fh, 8200h ;4e - - _ <65>
       8200
 DF8A  2827 2822 0000				dw	2827h, 2822h, 0000h, 2800h ;52 -   <66>
       2800
 DF92  1A5B 1A7B 1A1B				dw	1a5bh, 1a7bh, 1a1bh, 1a00h ;54 - [ { <67>
       1A00
 DF9A  0D3D 0D2B 0000				dw	0d3dh, 0d2bh, 0000h, 8300h ;55 - = + <68>	
       8300
 DFA2  1C0D 1C0D 1C0A				dw	1c0dh, 1c0dh, 1c0ah, 1c00h ;5a - Enter, (E0)KPEnter <69>
       1C00
 DFAA  1B5D 1B7D 1B1D				dw	1b5dh, 1b7dh, 1b1dh, 1b00h ;5b - ] } <70>
       1B00
 DFB2  2B5C 2B7C 2B1C				dw	2b5ch, 2b7ch, 2b1ch, 2b00h ;5d - \ | <71>
       2B00
 DFBA  0E08 0E08 0E7F				dw	0e08h, 0e08h, 0e7fh, 0e00h ;66 - BKSP <72>
       0E00
 DFC2  4F00 4F00 7500				dw	4f00h, 4f00h, 7500h, 9f00h ;69 - (E0)END <73>
       9F00
 DFCA  4B00 4B00 7300				dw	4b00h, 4b00h, 7300h, 9b00h ;6b - (E0)LEFT <74>
       9B00
 DFD2  4700 4700 7700				dw	4700h, 4700h, 7700h, 9700h ;6c - (E0)HOME <75>
       9700
 DFDA  5200 5200 9200				dw	5200h, 5200h, 9200h, 0a200h ;70 - (E0)INS <76>
       A200
 DFE2  5300 5300 9300				dw	5300h, 5300h, 9300h, 0a300h ;71 - (E0)DEL <77>
       A300
 DFEA  5000 5000 9100				dw	5000h, 5000h, 9100h, 0a000h ;72 - (E0)DOWN <78>
       A000
 DFF2  4300 5C00 6600				dw	4300h, 5c00h, 6600h, 7000h ;01 - F9 <79>
       7000
 DFFA  4D00 4D00 7400				dw	4d00h, 4d00h, 7400h, 9d00h ;74 - (E0)RIGHT <80>
       9D00
 E002  4800 4800 8D00				dw	4800h, 4800h, 8d00h, 9800h ;75 - (E0)UP <81>
       9800
 E00A  011B 011B 011B				dw	011bh, 011bh, 011bh, 0100h ;76 - ESC <82>
       0100
 E012  8500 8700 8900				dw	8500h, 8700h, 8900h, 8b00h ;78 - F11 <83>
       8B00
 E01A  4E2B 4E2B 9000				dw	4e2bh, 4e2bh, 9000h, 4e00h ;79 - KP+ <84>
       4E00
 E022  5100 5100 7600				dw	5100h, 5100h, 7600h, 0a100h ;7a - (E0)PGDN <85>
       A100
 E02A  4A2D 4A2D 8E00				dw	4a2dh, 4a2dh, 8e00h, 4a00h ;7b - KP- <86>
       4A00
 E032  372A 372A 9600				dw	372ah, 372ah, 9600h, 3700h ;7c - KP* --- on VMWare, it does not send 3710h with CTL <87>
       3700
 E03A  4900 4900 8400				dw	4900h, 4900h, 8400h, 9900h ;7d - (E0)PGUP <88>
       9900
 E042  4600 4600 4600				dw	4600h, 4600h, 4600h, 4600h ;7e - SCRL <89>
       4600
 E04A  4100 5A00 6400				dw	4100h, 5a00h, 6400h, 6e00h ;83 - F7 <90>
       6E00

				; ------------------------- POWER ON RESET -----------------------
						org     0fff0h
						
 FFF0  EA					db      0eah
 FFF1  C05B R F000				dw      coldboot, 0f000h
 FFF5  30 39 2F 31 30 2F			db      '09/10/17'
       31 37
 FFFD  FF FF 00					db      0ffh, 0ffh, 0
				end bios
Microsoft (R) Macro Assembler Version 6.14.8444		    08/21/22 22:05:47
BIOS_Next186.asm					     Symbols 2 - 1




Macros:

                N a m e                 Type

OFFDX  . . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_TEXT  . . . . . . . . . . . . .	16 Bit	 00010000 Word	  Public  'CODE'	
_DATA  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

KeyLock  . . . . . . . . . . . .	P Near	 C584	  _TEXT	Length= 0016 Public
  s2 . . . . . . . . . . . . . .	L Near	 C591	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 C599	  _TEXT	
defint . . . . . . . . . . . . .	P Near	 D808	  _TEXT	Length= 0001 Public
enableKbIfPresent  . . . . . . .	P Near	 D7FC	  _TEXT	Length= 000C Public
  noenablekb . . . . . . . . . .	L Near	 D807	  _TEXT	
getps2byte . . . . . . . . . . .	P Near	 D7D1	  _TEXT	Length= 001A Public
  gps2b2 . . . . . . . . . . . .	L Near	 D7D6	  _TEXT	
  gps2b1 . . . . . . . . . . . .	L Near	 D7E6	  _TEXT	
int07  . . . . . . . . . . . . .	P Near	 C2F1	  _TEXT	Length= 0030 Public
  int07_pfx  . . . . . . . . . .	L Near	 C2FA	  _TEXT	
  int072 . . . . . . . . . . . .	L Near	 C313	  _TEXT	
int08  . . . . . . . . . . . . .	P Near	 C321	  _TEXT	Length= 0056 Public
  int08_nodec  . . . . . . . . .	L Near	 C330	  _TEXT	
  int081 . . . . . . . . . . . .	L Near	 C359	  _TEXT	
  kloop  . . . . . . . . . . . .	L Near	 C35F	  _TEXT	
  kbdata . . . . . . . . . . . .	L Near	 C371	  _TEXT	
  nokey  . . . . . . . . . . . .	L Near	 C373	  _TEXT	
int09  . . . . . . . . . . . . .	P Near	 C377	  _TEXT	Length= 020D Public
  SecondACK  . . . . . . . . . .	L Near	 C3A1	  _TEXT	
  ToggleACK  . . . . . . . . . .	L Near	 C3A4	  _TEXT	
  SetFlags1  . . . . . . . . . .	L Near	 C3A7	  _TEXT	
  noACK  . . . . . . . . . . . .	L Near	 C3AA	  _TEXT	
  noE0 . . . . . . . . . . . . .	L Near	 C3BD	  _TEXT	
  noE1 . . . . . . . . . . . . .	L Near	 C3C6	  _TEXT	
  noDEL  . . . . . . . . . . . .	L Near	 C3E2	  _TEXT	
  noLSDown . . . . . . . . . . .	L Near	 C3F0	  _TEXT	
  noLSUp . . . . . . . . . . . .	L Near	 C3F9	  _TEXT	
  noRSDown . . . . . . . . . . .	L Near	 C402	  _TEXT	
  noRSUp . . . . . . . . . . . .	L Near	 C40B	  _TEXT	
  LALTDn . . . . . . . . . . . .	L Near	 C41C	  _TEXT	
  noALTDown  . . . . . . . . . .	L Near	 C422	  _TEXT	
  LALTUp . . . . . . . . . . . .	L Near	 C433	  _TEXT	
  ALTUp  . . . . . . . . . . . .	L Near	 C437	  _TEXT	
  noALTUp  . . . . . . . . . . .	L Near	 C444	  _TEXT	
  SetFlagsKey2 . . . . . . . . .	L Near	 C453	  _TEXT	
  LCTLDn . . . . . . . . . . . .	L Near	 C455	  _TEXT	
  noCTLDown  . . . . . . . . . .	L Near	 C45B	  _TEXT	
  LCTLUp . . . . . . . . . . . .	L Near	 C46C	  _TEXT	
  noCTLUp  . . . . . . . . . . .	L Near	 C472	  _TEXT	
  noScrLock  . . . . . . . . . .	L Near	 C4A5	  _TEXT	
  testINS  . . . . . . . . . . .	L Near	 C4B4	  _TEXT	
  noIns  . . . . . . . . . . . .	L Near	 C4BA	  _TEXT	
  SetFlagsKey1 . . . . . . . . .	L Near	 C4CE	  _TEXT	
  E0Key  . . . . . . . . . . . .	L Near	 C4D1	  _TEXT	
  NormalKey  . . . . . . . . . .	L Near	 C4E6	  _TEXT	
  KeyDown  . . . . . . . . . . .	L Near	 C4FA	  _TEXT	
  noShift  . . . . . . . . . . .	L Near	 C503	  _TEXT	
  noCaps . . . . . . . . . . . .	L Near	 C511	  _TEXT	
  NumDown  . . . . . . . . . . .	L Near	 C51C	  _TEXT	
  noNum  . . . . . . . . . . . .	L Near	 C51F	  _TEXT	
  noCtrl . . . . . . . . . . . .	L Near	 C526	  _TEXT	
  noAlt  . . . . . . . . . . . .	L Near	 C52D	  _TEXT	
  pushKey  . . . . . . . . . . .	L Near	 C54B	  _TEXT	
  SetFlagsKey  . . . . . . . . .	L Near	 C556	  _TEXT	
  SetFlags . . . . . . . . . . .	L Near	 C559	  _TEXT	
  SF1  . . . . . . . . . . . . .	L Near	 C574	  _TEXT	
  int09Exit  . . . . . . . . . .	L Near	 C57C	  _TEXT	
int10  . . . . . . . . . . . . .	P Near	 C59A	  _TEXT	Length= 0AAE Public
  exit . . . . . . . . . . . . .	L Near	 C5B9	  _TEXT	
  svga . . . . . . . . . . . . .	L Near	 C5BC	  _TEXT	
  VESAGetInfo  . . . . . . . . .	L Near	 C5D1	  _TEXT	
  VESASupportedClear . . . . . .	L Near	 C5DE	  _TEXT	
  VESASupported  . . . . . . . .	L Near	 C5E4	  _TEXT	
  VESASupportedErr . . . . . . .	L Near	 C5E6	  _TEXT	
  VESAGetModeInfo  . . . . . . .	L Near	 C5EA	  _TEXT	
  VESAGetModeInfo1 . . . . . . .	L Near	 C5EE	  _TEXT	
  VESASetMode  . . . . . . . . .	L Near	 C601	  _TEXT	
  VESASetMode1 . . . . . . . . .	L Near	 C613	  _TEXT	
  VESAGetMode  . . . . . . . . .	L Near	 C61B	  _TEXT	
  VESAGetMode1 . . . . . . . . .	L Near	 C631	  _TEXT	
  VESAMemControl . . . . . . . .	L Near	 C637	  _TEXT	
  VESAMemControlCB . . . . . . .	L Near	 C63B	  _TEXT	
  getpageinfo  . . . . . . . . .	L Near	 C655	  _TEXT	
  VESAModeInfo . . . . . . . . .	L Near	 C68B	  _TEXT	
  ModeTab  . . . . . . . . . . .	L Near	 C69E	  _TEXT	
  setmode  . . . . . . . . . . .	L Near	 C79A	  _TEXT	
  setmode_text1  . . . . . . . .	L Near	 C7D8	  _TEXT	
  setmode_80ch . . . . . . . . .	L Near	 C7F6	  _TEXT	
  setmode1 . . . . . . . . . . .	L Near	 C808	  _TEXT	
  setmode1_pcjr  . . . . . . . .	L Near	 C818	  _TEXT	
  setmode1b  . . . . . . . . . .	L Near	 C81A	  _TEXT	
  setmode1a  . . . . . . . . . .	L Near	 C837	  _TEXT	
  setmode11  . . . . . . . . . .	L Near	 C84E	  _TEXT	
  setmode12  . . . . . . . . . .	L Near	 C860	  _TEXT	
  setmode1221  . . . . . . . . .	L Near	 C86A	  _TEXT	
  setmode122 . . . . . . . . . .	L Near	 C872	  _TEXT	
  setmode121 . . . . . . . . . .	L Near	 C886	  _TEXT	
  setmode13  . . . . . . . . . .	L Near	 C895	  _TEXT	
  setmode3 . . . . . . . . . . .	L Near	 C8A7	  _TEXT	
  setmode21  . . . . . . . . . .	L Near	 C8BA	  _TEXT	
  setmode2 . . . . . . . . . . .	L Near	 C8C2	  _TEXT	
  setmode2a  . . . . . . . . . .	L Near	 C8D3	  _TEXT	
  clearnext  . . . . . . . . . .	L Near	 C968	  _TEXT	
  clearok  . . . . . . . . . . .	L Near	 C97C	  _TEXT	
  setmode4 . . . . . . . . . . .	L Near	 C97C	  _TEXT	
  setmodeexit  . . . . . . . . .	L Near	 C9D5	  _TEXT	
  nullproc . . . . . . . . . . .	L Near	 C9E7	  _TEXT	
  cursor . . . . . . . . . . . .	L Near	 C9E8	  _TEXT	
  cursor8  . . . . . . . . . . .	L Near	 C9F9	  _TEXT	
  curpos . . . . . . . . . . . .	L Near	 CA08	  _TEXT	
  curpos_ismode7 . . . . . . . .	L Near	 CA1E	  _TEXT	
  curpos1  . . . . . . . . . . .	L Near	 CA25	  _TEXT	
  curpos_exit  . . . . . . . . .	L Near	 CA46	  _TEXT	
  getcurpos  . . . . . . . . . .	L Near	 CA49	  _TEXT	
  lightpen . . . . . . . . . . .	L Near	 CA59	  _TEXT	
  apage  . . . . . . . . . . . .	L Near	 CA5C	  _TEXT	
  apage1 . . . . . . . . . . . .	L Near	 CA84	  _TEXT	
  apage3 . . . . . . . . . . . .	L Near	 CA92	  _TEXT	
  apage2 . . . . . . . . . . . .	L Near	 CA94	  _TEXT	
  apage4 . . . . . . . . . . . .	L Near	 CA97	  _TEXT	
  scrollup . . . . . . . . . . .	L Near	 CAB2	  _TEXT	
  scrollup6  . . . . . . . . . .	L Near	 CABC	  _TEXT	
  scrollup4  . . . . . . . . . .	L Near	 CAD3	  _TEXT	
  scrollup3  . . . . . . . . . .	L Near	 CAE0	  _TEXT	
  scrollup5  . . . . . . . . . .	L Near	 CAE5	  _TEXT	
  scrollexit . . . . . . . . . .	L Near	 CAEF	  _TEXT	
  scrolldn . . . . . . . . . . .	L Near	 CAF2	  _TEXT	
  scr_params . . . . . . . . . .	L Near	 CB03	  _TEXT	
  readchar . . . . . . . . . . .	L Near	 CB24	  _TEXT	
  mode3chaddr  . . . . . . . . .	L Near	 CB2C	  _TEXT	
  writecharattr  . . . . . . . .	L Near	 CB4F	  _TEXT	
  writechar  . . . . . . . . . .	L Near	 CB65	  _TEXT	
  writechar3 . . . . . . . . . .	L Near	 CB6C	  _TEXT	
  writecharskip  . . . . . . . .	L Near	 CB75	  _TEXT	
  setcolorpalette  . . . . . . .	L Near	 CB76	  _TEXT	
  setcolorpalette_pal  . . . . .	L Near	 CB8E	  _TEXT	
  setcolorpalette_out  . . . . .	L Near	 CB95	  _TEXT	
  writepixel . . . . . . . . . .	L Near	 CB9C	  _TEXT	
  readpixel  . . . . . . . . . .	L Near	 CBEA	  _TEXT	
  writecharTTY . . . . . . . . .	L Near	 CBEB	  _TEXT	
  tty  . . . . . . . . . . . . .	L Near	 CC09	  _TEXT	
  tty1 . . . . . . . . . . . . .	L Near	 CC2E	  _TEXT	
  bell . . . . . . . . . . . . .	L Near	 CC30	  _TEXT	
  bs . . . . . . . . . . . . . .	L Near	 CC32	  _TEXT	
  lf . . . . . . . . . . . . . .	L Near	 CC3A	  _TEXT	
  crlf . . . . . . . . . . . . .	L Near	 CC3E	  _TEXT	
  cr . . . . . . . . . . . . . .	L Near	 CC40	  _TEXT	
  readmode . . . . . . . . . . .	L Near	 CC62	  _TEXT	
  pal  . . . . . . . . . . . . .	L Near	 CCAC	  _TEXT	
  palexit  . . . . . . . . . . .	L Near	 CCB9	  _TEXT	
  setonereg  . . . . . . . . . .	L Near	 CCBA	  _TEXT	
  setonereg1 . . . . . . . . . .	L Near	 CCC9	  _TEXT	
  setallreg  . . . . . . . . . .	L Near	 CCCA	  _TEXT	
  setallreg1 . . . . . . . . . .	L Near	 CCD1	  _TEXT	
  setblink . . . . . . . . . . .	L Near	 CCDE	  _TEXT	
  setblink1  . . . . . . . . . .	L Near	 CD08	  _TEXT	
  readonereg . . . . . . . . . .	L Near	 CD0A	  _TEXT	
  readallreg . . . . . . . . . .	L Near	 CD1F	  _TEXT	
  readllreg1 . . . . . . . . . .	L Near	 CD24	  _TEXT	
  readoverscan . . . . . . . . .	L Near	 CD36	  _TEXT	
  setoneDAC  . . . . . . . . . .	L Near	 CD39	  _TEXT	
  setblockDAC  . . . . . . . . .	L Near	 CD4F	  _TEXT	
  paging . . . . . . . . . . . .	L Near	 CD60	  _TEXT	
  paging1  . . . . . . . . . . .	L Near	 CD81	  _TEXT	
  paging3  . . . . . . . . . . .	L Near	 CD88	  _TEXT	
  paging2  . . . . . . . . . . .	L Near	 CD8D	  _TEXT	
  readoneDAC . . . . . . . . . .	L Near	 CD90	  _TEXT	
  readblockDAC . . . . . . . . .	L Near	 CDA8	  _TEXT	
  setPELmask . . . . . . . . . .	L Near	 CDB9	  _TEXT	
  getPELmask . . . . . . . . . .	L Near	 CDC2	  _TEXT	
  getpaging  . . . . . . . . . .	L Near	 CDCB	  _TEXT	
  getpaging1 . . . . . . . . . .	L Near	 CDE0	  _TEXT	
  grayscale  . . . . . . . . . .	L Near	 CDE1	  _TEXT	
  grayscale1 . . . . . . . . . .	L Near	 CDE6	  _TEXT	
  grayscale2 . . . . . . . . . .	L Near	 CE0E	  _TEXT	
  loadUDF  . . . . . . . . . . .	L Near	 CE0F	  _TEXT	
  loadUDF1 . . . . . . . . . . .	L Near	 CE1B	  _TEXT	
  loadUDFexit1 . . . . . . . . .	L Near	 CE5A	  _TEXT	
  loadUDFexit  . . . . . . . . .	L Near	 CE5B	  _TEXT	
  chargen  . . . . . . . . . . .	L Near	 CE5C	  _TEXT	
  loadROMFont8 . . . . . . . . .	L Near	 CE7F	  _TEXT	
  loadROMFont16  . . . . . . . .	L Near	 CE8A	  _TEXT	
  loadROMFont161 . . . . . . . .	L Near	 CE93	  _TEXT	
  set1f  . . . . . . . . . . . .	L Near	 CEA2	  _TEXT	
  setgrUDF . . . . . . . . . . .	L Near	 CEAD	  _TEXT	
  setgrUDF1  . . . . . . . . . .	L Near	 CECD	  _TEXT	
  setgrUDFexit . . . . . . . . .	L Near	 CED8	  _TEXT	
  setROMgrFont . . . . . . . . .	L Near	 CEDA	  _TEXT	
  setROMgrFont1  . . . . . . . .	L Near	 CEEB	  _TEXT	
  getfontinfo  . . . . . . . . .	L Near	 CEF8	  _TEXT	
  getfontinfo1 . . . . . . . . .	L Near	 CF13	  _TEXT	
  getfontinfoexit  . . . . . . .	L Near	 CF26	  _TEXT	
  special  . . . . . . . . . . .	L Near	 CF33	  _TEXT	
  special1 . . . . . . . . . . .	L Near	 CF43	  _TEXT	
  special2 . . . . . . . . . . .	L Near	 CF57	  _TEXT	
  writestr . . . . . . . . . . .	L Near	 CF5A	  _TEXT	
  wstr1  . . . . . . . . . . . .	L Near	 CF69	  _TEXT	
  noattr . . . . . . . . . . . .	L Near	 CF77	  _TEXT	
  wstr2  . . . . . . . . . . . .	L Near	 CF8C	  _TEXT	
  wstrexit . . . . . . . . . . .	L Near	 CF8D	  _TEXT	
  getdcc . . . . . . . . . . . .	L Near	 CF8E	  _TEXT	
  setdcc . . . . . . . . . . . .	L Near	 CF99	  _TEXT	
  getdccexit . . . . . . . . . .	L Near	 CF9E	  _TEXT	
  querystatus  . . . . . . . . .	L Near	 CF9F	  _TEXT	
  querystatus1 . . . . . . . . .	L Near	 CFD1	  _TEXT	
  querystatus3 . . . . . . . . .	L Near	 CFDB	  _TEXT	
int11  . . . . . . . . . . . . .	P Near	 D048	  _TEXT	Length= 0009 Public
int12  . . . . . . . . . . . . .	P Near	 D051	  _TEXT	Length= 0009 Public
int13  . . . . . . . . . . . . .	P Near	 D05A	  _TEXT	Length= 01ED Public
  inINT13  . . . . . . . . . . .	L Near	 D079	  _TEXT	
  Disk1  . . . . . . . . . . . .	L Near	 D07D	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 D08D	  _TEXT	
  exit2  . . . . . . . . . . . .	L Near	 D091	  _TEXT	
  exit1  . . . . . . . . . . . .	L Near	 D098	  _TEXT	
  DiskGetType  . . . . . . . . .	L Near	 D0EB	  _TEXT	
  DiskGetTypeexit  . . . . . . .	L Near	 D102	  _TEXT	
  DiskExtInstCheck . . . . . . .	L Near	 D10B	  _TEXT	
  DiskReset  . . . . . . . . . .	L Near	 D119	  _TEXT	
  DiskChanged  . . . . . . . . .	L Near	 D119	  _TEXT	
  DiskPark . . . . . . . . . . .	L Near	 D119	  _TEXT	
  DiskGetStatus  . . . . . . . .	L Near	 D11C	  _TEXT	
  DiskVerify . . . . . . . . . .	L Near	 D121	  _TEXT	
  DiskWrite  . . . . . . . . . .	L Near	 D126	  _TEXT	
  DiskRead . . . . . . . . . . .	L Near	 D12B	  _TEXT	
  DiskRead1  . . . . . . . . . .	L Near	 D12E	  _TEXT	
  DiskReadend  . . . . . . . . .	L Near	 D156	  _TEXT	
  HCStoLBA . . . . . . . . . . .	L Near	 D157	  _TEXT	
  DiskFormat . . . . . . . . . .	L Near	 D175	  _TEXT	
  DiskInit . . . . . . . . . . .	L Near	 D175	  _TEXT	
  DiskSeek . . . . . . . . . . .	L Near	 D175	  _TEXT	
  DiskRst  . . . . . . . . . . .	L Near	 D175	  _TEXT	
  DiskReady  . . . . . . . . . .	L Near	 D175	  _TEXT	
  DiskRecalibrate  . . . . . . .	L Near	 D175	  _TEXT	
  DiskDiag . . . . . . . . . . .	L Near	 D175	  _TEXT	
  DiskExtSeek  . . . . . . . . .	L Near	 D175	  _TEXT	
  notready . . . . . . . . . . .	L Near	 D181	  _TEXT	
  DiskGetParams  . . . . . . . .	L Near	 D184	  _TEXT	
  dgpok  . . . . . . . . . . . .	L Near	 D1AC	  _TEXT	
  DiskExtVerify  . . . . . . . .	L Near	 D1BB	  _TEXT	
  DiskExtWrite . . . . . . . . .	L Near	 D1C0	  _TEXT	
  DiskExtRead  . . . . . . . . .	L Near	 D1C5	  _TEXT	
  DiskExtRead1 . . . . . . . . .	L Near	 D1C8	  _TEXT	
  DiskExtGetParams . . . . . . .	L Near	 D1F7	  _TEXT	
  DiskReadSectBuffer . . . . . .	L Near	 D244	  _TEXT	
  DiskWriteSectBuffer  . . . . .	L Near	 D244	  _TEXT	
  DiskSetDASDType  . . . . . . .	L Near	 D244	  _TEXT	
  DiskSetMediaType . . . . . . .	L Near	 D244	  _TEXT	
  DiskExtLock  . . . . . . . . .	L Near	 D244	  _TEXT	
  DiskExtEject . . . . . . . . .	L Near	 D244	  _TEXT	
int14  . . . . . . . . . . . . .	P Near	 D247	  _TEXT	Length= 0081 Public
  SExit  . . . . . . . . . . . .	L Near	 D26E	  _TEXT	
  SetCharFormat  . . . . . . . .	L Near	 D272	  _TEXT	
  Baud110  . . . . . . . . . . .	L Near	 D28B	  _TEXT	
  GetPortStatus  . . . . . . . .	L Near	 D2A1	  _TEXT	
  GetPortStatus1 . . . . . . . .	L Near	 D2A4	  _TEXT	
  STransmit  . . . . . . . . . .	L Near	 D2AB	  _TEXT	
  STr1 . . . . . . . . . . . . .	L Near	 D2AE	  _TEXT	
  STr2 . . . . . . . . . . . . .	L Near	 D2B9	  _TEXT	
  SReceive . . . . . . . . . . .	L Near	 D2BC	  _TEXT	
  SReceive1  . . . . . . . . . .	L Near	 D2BD	  _TEXT	
int16  . . . . . . . . . . . . .	P Near	 D54C	  _TEXT	Length= 00EB Public
  kbfunc . . . . . . . . . . . .	L Near	 D574	  _TEXT	
  Exit . . . . . . . . . . . . .	L Near	 D576	  _TEXT	
  GetKey1  . . . . . . . . . . .	L Near	 D579	  _TEXT	
  GetKey . . . . . . . . . . . .	L Near	 D57A	  _TEXT	
  noWrap . . . . . . . . . . . .	L Near	 D590	  _TEXT	
  TestKey  . . . . . . . . . . .	L Near	 D596	  _TEXT	
  StoreKey . . . . . . . . . . .	L Near	 D5A5	  _TEXT	
  NoWrap1  . . . . . . . . . . .	L Near	 D5B7	  _TEXT	
  ExtStatus  . . . . . . . . . .	L Near	 D5C6	  _TEXT	
  NoSysReq . . . . . . . . . . .	L Near	 D5D1	  _TEXT	
  GetStatus  . . . . . . . . . .	L Near	 D5DA	  _TEXT	
  Exit1  . . . . . . . . . . . .	L Near	 D5DD	  _TEXT	
  SetAutoRpt . . . . . . . . . .	L Near	 D5DF	  _TEXT	
  timeout1 . . . . . . . . . . .	L Near	 D615	  _TEXT	
  timeout  . . . . . . . . . . .	L Near	 D61A	  _TEXT	
  WaitFlag . . . . . . . . . . .	L Near	 D61D	  _TEXT	
  wf_loop  . . . . . . . . . . .	L Near	 D622	  _TEXT	
  wf_ok  . . . . . . . . . . . .	L Near	 D636	  _TEXT	
int18  . . . . . . . . . . . . .	P Near	 D637	  _TEXT	Length= 007C Public
  sloop  . . . . . . . . . . . .	L Near	 D65E	  _TEXT	
int19  . . . . . . . . . . . . .	P Near	 D6B3	  _TEXT	Length= 001A Public
  int19err . . . . . . . . . . .	L Near	 D6CB	  _TEXT	
int1a  . . . . . . . . . . . . .	P Near	 D6CD	  _TEXT	Length= 002C Public
  clockexit1 . . . . . . . . . .	L Near	 D6E3	  _TEXT	
  clockexit  . . . . . . . . . .	L Near	 D6E8	  _TEXT	
  setclock . . . . . . . . . . .	L Near	 D6EE	  _TEXT	
int70  . . . . . . . . . . . . .	P Near	 D6F9	  _TEXT	Length= 0038 Public
  exit1  . . . . . . . . . . . .	L Near	 D71F	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 D725	  _TEXT	
int74  . . . . . . . . . . . . .	P Near	 D731	  _TEXT	Length= 004F Public
  docall . . . . . . . . . . . .	L Near	 D756	  _TEXT	
  nocall . . . . . . . . . . . .	L Near	 D775	  _TEXT	
sdinit . . . . . . . . . . . . .	P Near	 D9D2	  _TEXT	Length= 009D Public
  sdinit1  . . . . . . . . . . .	L Near	 D9DD	  _TEXT	
  repinit  . . . . . . . . . . .	L Near	 DA0D	  _TEXT	
  sdexit . . . . . . . . . . . .	L Near	 DA61	  _TEXT	
sdrblk . . . . . . . . . . . . .	P Near	 D87C	  _TEXT	Length= 0030 Public
  sdrblk1  . . . . . . . . . . .	L Near	 D884	  _TEXT	
  sdrblk2  . . . . . . . . . . .	L Near	 D889	  _TEXT	
sdwblk . . . . . . . . . . . . .	P Near	 D849	  _TEXT	Length= 0033 Public
  sdwblk1  . . . . . . . . . . .	L Near	 D84B	  _TEXT	
sendcmd  . . . . . . . . . . . .	P Near	 D7EB	  _TEXT	Length= 0011 Public
  retry  . . . . . . . . . . . .	L Near	 D7F2	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 D7FB	  _TEXT	
sendps2byte  . . . . . . . . . .	P Near	 D7AC	  _TEXT	Length= 0025 Public
  sps2b2 . . . . . . . . . . . .	L Near	 D7B2	  _TEXT	
  sps2b1 . . . . . . . . . . . .	L Near	 D7C3	  _TEXT	
  sps2_kb  . . . . . . . . . . .	L Near	 D7CB	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 D7CF	  _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0001h	 
@code  . . . . . . . . . . . . .	Text   	 DGROUP
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
AckReceived  . . . . . . . . . .	Number	 0010h	 
ActivePage . . . . . . . . . . .	Text   	 ds:[62h]
ActiveVideoMode  . . . . . . . .	Text   	 ds:[49h]
AltDown  . . . . . . . . . . . .	Number	 0008h	 
AltKpd . . . . . . . . . . . . .	Text   	 ds:[19h]
Buffer . . . . . . . . . . . . .	Text   	 ds:[80h]
COMFlush . . . . . . . . . . . .	L Near	 C20E	  _TEXT	
CapsLockDown . . . . . . . . . .	Number	 0040h	 
CapsLockLED  . . . . . . . . . .	Number	 0004h	 
CapsLock . . . . . . . . . . . .	Number	 0040h	 
ComPort  . . . . . . . . . . . .	Number	 0000h	 
CrtMode  . . . . . . . . . . . .	Text   	 ds:[65h]
CrtPalette . . . . . . . . . . .	Text   	 ds:[66h]
CtrlBreak  . . . . . . . . . . .	Text   	 ds:[71h]
CtrlDown . . . . . . . . . . . .	Number	 0004h	 
CursorPos  . . . . . . . . . . .	Text   	 ds:[50h]
CursorShape  . . . . . . . . . .	Text   	 ds:[60h]
DLH  . . . . . . . . . . . . . .	Number	 0001h	 
DLL  . . . . . . . . . . . . . .	Number	 0000h	 
DataBuffer . . . . . . . . . . .	Text   	 ds:[0a5h]
DataCounter  . . . . . . . . . .	Text   	 ds:[067h]
E0KeyIndex . . . . . . . . . . .	L Near	 DD6E	  _TEXT	
E0KeyList  . . . . . . . . . . .	L Near	 DD62	  _TEXT	
EgaMiscInfo2 . . . . . . . . . .	Text   	 ds:[88h]
EgaMiscInfo  . . . . . . . . . .	Text   	 ds:[87h]
EndBuf . . . . . . . . . . . . .	Text   	 ds:[82h]
EquipmentWord  . . . . . . . . .	Text   	 ds:[10h]
ExtSize  . . . . . . . . . . . .	L Near	 D41A	  _TEXT	
FreeXMSKb  . . . . . . . . . . .	Number	 7B60h	 
GetConfig  . . . . . . . . . . .	L Near	 D41F	  _TEXT	
HDLastError  . . . . . . . . . .	Text   	 ds:[74h]
HDOpStarted  . . . . . . . . . .	Text   	 ds:[92h]
HDSize . . . . . . . . . . . . .	Text   	 ds:[94h]
HandlerPtr . . . . . . . . . . .	Text   	 ds:[0a1h]
HeadPtr  . . . . . . . . . . . .	Text   	 ds:[1ah]
IER  . . . . . . . . . . . . . .	Number	 0001h	 
IncSeg1  . . . . . . . . . . . .	L Near	 D2D6	  _TEXT	
IncSeg . . . . . . . . . . . . .	L Near	 D2C8	  _TEXT	
InsDown  . . . . . . . . . . . .	Number	 0080h	 
Insert . . . . . . . . . . . . .	Number	 0080h	 
KbdFlags1  . . . . . . . . . . .	Text   	 ds:[17h]
KbdFlags2  . . . . . . . . . . .	Text   	 ds:[18h]
KbdFlags3  . . . . . . . . . . .	Text   	 ds:[96h]
KbdFlags4  . . . . . . . . . . .	Text   	 ds:[97h]
KeyCode  . . . . . . . . . . . .	L Near	 DD7A	  _TEXT	
KeyIndex . . . . . . . . . . . .	L Near	 DD09	  _TEXT	
LAltDown . . . . . . . . . . . .	Number	 0002h	 
LCR  . . . . . . . . . . . . . .	Number	 0003h	 
LCtrDown . . . . . . . . . . . .	Number	 0001h	 
LEDUpdate  . . . . . . . . . . .	Number	 0040h	 
LSR  . . . . . . . . . . . . . .	Number	 0005h	 
LShfDown . . . . . . . . . . . .	Number	 0002h	 
LastE0 . . . . . . . . . . . . .	Number	 0002h	 
LastE1 . . . . . . . . . . . . .	Number	 0001h	 
LastF0 . . . . . . . . . . . . .	Number	 0020h	 
MSR  . . . . . . . . . . . . . .	Number	 0006h	 
MemorySize . . . . . . . . . . .	Text   	 ds:[13h]
Mouse  . . . . . . . . . . . . .	L Near	 D428	  _TEXT	
MovExt1  . . . . . . . . . . . .	L Near	 D33F	  _TEXT	
MovExt2  . . . . . . . . . . . .	L Near	 D351	  _TEXT	
MovExtLoop . . . . . . . . . . .	L Near	 D336	  _TEXT	
MovExtProxy  . . . . . . . . . .	L Near	 D38F	  _TEXT	
MovExt_exit  . . . . . . . . . .	L Near	 D377	  _TEXT	
MovExt_next  . . . . . . . . . .	L Near	 D364	  _TEXT	
MovExt . . . . . . . . . . . . .	L Near	 D2F6	  _TEXT	
MovSeg . . . . . . . . . . . . .	Number	 0001h	 
NumLockDown  . . . . . . . . . .	Number	 0020h	 
NumLockLED . . . . . . . . . . .	Number	 0002h	 
NumLock  . . . . . . . . . . . .	Number	 0020h	 
PacketSize . . . . . . . . . . .	Text   	 ds:[068h]
PageOffset . . . . . . . . . . .	Text   	 ds:[4eh]
Pal256 . . . . . . . . . . . . .	L Near	 DA99	  _TEXT	
PalEGA . . . . . . . . . . . . .	L Near	 DB69	  _TEXT	
PalOffset  . . . . . . . . . . .	Text   	 ds:[69h]
PalVGA . . . . . . . . . . . . .	L Near	 DC39	  _TEXT	
Pause  . . . . . . . . . . . . .	Number	 0008h	 
PortAddress  . . . . . . . . . .	Text   	 ds:[63h]
RAMSize  . . . . . . . . . . . .	Number	 0200h	 
RAltDown . . . . . . . . . . . .	Number	 0008h	 
RBR  . . . . . . . . . . . . . .	Number	 0000h	 
RCtrDown . . . . . . . . . . . .	Number	 0004h	 
RShfDown . . . . . . . . . . . .	Number	 0001h	 
RegenLength  . . . . . . . . . .	Text   	 ds:[4ch]
SCANCODE1  . . . . . . . . . . .	Number	 0001h	 
SD_CMD0  . . . . . . . . . . . .	Byte	 DA6F	  _TEXT	
SD_CMD12 . . . . . . . . . . . .	Byte	 DA81	  _TEXT	
SD_CMD41 . . . . . . . . . . . .	Byte	 DA87	  _TEXT	
SD_CMD55 . . . . . . . . . . . .	Byte	 DA8D	  _TEXT	
SD_CMD58 . . . . . . . . . . . .	Byte	 DA93	  _TEXT	
SD_CMD8  . . . . . . . . . . . .	Byte	 DA75	  _TEXT	
SD_CMD9  . . . . . . . . . . . .	Byte	 DA7B	  _TEXT	
ScanLinesChar  . . . . . . . . .	Text   	 ds:[85h]
ScrLockDown  . . . . . . . . . .	Number	 0010h	 
ScrLockLED . . . . . . . . . . .	Number	 0001h	 
ScrLock  . . . . . . . . . . . .	Number	 0010h	 
ScreenRows . . . . . . . . . . .	Text   	 ds:[84h]
ScreenWidth  . . . . . . . . . .	Text   	 ds:[4ah]
SetEventWait . . . . . . . . . .	L Near	 D3CC	  _TEXT	
SetRepeat  . . . . . . . . . . .	Number	 0008h	 
SetSeg1  . . . . . . . . . . . .	L Near	 D2EE	  _TEXT	
SetSeg2  . . . . . . . . . . . .	L Near	 D2E6	  _TEXT	
SetSegExit . . . . . . . . . . .	L Near	 D2EF	  _TEXT	
SetSeg . . . . . . . . . . . . .	L Near	 D2DB	  _TEXT	
SysParams  . . . . . . . . . . .	Byte	 D542	  _TEXT	
SysReqDown . . . . . . . . . . .	Number	 0004h	 
THR  . . . . . . . . . . . . . .	Number	 0000h	 
TailPtr  . . . . . . . . . . . .	Text   	 ds:[1ch]
UFPtr  . . . . . . . . . . . . .	Text   	 ds:[98h]
UWaitFlag  . . . . . . . . . . .	Text   	 ds:[0a0h]
VESAInfo . . . . . . . . . . . .	Byte	 C660	  _TEXT	
VESAModes  . . . . . . . . . . .	Word	 C687	  _TEXT	
VESAOEM  . . . . . . . . . . . .	Byte	 C674	  _TEXT	
VgaFlags2  . . . . . . . . . . .	Text   	 ds:[8ah]
VgaFlags . . . . . . . . . . . .	Text   	 ds:[89h]
Wait1  . . . . . . . . . . . . .	L Near	 D401	  _TEXT	
WaitCount  . . . . . . . . . . .	Text   	 ds:[9ch]
badparam . . . . . . . . . . . .	L Near	 D4A9	  _TEXT	
bioscont . . . . . . . . . . . .	Byte	 C275	  _TEXT	
biosmsg  . . . . . . . . . . . .	Byte	 C000	  _TEXT	
bios . . . . . . . . . . . . . .	L Near	 C000	  _TEXT	
booterrmsg . . . . . . . . . . .	Byte	 D66C	  _TEXT	
busy . . . . . . . . . . . . . .	L Near	 D3FD	  _TEXT	
cancel . . . . . . . . . . . . .	L Near	 D3F6	  _TEXT	
coldboot . . . . . . . . . . . .	L Near	 C05B	  _TEXT	
crtc0  . . . . . . . . . . . . .	Byte	 C69E	  _TEXT	
crtc10 . . . . . . . . . . . . .	Byte	 C731	  _TEXT	
crtc12 . . . . . . . . . . . . .	Byte	 C746	  _TEXT	
crtc13 . . . . . . . . . . . . .	Byte	 C75B	  _TEXT	
crtc1  . . . . . . . . . . . . .	Byte	 C6B3	  _TEXT	
crtc4  . . . . . . . . . . . . .	Byte	 C6C8	  _TEXT	
crtc5  . . . . . . . . . . . . .	Byte	 C6DD	  _TEXT	
crtc6  . . . . . . . . . . . . .	Byte	 C6F2	  _TEXT	
crtc7  . . . . . . . . . . . . .	Byte	 C707	  _TEXT	
crtc9  . . . . . . . . . . . . .	Byte	 C71C	  _TEXT	
dac10  . . . . . . . . . . . . .	Byte	 C770	  _TEXT	
dccval . . . . . . . . . . . . .	Word	 CF99	  _TEXT	
disablemouseinterrupt  . . . . .	L Near	 D528	  _TEXT	
disktbl  . . . . . . . . . . . .	Word	 D0A5	  _TEXT	
dispAX1  . . . . . . . . . . . .	L Near	 D818	  _TEXT	
dispAX . . . . . . . . . . . . .	L Near	 D809	  _TEXT	
dly1 . . . . . . . . . . . . . .	L Near	 D7A3	  _TEXT	
dlybit . . . . . . . . . . . . .	L Near	 D79F	  _TEXT	
done . . . . . . . . . . . . . .	L Near	 D3C3	  _TEXT	
en_dis . . . . . . . . . . . . .	L Near	 D47C	  _TEXT	
enablemouseinterrupt . . . . . .	L Near	 D515	  _TEXT	
errexit  . . . . . . . . . . . .	L Near	 D439	  _TEXT	
exit15 . . . . . . . . . . . . .	L Near	 D3C4	  _TEXT	
exit_ax  . . . . . . . . . . . .	L Near	 D3C7	  _TEXT	
exit_iret  . . . . . . . . . . .	L Near	 D3CB	  _TEXT	
exit_success1  . . . . . . . . .	L Near	 D491	  _TEXT	
exit_success . . . . . . . . . .	L Near	 D48C	  _TEXT	
exitok . . . . . . . . . . . . .	L Near	 D43A	  _TEXT	
extend . . . . . . . . . . . . .	L Near	 D4E7	  _TEXT	
font8x14 . . . . . . . . . . . .	Text   	 font8x16 - 0e00h
font8x16 . . . . . . . . . . . .	Text   	 font8x8 - 1000h
font8x8  . . . . . . . . . . . .	Text   	 bios - 800h
fontinfo . . . . . . . . . . . .	Word	 CF27	  _TEXT	
gettype  . . . . . . . . . . . .	L Near	 D4CF	  _TEXT	
if_err1  . . . . . . . . . . . .	L Near	 D48A	  _TEXT	
if_err . . . . . . . . . . . . .	L Near	 D434	  _TEXT	
int15  . . . . . . . . . . . . .	L Near	 D392	  _TEXT	
kbi1 . . . . . . . . . . . . . .	L Near	 C174	  _TEXT	
kbi2 . . . . . . . . . . . . . .	L Near	 C183	  _TEXT	
kbok . . . . . . . . . . . . . .	L Near	 C1B7	  _TEXT	
l1 . . . . . . . . . . . . . . .	L Near	 D794	  _TEXT	
mapi1  . . . . . . . . . . . . .	L Near	 C0A2	  _TEXT	
mapi . . . . . . . . . . . . . .	L Near	 C099	  _TEXT	
mouse_present  . . . . . . . . .	L Near	 D449	  _TEXT	
mousei0  . . . . . . . . . . . .	L Near	 C1BF	  _TEXT	
mousei1  . . . . . . . . . . . .	L Near	 C1CD	  _TEXT	
mouseok  . . . . . . . . . . . .	L Near	 C1E9	  _TEXT	
msgkb  . . . . . . . . . . . . .	Byte	 C042	  _TEXT	
msgmb  . . . . . . . . . . . . .	Byte	 C035	  _TEXT	
msgmouse . . . . . . . . . . . .	Byte	 C260	  _TEXT	
nokbmsg  . . . . . . . . . . . .	L Near	 C245	  _TEXT	
nokb . . . . . . . . . . . . . .	L Near	 C1B2	  _TEXT	
nomousemsg . . . . . . . . . . .	L Near	 C252	  _TEXT	
nomouse  . . . . . . . . . . . .	L Near	 C1E0	  _TEXT	
nowait . . . . . . . . . . . . .	L Near	 D3FE	  _TEXT	
p3c0r10  . . . . . . . . . . . .	Byte	 C69D	  _TEXT	
paltable . . . . . . . . . . . .	Word	 CC74	  _TEXT	
prtse  . . . . . . . . . . . . .	L Near	 D82E	  _TEXT	
prts . . . . . . . . . . . . . .	L Near	 D822	  _TEXT	
raligned . . . . . . . . . . . .	L Near	 D35D	  _TEXT	
reset  . . . . . . . . . . . . .	L Near	 D495	  _TEXT	
resolution . . . . . . . . . . .	L Near	 D4C5	  _TEXT	
sample_tbl . . . . . . . . . . .	Byte	 D53B	  _TEXT	
sampling . . . . . . . . . . . .	L Near	 D4A6	  _TEXT	
savesp . . . . . . . . . . . . .	Word	 D2F2	  _TEXT	
savess . . . . . . . . . . . . .	Word	 D2F0	  _TEXT	
sc1  . . . . . . . . . . . . . .	Byte	 C785	  _TEXT	
sdcmd1 . . . . . . . . . . . . .	L Near	 D8D3	  _TEXT	
sdcmd8T  . . . . . . . . . . . .	L Near	 D8BD	  _TEXT	
sdcmd  . . . . . . . . . . . . .	L Near	 D8C0	  _TEXT	
sdr11  . . . . . . . . . . . . .	L Near	 D948	  _TEXT	
sdr1s  . . . . . . . . . . . . .	L Near	 D8E8	  _TEXT	
sdr1 . . . . . . . . . . . . . .	L Near	 D949	  _TEXT	
sdr2 . . . . . . . . . . . . . .	L Near	 D93F	  _TEXT	
sdr3 . . . . . . . . . . . . . .	L Near	 D932	  _TEXT	
sdrb . . . . . . . . . . . . . .	L Near	 D82F	  _TEXT	
sdread1  . . . . . . . . . . . .	L Near	 D8DC	  _TEXT	
sdread . . . . . . . . . . . . .	L Near	 D8D9	  _TEXT	
sdresp1  . . . . . . . . . . . .	L Near	 D8C8	  _TEXT	
sdresp . . . . . . . . . . . . .	L Near	 D8C6	  _TEXT	
sdrms  . . . . . . . . . . . . .	L Near	 D909	  _TEXT	
sdsb . . . . . . . . . . . . . .	L Near	 D831	  _TEXT	
sdvblk1  . . . . . . . . . . . .	L Near	 D8AF	  _TEXT	
sdvblk . . . . . . . . . . . . .	L Near	 D8AC	  _TEXT	
sdverify . . . . . . . . . . . .	L Near	 D8D4	  _TEXT	
sdw1s1 . . . . . . . . . . . . .	L Near	 D998	  _TEXT	
sdw1s  . . . . . . . . . . . . .	L Near	 D960	  _TEXT	
sdwms  . . . . . . . . . . . . .	L Near	 D981	  _TEXT	
sdwrite  . . . . . . . . . . . .	L Near	 D954	  _TEXT	
sdwwait1 . . . . . . . . . . . .	L Near	 D9C8	  _TEXT	
sdwwait  . . . . . . . . . . . .	L Near	 D9B1	  _TEXT	
send1c . . . . . . . . . . . . .	L Near	 D4BF	  _TEXT	
send2c . . . . . . . . . . . . .	L Near	 D4B8	  _TEXT	
setscaling . . . . . . . . . . .	L Near	 D50A	  _TEXT	
srecb  . . . . . . . . . . . . .	L Near	 D780	  _TEXT	
srstb  . . . . . . . . . . . . .	L Near	 D788	  _TEXT	
staticfunctable  . . . . . . . .	Byte	 CFFE	  _TEXT	
ten  . . . . . . . . . . . . . .	Word	 D820	  _TEXT	
vidtbl . . . . . . . . . . . . .	Word	 D00E	  _TEXT	
warmboot . . . . . . . . . . . .	L Near	 C05B	  _TEXT	
wbusy  . . . . . . . . . . . . .	L Near	 D416	  _TEXT	
wloop  . . . . . . . . . . . . .	L Near	 D40F	  _TEXT	

	   0 Warnings
	   0 Errors
